Public blockchain networks are revolutionising modern society by facilitating decentralised, immutable and verifiable data exchange. At the heart of these networks are consensus protocols that enable state machine replication (SMR). A blockchain network is a form of distributed state machine, which is transitioned from one state to another by applying client-submitted instructions called transactions. SMR protocols ensure that every node in the network maintains a consistent state by facilitating their agreement upon the order in which these transactions should be executed. A Byzantine Fault Tolerant (BFT) SMR protocol is one that tolerates a fixed number of faulty participants. These faulty processes, termed Byzantine, may crash or deviate arbitrarily from the protocol, but are assumed to be unable to break cryptographic primitives like signatures. Blockchain-based SMR protocols group transactions into blocks, with each new block committed by the network referencing the previously committed one as its parent, thus forming the blockchain.

Several such protocols have been proposed [citations], some of them also formally verified [citations]. New ones are being proposed, to improve certains aspects. Two such aspects are block period and commit latency. Block period is the delay between consecutive block proposals. Commit latency is the delay between proposal of a block and achieving $2/3$ majority of processes committing the block. Chained Moonshot protocol achieves better block period and commit latency compared to other similar protocols [citations].

One of the main desirable properties of such protocols is \emph{safety}: any two honest processes must agree on the set of transactions executed and the order in which they are executed. Formally, if two honest processes have committed chains of blocks, then one of the chains must be (not necessarily strict) prefix of the other one. Chained Moonshot protocol is proved to be safe and live [citation], with a handwritten proof. The goal of this project is to give a proof of safety in a formal verification tool. The usage of such protocols in commercial settings makes mistakes in their design costly. On the other hand, distributed systems are inherently complex and trying to squeeze as little block period and commit latency as possible makes them even more complicated. Designing protocols and proving them correct by hand are notoriously prone to errors; see [Holistic Verification of Blockchain Consensus, DISC 2022] and references therein.

We chose a tool called IVy for this project. Ivy is a language and a tool for the formal specification and verification of distributed systems. Ivy supports deductive verification using automated provers, model checking, automated testing, manual theorem proving and generation of executable code. In order to achieve greater verification productivity, a key design goal for Ivy is to allow the engineer to apply automated provers in the realm in which their performance is relatively predictable, stable and transparent. In particular Ivy focuses on the use of decidable fragments of first-order logic.

\paragraph{Our Contribution}
\begin{itemize}
	\item We formally model the chained Moonshot protocol in Ivy.
	\item Within Ivy, we formally verify that the proof of safety as given in [citation] is correct.
	\item Within Ivy, we explicitly state and prove many facts that are used implicitly in the handwritten safety proof.
	\item For proving properties in Ivy, we need to manually write invariants of the protocol that are inductive and also imply the desired safety property that we wish to prove. We identify several properties the conjunction of which is proved to be inductive by Ivy and also imply the desired safety property.
\end{itemize}

\paragraph{Related Work} Formal verification of distributed consensus protocols have been done before. The safety and liveness of the Tendermint protocol has been formally verified [citation] in Ivy. A simplified version of HotStuff protocol is formally verified to be safe in Ivy as well as TLA, a formal specification and verification tool. Multi-Paxos protocol has been formally verified to be safe in TLA\textsuperscript{+} [FM2016]. There have been many attempts at formally verifying Paxos and its many variants [PaxosMadeEPR, AutomaticProofOfPaxosIC3PO], trying to automate the verification as much as possible. TODO: Ironfleet, Verdi

The above works are based on deductive verification, with the protocol modeled in languages based on a logical language and the properties to be proved are converted to (un)satisfiability of formulas. Another approach is model checking, where the protocol is modeled as a state machine and the desired properties are written in variants of temporal logics. Algorithms then attempt to verify that the state machine satisfies the temporal properties. PSync [citation] and related tools use this approach. The RedBelly block chain consensus protocol has been verified for safety and liveness using this approach [citation].

Even after a protocol has been formally proved to be correct, its actual implementation may be incorrect due to other issues. Very often, protocol specifications use abstractions to describe some aspects of the protocol that may be subject to different refinements by implementers. This process may introduce errors in the program. Aiming to capture such errors, in [citation], the reference implementation of the Ethereum 2.0 Beacon chain has been formally verified.

