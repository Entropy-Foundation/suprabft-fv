In this section we give some details of the system we want to formally verify and setup the scope and goal of our experiment.

\subsection{System Description of the Chained Moonshot SMR protocol}
The system under study is a block-chain based SMR protocol, in which client transactions are grouped in blocks that explicitly refer to one another to form a blockchain. A set of processes $\prcs$ participate in the protocol. Some of the processes may be faulty --- they may crash or deviate arbitrarily from the protocol. Such faulty processes are termed \emph{Byzantine}. It is assumed that less than one thirds of the processes are Byzantine and that they are unable to break cryptographic primitives like signatures. It is assumed that each block refers to at most one previously proposed block as its \emph{parent}, and that these blocks are proposed in sequential \emph{rounds} by an elected \emph{leader} process, which may be distinct for different rounds. Every process $v \in \prcs$ maintains a local copy, denoted by $\blkchn_v$, of the \emph{canonical blockchain}.

The formal safety property is that for every run of the protocol, for each pair of honest processes $(v_i,v_j) \in \prcs \times \prcs$, either $\blkchn_{v_i}$ is a (not necessarily strict) prefix of $\blkchn_{v_j}$ or vice-versa.

The chained Moonshot protocol achieves better block period and commit latency via some optimizations, which we explain by first describing the simpler Tendermint protocol [citation]. Tendermint is an adaptation of the Practical Byzantine Fault Tolerant (PBFT) protocol [citation] to the blockchain setting. One instance of the Tendermint protocol aims to achieve consensus for appending one block to the canonical block chain. Each instance proceeds in three phases: \emph{Propose, Prepare} and \emph{Commit}. In the first phase, the leader of the current round multicasts a block in a signed Proposal message. A validator then enters the Prepare phase after receiving a valid Proposal from the leader, and re-multicasts it along with a Prepare message to indicate its endorsement of the Proposal. The validator then waits to receive a quorum of valid Prepare messages and then constructs a Prepare Quorum Certificate (Prepare QC) as verifiable proof that a quorum of processes have accepted the leaderâ€™s proposal. After forming this QC, the process enters the Commit phase and multicasts a Commit message as a second endorsement of the Proposal. As before, the process then waits to receive a quorum of valid Commit messages before forming Commit Quorum Certificate and committing the block.

Chained HotStuff [citation]  introduced the concept of a message serving multiple purposes, allowing leaders to create new proposals justified by the prepare QC of the proposal of their predecessor. The Chained Moonshot protocol takes this observation one step further, wherein the Prepare phase of an earlier round can be safely overlapped with the Propose phases of later ones. Some proposals may fail due to various reasons and the parent of a block need not be the one proposed in the previous round, but several rounds before. Some parts of the safety proof thus proceeds by induction on number of rounds.  Some rules of the protocol refer to ancestors of a block. The ancestor relation is the transitive closure of the parent relation. Neither induction nor transitive closure are definable in first-order logic. These are some of the challenges we faced, which we will come back to later.

\subsection{Ivy verification tool}
Ivy is a language and a tool for the formal specification and verification of distributed systems. Systems are represented as state transition machines. States are multi-sorted first-order structures, with relations and functions. Transitions specify how the state is muted. Any update definable in first-order logic is supported. Update instructions can be given in sequence one after another, giving the syntax the flavor of an imperative programming language. Multiple update instructions can be grouped together into an \emph{action}, a keyword in Ivy used to denote state transition specifications.

The system under consideration can be split into multiple modules, with internal states of a module not allowed to be modified directly by other modules. One module can call actions of another module, passing parameters. Modules can reason about one another using assume gurantee specifications, which are formulas specifying properties of the modules' states. Properties of the overall system has to be proved by writing \emph{inductive invariants}, which are properties satisfying two conditions --- initiation and inductiveness. Initiation means that the initial state of the system satisfies the invariant. Inductiveness means that if any of the actions are executed in any state that satisfies the invariant, the resulting state also satisfies the invariant.

\subsection{Objectives and Scope of the Experiment}
The objective of this project is to formally verify the safety of chained Moonshot protocol. Formal verification ensures that there are no errors in the reasoning underlying the handwritten proof. The development and proof of safety and liveness of the chained Moonshot protocol underwent many cycles (some modificatins to ensure liveness and some for simplifying the specification and proofs). The process of formally verifying safety uncovered some points in the specifications and proofs that were ambiguous and helped better understand many details that were implicit in the handwritten proofs.

Only a high level abstract specification of the protocol is modeled and verified. Some implementation details are hence modeled with Boolean abstractions. For example, timers used in the protocol are replaced by Boolean propositions that indicate whether or not a timer has expired. In the Ivy model, the Boolean proposition can switch value anytime non-deterministically to simulate a timer getting expired or reset, instead of tracking the actual time elapsed since the last reset. This is a sound abstraction for proving safety.

Another abstraction we have adapted from the literature is handling quorums. The protocol specification mandates that a process needs to receive messages from two thirds majority of all processes in order to achieve a quorum. Verifying this detail would require having arithmetic in the formulas passed on to SMT solvers, potentially affecting the solvers' performance. Instead, what is modeled is the \emph{quorum intersection property} [citation] --- any two quorums have at least one common honest process. It is this property of quorums that are mainly used in correctness proofs and is modeled in Ivy as an axiom, avoiding the usage of arithmetic.

Processes receive messages from the network and verify their authenticity by checking digital signatures. It is assumed that Byzantine processes cannot break cryptographic primitives and hence they cannot imitate signatures of honest processes. Checking digital signatures is not modeled in Ivy --- the model assumes messages sent by honest processes are authentic. The model also disallows byzantine processes to send messages on behalf of other honest process, though they can send any kind of message on behalf of other byzantine processes, even if such a message is not mandated to be sent by the protocol specification.