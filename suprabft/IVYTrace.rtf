{\rtf1\ansi\ansicpg1252\cocoartf2580
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red255\green255\blue255;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c100000\c100000\c100000;}
\paperw11900\paperh16840\margl1440\margr1440\vieww27120\viewh12540\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs48 \cf2 \cb3 \CocoaLigature0 call basic_safety.validator.process_prepareQC\
\
\{\
    [\
        fml:qc = 2\
        prm:V0 = 0\
    ]\
classic_safety.ivy: line 14: \
    assume forall N1. (forall N2. (forall B1. (forall B2. is_good(N1) & is_good(N2) & gv.node_has_quorum(N1,B1) & gv.node_has_quorum(N2,B2) & block_t.round(B1) = block_t.round(B2) -> B1 = B2)))\
\
classic_safety.ivy: line 10: \
    assume forall N. (forall B1. (forall B2. is_good(N) & gv.node_has_voted(N,B1) & gv.node_has_voted(N,B2) & block_t.round(B1) = block_t.round(B2) -> B1 = B2))\
\
classic_safety.ivy: line 12: \
    assume forall N. (forall B. gv.node_has_quorum(N,B) -> (exists Q. (forall N1. quorum_t.member(N1,Q) -> gv.node_has_voted(N1,B))))\
\
classic_safety.ivy: line 21: \
    assume forall Bc. (forall Bp. block_t.parent(Bc) = block_t.hash(Bp) -> block_t.round(Bp) < block_t.round(Bc))\
\
algorithm.ivy: line 292: \
    assume basic_safety.validator.rcvd_qc(prm:V0,fml:qc) & basic_safety.validator.valid_qc(prm:V0,fml:qc)\
\
algorithm.ivy: line 294: \
    loc:ok := true\
\
    [\
        loc:ok = true\
    ]\
algorithm.ivy: line 295: \
    loc:ok := loc:ok & cert_t.block(fml:qc) ~= block_t.nil\
\
algorithm.ivy: line 296: \
    loc:ok := loc:ok & block_t.parent(cert_t.block(fml:qc)) ~= block_t.hash(block_t.nil)\
\
algorithm.ivy: line 297: \
    loc:ok := loc:ok & (forall H. basic_safety.validator.blockchain(prm:V0,H) ~= cert_t.block(fml:qc))\
\
algorithm.ivy: line 298: \
    loc:ok := loc:ok & (forall Q. (forall H. basic_safety.validator.forest_store(prm:V0,Q,H) -> cert_t.block(Q) ~= cert_t.block(fml:qc)))\
\
algorithm.ivy: line 299: \
    loc:ok := loc:ok & (forall H. ~basic_safety.validator.forest_store(prm:V0,fml:qc,H))\
\
    assume true\
\
    [\
        loc:ql = 1\
    ]\
    assume true\
\
    [\
        loc:hl = 0\
    ]\
    assume true\
\
    [\
        fml:y = 1\
    ]\
algorithm.ivy: line 312: \
    call loc:0 := height_t.next(loc:hl)\
    \{\
        [\
            fml:x = 0\
        ]\
/Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 38: \
        assume fml:x < fml:y & (fml:x < Y -> fml:y <= Y)\
\
/Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 39: \
        assume height_t.succ(fml:x,fml:y)\
\
    \}\
\
    [\
        loc:0 = 1\
    ]\
algorithm.ivy: line 312: \
    basic_safety.validator.forest_store(prm:V0,fml:qc,loc:0) := true\
\
    [\
        basic_safety.validator.forest_store(0,2,1) = true\
    ]\
algorithm.ivy: line 313: \
    call loc:0 := height_t.next(loc:hl)\
    \{\
/Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 38: \
        assume fml:x < fml:y & (fml:x < Y -> fml:y <= Y)\
\
/Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 39: \
        assume height_t.succ(fml:x,fml:y)\
\
    \}\
\
algorithm.ivy: line 313: \
    call loc:1 := height_t.next(loc:hl)\
    \{\
/Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 38: \
        assume fml:x < fml:y & (fml:x < Y -> fml:y <= Y)\
\
/Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 39: \
        assume height_t.succ(fml:x,fml:y)\
\
    \}\
\
    [\
        loc:1 = 1\
    ]\
algorithm.ivy: line 313: \
    basic_safety.validator.forest_ancestor(prm:V0,fml:qc,loc:0,fml:qc,loc:1) := true\
\
    [\
        basic_safety.validator.forest_ancestor(0,2,1,2,1) = true\
    ]\
algorithm.ivy: line 314: \
    call loc:0 := height_t.next(loc:hl)\
    \{\
/Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 38: \
        assume fml:x < fml:y & (fml:x < Y -> fml:y <= Y)\
\
/Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 39: \
        assume height_t.succ(fml:x,fml:y)\
\
    \}\
\
algorithm.ivy: line 314: \
    basic_safety.validator.forest_ancestor(prm:V0,fml:qc,loc:0,loc:ql,loc:hl) := true\
\
    [\
        basic_safety.validator.forest_ancestor(0,2,1,1,0) = true\
        basic_safety.validator.forest_strictAncestor(0,2,1,1,0) = true\
    ]\
algorithm.ivy: line 315: \
    call loc:0 := height_t.next(loc:hl)\
    \{\
/Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 38: \
        assume fml:x < fml:y & (fml:x < Y -> fml:y <= Y)\
\
/Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 39: \
        assume height_t.succ(fml:x,fml:y)\
\
    \}\
\
algorithm.ivy: line 315: \
    call loc:1 := height_t.next(loc:hl)\
    \{\
/Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 38: \
        assume fml:x < fml:y & (fml:x < Y -> fml:y <= Y)\
\
/Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 39: \
        assume height_t.succ(fml:x,fml:y)\
\
    \}\
\
algorithm.ivy: line 315: \
    basic_safety.validator.forest_ancestor(prm:V0,fml:qc,loc:0,Q,H) := basic_safety.validator.forest_ancestor(prm:V0,loc:ql,loc:hl,Q,H) | Q = fml:qc & H = loc:1\
\
    [\
        basic_safety.validator.forest_ancestor(0,2,1,1,0) = false\
        basic_safety.validator.forest_strictAncestor(0,2,1,1,0) = false\
    ]\
algorithm.ivy: line 317: \
    call loc:0 := height_t.next(loc:hl)\
    \{\
/Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 38: \
        assume fml:x < fml:y & (fml:x < Y -> fml:y <= Y)\
\
/Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 39: \
        assume height_t.succ(fml:x,fml:y)\
\
    \}\
\
algorithm.ivy: line 317: \
    assert is_good(prm:V0) -> ~basic_safety.validator.forest_root(prm:V0,fml:qc,loc:0)\
\
algorithm.ivy: line 319: \
    call basic_safety.validator.broadcast_qc(prm:V0, fml:qc)\
    \{\
        [\
            fml:qc_a = 2\
            prm:V0_a = 0\
            loc:m = 0\
        ]\
algorithm.ivy: line 128: \
        msg.kind(loc:m) := msg_kind.qc\
\
algorithm.ivy: line 129: \
        msg.qc(loc:m) := fml:qc\
\
algorithm.ivy: line 130: \
        msg.src(loc:m) := prm:V0\
\
algorithm.ivy: line 132: \
        call shim.broadcast(prm:V0, loc:m)\
        \{\
            [\
                fml:m = 0\
                fml:src = 0\
            ]\
network_model.ivy: line 54: \
            shim.sent(fml:m,D) := true\
\
            [\
                shim.sent(0,0) = true\
                shim.sent(0,1) = true\
            ]\
classic_safety.ivy: line 14: \
            assume forall N1. (forall N2. (forall B1. (forall B2. is_good(N1) & is_good(N2) & gv.node_has_quorum(N1,B1) & gv.node_has_quorum(N2,B2) & block_t.round(B1) = block_t.round(B2) -> B1 = B2)))\
\
classic_safety.ivy: line 10: \
            assume forall N. (forall B1. (forall B2. is_good(N) & gv.node_has_voted(N,B1) & gv.node_has_voted(N,B2) & block_t.round(B1) = block_t.round(B2) -> B1 = B2))\
\
classic_safety.ivy: line 12: \
            assume forall N. (forall B. gv.node_has_quorum(N,B) -> (exists Q. (forall N1. quorum_t.member(N1,Q) -> gv.node_has_voted(N1,B))))\
\
        \}\
\
    \}\
\
algorithm.ivy: line 320: \
    call basic_safety.validator.tryLockAndCommit(prm:V0, fml:qc)\
    \{\
algorithm.ivy: line 235: \
        assert fml:qc ~= cert_t.nil & basic_safety.validator.rcvd_qc(prm:V0,fml:qc)\
\
algorithm.ivy: line 236: \
        assert block_t.parent(cert_t.block(fml:qc)) ~= block_t.hash(block_t.nil)\
\
algorithm.ivy: line 238: \
        loc:ok := true\
\
algorithm.ivy: line 239: \
        loc:ok := loc:ok & round_t.succ(block_t.round(cert_t.block(basic_safety.validator.locked(prm:V0))),block_t.round(cert_t.block(fml:qc)))\
\
algorithm.ivy: line 240: \
        loc:ok := loc:ok & block_t.parent(cert_t.block(fml:qc)) = block_t.hash(cert_t.block(basic_safety.validator.locked(prm:V0)))\
\
        [\
            loc:hc = 1\
        ]\
        assume true\
\
algorithm.ivy: line 244: \
        basic_safety.validator.forest_store(prm:V0,Q,H) := basic_safety.validator.forest_ancestor(prm:V0,fml:qc,loc:hc,Q,H)\
\
        [\
            basic_safety.validator.forest_leaf(0,1,0) = false\
            basic_safety.validator.forest_leaf(0,1,1) = false\
            basic_safety.validator.forest_store(0,1,0) = false\
            basic_safety.validator.forest_store(0,1,1) = false\
            basic_safety.validator.forest_root(0,1,0) = false\
            basic_safety.validator.forest_root(0,1,1) = false\
        ]\
algorithm.ivy: line 245: \
        basic_safety.validator.forest_ancestor(prm:V0,Q1,H1,Q2,H2) := basic_safety.validator.forest_ancestor(prm:V0,Q1,H1,Q2,H2) & basic_safety.validator.forest_ancestor(prm:V0,fml:qc,loc:hc,Q1,H1) & basic_safety.validator.forest_ancestor(prm:V0,fml:qc,loc:hc,Q2,H2)\
\
algorithm.ivy: line 246: \
        basic_safety.validator.forest_ancestor := *\
\
        [\
            basic_safety.validator.forest_ancestor(0,2,1,2,1) = false\
        ]\
algorithm.ivy: line 246: \
        basic_safety.validator.forest_succ := *\
\
algorithm.ivy: line 246: \
        basic_safety.validator.forest_strictAncestor := *\
\
algorithm.ivy: line 246: \
        basic_safety.validator.forest_root := *\
\
algorithm.ivy: line 246: \
        basic_safety.validator.forest_root_child := *\
\
algorithm.ivy: line 246: \
        basic_safety.validator.forest_store := *\
\
        [\
            basic_safety.validator.forest_store(0,2,1) = false\
        ]\
algorithm.ivy: line 246: \
        basic_safety.validator.blockchain := *\
\
algorithm.ivy: line 246: \
        basic_safety.validator.forest_leaf := *\
\
algorithm.ivy: line 246: \
        basic_safety.validator.chain_size := *\
\
        [\
            basic_safety.validator.chain_size(0) = 1\
            basic_safety.validator.chain_size(1) = 1\
        ]\
algorithm.ivy: line 286: \
        basic_safety.validator.locked(prm:V0) := fml:qc\
\
        [\
            fml:b = 1\
            basic_safety.validator.locked(0) = 2\
        ]\
algorithm.ivy: line 288: \
        call gv.node_rcvd_quorum(prm:V0, cert_t.block(fml:qc), cert_t.cert(fml:qc))\
        \{\
            [\
                fml:b = 2\
                fml:q = 0\
                fml:n = 0\
            ]\
global_view.ivy: line 25: \
            assert forall N. quorum_t.member(N,fml:q) -> gv.node_has_voted(N,fml:b)\
\
global_view.ivy: line 37: \
            gv.node_has_quorum(fml:n,fml:b) := true\
\
classic_safety.ivy: line 14: \
            assume forall N1. (forall N2. (forall B1. (forall B2. is_good(N1) & is_good(N2) & gv.node_has_quorum(N1,B1) & gv.node_has_quorum(N2,B2) & block_t.round(B1) = block_t.round(B2) -> B1 = B2)))\
\
classic_safety.ivy: line 10: \
            assume forall N. (forall B1. (forall B2. is_good(N) & gv.node_has_voted(N,B1) & gv.node_has_voted(N,B2) & block_t.round(B1) = block_t.round(B2) -> B1 = B2))\
\
classic_safety.ivy: line 12: \
            assume forall N. (forall B. gv.node_has_quorum(N,B) -> (exists Q. (forall N1. quorum_t.member(N1,Q) -> gv.node_has_voted(N1,B))))\
\
        \}\
\
        [\
            fml:b = 1\
        ]\
    \}\
\
algorithm.ivy: line 321: \
    call basic_safety.validator.finished_prepareQC_processing(prm:V0, fml:qc)\
    \{\
algorithm.ivy: line 405: \
        assert basic_safety.validator.rcvd_qc(prm:V0,fml:qc)\
\
algorithm.ivy: line 407: \
        loc:ok := true\
\
        [\
            fml:y = 2\
        ]\
algorithm.ivy: line 408: \
        call loc:0 := round_t.next(block_t.round(cert_t.block(fml:qc)))\
        \{\
            [\
                fml:x = 1\
                fml:y = 1\
                fml:y = 2\
            ]\
/Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 38: \
            assume fml:x < fml:y & (fml:x < Y -> fml:y <= Y)\
\
            [\
                fml:y = 1\
                fml:y = 2\
            ]\
/Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 39: \
            assume round_t.succ(fml:x,fml:y)\
\
            [\
                fml:y = 1\
                fml:y = 2\
            ]\
classic_safety.ivy: line 14: \
            assume forall N1. (forall N2. (forall B1. (forall B2. is_good(N1) & is_good(N2) & gv.node_has_quorum(N1,B1) & gv.node_has_quorum(N2,B2) & block_t.round(B1) = block_t.round(B2) -> B1 = B2)))\
\
            [\
                fml:y = 1\
                fml:y = 2\
            ]\
classic_safety.ivy: line 10: \
            assume forall N. (forall B1. (forall B2. is_good(N) & gv.node_has_voted(N,B1) & gv.node_has_voted(N,B2) & block_t.round(B1) = block_t.round(B2) -> B1 = B2))\
\
            [\
                fml:y = 1\
                fml:y = 2\
            ]\
classic_safety.ivy: line 12: \
            assume forall N. (forall B. gv.node_has_quorum(N,B) -> (exists Q. (forall N1. quorum_t.member(N1,Q) -> gv.node_has_voted(N1,B))))\
\
            [\
                fml:y = 1\
                fml:y = 2\
            ]\
classic_safety.ivy: line 21: \
            assume forall Bc. (forall Bp. block_t.parent(Bc) = block_t.hash(Bp) -> block_t.round(Bp) < block_t.round(Bc))\
\
            [\
                fml:y = 1\
                fml:y = 2\
            ]\
        \}\
\
        [\
            fml:y = 1\
            loc:0 = 2\
            fml:y = 2\
        ]\
algorithm.ivy: line 408: \
        loc:ok := loc:ok & loc:0 > basic_safety.validator.r_c(prm:V0)\
\
        [\
            fml:y = 1\
            fml:y = 2\
        ]\
        assume true\
\
        [\
            fml:y = 1\
            fml:y = 2\
        ]\
algorithm.ivy: line 414: \
        call loc:0 := round_t.next(block_t.round(cert_t.block(fml:qc)))\
        \{\
            [\
                fml:y = 1\
                fml:y = 2\
            ]\
/Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 38: \
            assume fml:x < fml:y & (fml:x < Y -> fml:y <= Y)\
\
            [\
                fml:y = 1\
                fml:y = 2\
            ]\
/Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 39: \
            assume round_t.succ(fml:x,fml:y)\
\
            [\
                fml:y = 1\
                fml:y = 2\
            ]\
classic_safety.ivy: line 14: \
            assume forall N1. (forall N2. (forall B1. (forall B2. is_good(N1) & is_good(N2) & gv.node_has_quorum(N1,B1) & gv.node_has_quorum(N2,B2) & block_t.round(B1) = block_t.round(B2) -> B1 = B2)))\
\
            [\
                fml:y = 1\
                fml:y = 2\
            ]\
classic_safety.ivy: line 10: \
            assume forall N. (forall B1. (forall B2. is_good(N) & gv.node_has_voted(N,B1) & gv.node_has_voted(N,B2) & block_t.round(B1) = block_t.round(B2) -> B1 = B2))\
\
            [\
                fml:y = 1\
                fml:y = 2\
            ]\
classic_safety.ivy: line 12: \
            assume forall N. (forall B. gv.node_has_quorum(N,B) -> (exists Q. (forall N1. quorum_t.member(N1,Q) -> gv.node_has_voted(N1,B))))\
\
            [\
                fml:y = 1\
                fml:y = 2\
            ]\
classic_safety.ivy: line 21: \
            assume forall Bc. (forall Bp. block_t.parent(Bc) = block_t.hash(Bp) -> block_t.round(Bp) < block_t.round(Bc))\
\
            [\
                fml:y = 1\
                fml:y = 2\
            ]\
        \}\
\
        [\
            fml:y = 1\
            fml:y = 2\
        ]\
algorithm.ivy: line 414: \
        call basic_safety.validator.advanceToRound(prm:V0, loc:0, block_t.nil, cert_t.nil, timeout_cert_t.nil)\
        \{\
            [\
                fml:tc_r_2 = 0\
                fml:y = 1\
                fml:r = 2\
                fml:b_r_1 = 0\
                fml:y = 2\
                fml:qc = 0\
            ]\
algorithm.ivy: line 202: \
            assert fml:tc_r_2 = timeout_cert_t.nil | basic_safety.validator.rcvd_tc(prm:V0,fml:tc_r_2)\
\
            [\
                fml:y = 1\
                fml:y = 2\
            ]\
algorithm.ivy: line 204: \
            basic_safety.validator.r_c(prm:V0) := fml:r\
\
            [\
                basic_safety.validator.r_c(0) = 2\
                fml:y = 1\
                fml:y = 2\
            ]\
algorithm.ivy: line 205: \
            basic_safety.validator.timed_out(prm:V0) := false\
\
            [\
                fml:y = 1\
                fml:y = 2\
            ]\
        \}\
\
        [\
            fml:y = 1\
            fml:y = 2\
            fml:qc = 2\
        ]\
    \}\
\
    [\
        fml:y = 1\
        fml:y = 2\
    ]\
classic_safety.ivy: line 14: \
    assume forall N1. (forall N2. (forall B1. (forall B2. is_good(N1) & is_good(N2) & gv.node_has_quorum(N1,B1) & gv.node_has_quorum(N2,B2) & block_t.round(B1) = block_t.round(B2) -> B1 = B2)))\
\
    [\
        fml:y = 1\
        fml:y = 2\
    ]\
classic_safety.ivy: line 10: \
    assume forall N. (forall B1. (forall B2. is_good(N) & gv.node_has_voted(N,B1) & gv.node_has_voted(N,B2) & block_t.round(B1) = block_t.round(B2) -> B1 = B2))\
\
    [\
        fml:y = 1\
        fml:y = 2\
    ]\
classic_safety.ivy: line 12: \
    assume forall N. (forall B. gv.node_has_quorum(N,B) -> (exists Q. (forall N1. quorum_t.member(N1,Q) -> gv.node_has_voted(N1,B))))\
\
    [\
        fml:y = 1\
        fml:y = 2\
    ]\
classic_safety.ivy: line 21: \
    assume forall Bc. (forall Bp. block_t.parent(Bc) = block_t.hash(Bp) -> block_t.round(Bp) < block_t.round(Bc))\
\
    [\
        fml:y = 1\
        fml:y = 2\
    ]\
\}\
}