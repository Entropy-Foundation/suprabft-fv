
    #invariant forall Hd:height_t. forall Qd:cert_t. forall Ha:height_t. forall Qa:cert_t. (is_good(id) & Hd <= chain_size & Ha <= chain_size_2cc & height_t.succ(Ha,Hd) & commit_candidates(Qd,Hd) & commit_candidates(Qa,Ha)) -> Qd.block.parent = block_t.hash(Qa.block)

    # # these invariants support blockchain_parent invariant
    # invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size) -> ( H2 < chain_size_2cc | H2 = chain_size_2cc | (chain_size_2cc <= H1 & H2 < chain_size))

    # invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size_2cc & H2 < chain_size & is_good(id)) -> blockchain_temp(H2).parent = block_t.hash(blockchain_temp(H1))

    # invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size & is_good(id) & H2 = chain_size_2cc) -> forall Q2:cert_t. (forest_store_temp(Q2,H2) -> forest_root_temp(Q2,H2))

    # invariant forall Q:cert_t. forall H:height_t. (forest_root_temp(Q,H) & Q.block.parent ~= block_t.hash(block_t.nil) & is_good(id)) -> (forall Hc:height_t. height_t.succ(Hc,chain_size_2cc) -> Q.block.parent = block_t.hash(blockchain_temp(Hc)))

    # invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size & is_good(id) & H2 = chain_size_2cc) -> forall Q2:cert_t. ((forest_store_temp(Q2,H2)) -> (forest_root_temp(Q2,H2)))
    
    # invariant forall Q:cert_t. forall H:height_t. (forest_root_temp(Q,H) & Q.block.parent ~= block_t.hash(block_t.nil) & is_good(id)) -> (forall Hc:height_t. height_t.succ(Hc,chain_size_2cc) -> Q.block.parent = block_t.hash(blockchain(Hc)))

    # #invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size & is_good(id) & H2 = chain_size_2cc) -> forall Q2:cert_t. ((forest_root_temp(Q2,H2)) -> (Q2.block.parent = block_t.hash(blockchain_temp(H1))))

    # invariant forall H:height_t. (is_good(id) & chain_size_2cc <= H & H < chain_size) -> exists Q:cert_t. (forest_store_temp(Q,H) & Q.block = blockchain(H) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q,H))

    # invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size & is_good(id) & chain_size_2cc <= H1) -> H1 < chain_size

    # invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size & is_good(id) & chain_size_2cc <= H1) -> exists Q1:cert_t. (forest_store_temp(Q1,H1) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q1,H1))

    # invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size & is_good(id) & chain_size_2cc <= H1) -> exists Q2:cert_t. (forest_store_temp(Q2,H2) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q2,H2))

    # invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size & is_good(id) & chain_size_2cc <= H1) -> exists Q1:cert_t. exists Q2:cert_t. (forest_store_temp(Q1,H1) & forest_store_temp(Q2,H2) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q1,H1) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q2,H2))

    # #invariant forall H2,H3:height_t. (is_good(id) & height_t.succ(H3,H2)) -> forall Q2,Q3:cert_t. (forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q2,H2) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q3,H3)) -> (Q1.block = blockchain(H1) & Q2.block = blockchain(H2) & forest_succ_temp(Q2,H2,Q3,H3))
    
    # invariant forall H2,H3:height_t. (is_good(id) & height_t.succ(H3,H2) & chain_size_2cc <= H3 & H2 < chain_size) ->  (forall Q2,Q3:cert_t. (forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q2,H2) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q3,H3)) -> forest_succ_temp(Q2,H2,Q3,H3))
    
    # invariant forall H2,H3:height_t. (is_good(id) & height_t.succ(H3,H2) & chain_size_2cc <= H3 & H2 < chain_size) ->  (forall Q2:cert_t. forall Q3:cert_t. (forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q2,H2) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q3,H3)) -> (blockchain(H2) = Q2.block & blockchain(H3) = Q3.block))

    # invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size & is_good(id) & chain_size_2cc <= H1) -> (forall Q1:cert_t. forall Q2:cert_t. ( forest_store_temp(Q1,H1) & forest_store_temp(Q2,H2) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q1,H1) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q2,H2)) -> (Q1.block = blockchain(H1) & Q2.block = blockchain(H2) & forest_succ_temp(Q2,H2,Q1,H1)))

    # invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size & is_good(id) & chain_size_2cc <= H1) -> (exists Q1:cert_t. exists Q2:cert_t. (Q1.block = blockchain(H1) & Q2.block = blockchain(H2) & forest_store_temp(Q1,H1) & forest_store_temp(Q2,H2) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q1,H1) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q2,H2)) & forest_succ_temp(Q2,H2,Q1,H1))

    # invariant forall Qd:cert_t. forall Qa:cert_t. forall Hd:height_t. forall Ha:height_t. (forest_store_temp(Qd,Hd) & forest_store_temp(Qa,Ha) & is_good(id)) -> (forest_succ_temp(Qd,Hd,Qa,Ha) -> (Qd.block.parent = block_t.hash(Qa.block) & height_t.succ(Ha,Hd)))

    # invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size & is_good(id) & chain_size_2cc <= H1) -> (exists Q1:cert_t. exists Q2:cert_t. (Q1.block = blockchain(H1) & Q2.block = blockchain(H2) & forest_store_temp(Q1,H1) & forest_store_temp(Q2,H2) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q1,H1) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q2,H2)))

    # invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size & is_good(id) & chain_size_2cc <= H1) -> blockchain_temp(H2).parent = block_t.hash(blockchain_temp(H1))

    # invariant forall Q:cert_t. forall H:height_t. (forest_store(Q,H) & Q.block.parent = block_t.hash(block_t.nil) & is_good(id)) -> H = 0

    # invariant (is_good(id) & (locked = cert_t.nil | (locked.block.parent = block_t.hash(block_t.nil)))) -> chain_size = 0
    
    # invariant chain_size = 0 -> forall H:height_t. ~height_t.succ(H,chain_size)
    
    # invariant forall Q:cert_t. forall H:height_t. (forest_root(Q,H) & Q.block.parent ~= block_t.hash(block_t.nil) & is_good(id)) -> (forall Hc:height_t. height_t.succ(Hc,chain_size) -> Q.block.parent = block_t.hash(blockchain(Hc)))

    # invariant forall Q:cert_t. forall H:height_t. (forest_root(Q,H) & Q.block.parent = block_t.hash(block_t.nil) & is_good(id)) -> (H = 0 & chain_size = 0)

    # invariant forall Q:cert_t. forall H:height_t. (forest_store(Q,H) & ~forest_root(Q,H) & is_good(id)) -> exists Qs:cert_t. exists Hs:height_t. forest_strictAncestor(Q,H,Qs,Hs)

    # invariant forall Q:cert_t. forall H:height_t. forall Qs:cert_t. forall Hs:height_t. (forest_strictAncestor(Q,H,Qs,Hs) & is_good(id)) -> exists Qss:cert_t. exists Hss:height_t. forest_succ(Q,H,Qss,Hss)

    # invariant forall Qd:cert_t. forall Qa:cert_t. forall Hd:height_t. forall Ha:height_t. (forest_store(Qd,Hd) & forest_store(Qa,Ha) & is_good(id)) -> ((Qd.block.parent = block_t.hash(Qa.block) & height_t.succ(Ha,Hd)) ->  forest_strictAncestor(Qd,Hd,Qa,Ha))

    # invariant forall H:height_t. ~height_t.succ(H,0)
    
    # invariant forall Qd:cert_t. forall Qa:cert_t. forall Hd:height_t. forall Ha:height_t. (forest_store(Qd,Hd) & forest_store(Qa,Ha) & is_good(id)) -> ((Qd.block.parent = block_t.hash(Qa.block) & height_t.succ(Ha,Hd)) ->  (forall Qaa:cert_t. forall Haa:height_t. (forest_ancestor(Qd,Hd,Qaa,Haa) & (Qd ~= Qaa | Hd ~= Haa)) -> forest_ancestor(Qa,Ha,Qaa,Haa)))

    # invariant forall Qd:cert_t. forall Qa:cert_t. forall Hd:height_t. forall Ha:height_t. (forest_store(Qd,Hd) & forest_store(Qa,Ha) & is_good(id)) -> ((Qd.block.parent = block_t.hash(Qa.block) & height_t.succ(Ha,Hd)) ->  forest_succ(Qd,Hd,Qa,Ha))

    #invariant forall Qf:cert_t. forall Hf:height_t. (is_good(id) & forest_store(Qf,Hf) & ~forest_root(Qf,Hf)) -> exists Qs:cert_t. exists Hs:height_t. forest_succ(Qf,Hf,Qs,Hs)

    #invariant forall Qd:cert_t. forall Hd:height_t. forall Qa:cert_t. forall Ha:height_t. forall Hi:height_t. (is_good(id) & forest_ancestor(Qd,Hd,Qa,Ha) & Ha <= Hi & Hi <= Hd) -> exists Qi:cert_t. (forest_ancestor(Qd,Hd,Qi,Hi) & forest_ancestor(Qi,Hi,Qa,Ha))

    ########################################## 26 December 2022 ##################

    #invariant forall Qd:cert_t. forall Hd:height_t. forall Qa:cert_t. forall Ha:height_t. forall Hi:height_t. (is_good(id) & forest_ancestor(Qd,Hd,Qa,Ha) & Ha <= Hi & Hi <= Hd) -> exists Qi:cert_t. (forest_ancestor(Qd,Hd,Qi,Hi) & forest_ancestor(Qi,Hi,Qa,Ha))

    #invariant forall Hd:height_t. forall Qd:cert_t. forall Ha:height_t. forall Qa:cert_t. (is_good(id) & Hd <= chain_size & Ha <= chain_size_2cc & height_t.succ(Ha,Hd) & commit_candidates(Qd,Hd) & commit_candidates(Qa,Ha)) -> Qd.block.parent = block_t.hash(Qa.block)

    # # these invariants support blockchain_parent invariant
    # invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size) -> ( H2 < chain_size_2cc | H2 = chain_size_2cc | (chain_size_2cc <= H1 & H2 < chain_size))

    # invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size_2cc & H2 < chain_size & is_good(id)) -> blockchain_temp(H2).parent = block_t.hash(blockchain_temp(H1))

    # invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size & is_good(id) & H2 = chain_size_2cc) -> forall Q2:cert_t. (forest_store_temp(Q2,H2) -> forest_root_temp(Q2,H2))

    # invariant forall Q:cert_t. forall H:height_t. (forest_root_temp(Q,H) & Q.block.parent ~= block_t.hash(block_t.nil) & is_good(id)) -> (forall Hc:height_t. height_t.succ(Hc,chain_size_2cc) -> Q.block.parent = block_t.hash(blockchain_temp(Hc)))

    # invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size & is_good(id) & H2 = chain_size_2cc) -> forall Q2:cert_t. ((forest_store_temp(Q2,H2)) -> (forest_root_temp(Q2,H2)))

    # invariant forall Q:cert_t. forall H:height_t. (forest_root_temp(Q,H) & Q.block.parent ~= block_t.hash(block_t.nil) & is_good(id)) -> (forall Hc:height_t. height_t.succ(Hc,chain_size_2cc) -> Q.block.parent = block_t.hash(blockchain(Hc)))

    # #invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size & is_good(id) & H2 = chain_size_2cc) -> forall Q2:cert_t. ((forest_root_temp(Q2,H2)) -> (Q2.block.parent = block_t.hash(blockchain_temp(H1))))

    # invariant forall H:height_t. (is_good(id) & chain_size_2cc <= H & H < chain_size) -> exists Q:cert_t. (forest_store_temp(Q,H) & Q.block = blockchain(H) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q,H))

    # invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size & is_good(id) & chain_size_2cc <= H1) -> H1 < chain_size

    # invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size & is_good(id) & chain_size_2cc <= H1) -> exists Q1:cert_t. (forest_store_temp(Q1,H1) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q1,H1))

    # invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size & is_good(id) & chain_size_2cc <= H1) -> exists Q2:cert_t. (forest_store_temp(Q2,H2) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q2,H2))

    # invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size & is_good(id) & chain_size_2cc <= H1) -> exists Q1:cert_t. exists Q2:cert_t. (forest_store_temp(Q1,H1) & forest_store_temp(Q2,H2) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q1,H1) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q2,H2))

    # #invariant forall H2,H3:height_t. (is_good(id) & height_t.succ(H3,H2)) -> forall Q2,Q3:cert_t. (forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q2,H2) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q3,H3)) -> (Q1.block = blockchain(H1) & Q2.block = blockchain(H2) & forest_succ_temp(Q2,H2,Q3,H3))

    # invariant forall H2,H3:height_t. (is_good(id) & height_t.succ(H3,H2) & chain_size_2cc <= H3 & H2 < chain_size) ->  (forall Q2,Q3:cert_t. (forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q2,H2) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q3,H3)) -> forest_succ_temp(Q2,H2,Q3,H3))

    # invariant forall H2,H3:height_t. (is_good(id) & height_t.succ(H3,H2) & chain_size_2cc <= H3 & H2 < chain_size) ->  (forall Q2:cert_t. forall Q3:cert_t. (forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q2,H2) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q3,H3)) -> (blockchain(H2) = Q2.block & blockchain(H3) = Q3.block))

    # invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size & is_good(id) & chain_size_2cc <= H1) -> (forall Q1:cert_t. forall Q2:cert_t. ( forest_store_temp(Q1,H1) & forest_store_temp(Q2,H2) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q1,H1) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q2,H2)) -> (Q1.block = blockchain(H1) & Q2.block = blockchain(H2) & forest_succ_temp(Q2,H2,Q1,H1)))

    # invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size & is_good(id) & chain_size_2cc <= H1) -> (exists Q1:cert_t. exists Q2:cert_t. (Q1.block = blockchain(H1) & Q2.block = blockchain(H2) & forest_store_temp(Q1,H1) & forest_store_temp(Q2,H2) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q1,H1) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q2,H2)) & forest_succ_temp(Q2,H2,Q1,H1))

    # invariant forall Qd:cert_t. forall Qa:cert_t. forall Hd:height_t. forall Ha:height_t. (forest_store_temp(Qd,Hd) & forest_store_temp(Qa,Ha) & is_good(id)) -> (forest_succ_temp(Qd,Hd,Qa,Ha) -> (Qd.block.parent = block_t.hash(Qa.block) & height_t.succ(Ha,Hd)))

    # invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size & is_good(id) & chain_size_2cc <= H1) -> (exists Q1:cert_t. exists Q2:cert_t. (Q1.block = blockchain(H1) & Q2.block = blockchain(H2) & forest_store_temp(Q1,H1) & forest_store_temp(Q2,H2) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q1,H1) & forest_ancestor_temp(dc_basis_qc,dc_basis_hc,Q2,H2)))

    # invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size & is_good(id) & chain_size_2cc <= H1) -> blockchain_temp(H2).parent = block_t.hash(blockchain_temp(H1))

    # invariant forall Q:cert_t. forall H:height_t. (forest_store(Q,H) & Q.block.parent = block_t.hash(block_t.nil) & is_good(id)) -> H = 0

    # invariant (is_good(id) & (locked = cert_t.nil | (locked.block.parent = block_t.hash(block_t.nil)))) -> chain_size = 0

    # invariant chain_size = 0 -> forall H:height_t. ~height_t.succ(H,chain_size)

    # invariant forall Q:cert_t. forall H:height_t. (forest_root(Q,H) & Q.block.parent ~= block_t.hash(block_t.nil) & is_good(id)) -> (forall Hc:height_t. height_t.succ(Hc,chain_size) -> Q.block.parent = block_t.hash(blockchain(Hc)))

    # invariant forall Q:cert_t. forall H:height_t. (forest_root(Q,H) & Q.block.parent = block_t.hash(block_t.nil) & is_good(id)) -> (H = 0 & chain_size = 0)

    # invariant forall Q:cert_t. forall H:height_t. (forest_store(Q,H) & ~forest_root(Q,H) & is_good(id)) -> exists Qs:cert_t. exists Hs:height_t. forest_strictAncestor(Q,H,Qs,Hs)

    # invariant forall Q:cert_t. forall H:height_t. forall Qs:cert_t. forall Hs:height_t. (forest_strictAncestor(Q,H,Qs,Hs) & is_good(id)) -> exists Qss:cert_t. exists Hss:height_t. forest_succ(Q,H,Qss,Hss)

    # invariant forall Qd:cert_t. forall Qa:cert_t. forall Hd:height_t. forall Ha:height_t. (forest_store(Qd,Hd) & forest_store(Qa,Ha) & is_good(id)) -> ((Qd.block.parent = block_t.hash(Qa.block) & height_t.succ(Ha,Hd)) ->  forest_strictAncestor(Qd,Hd,Qa,Ha))

    # invariant forall H:height_t. ~height_t.succ(H,0)

    # invariant forall Qd:cert_t. forall Qa:cert_t. forall Hd:height_t. forall Ha:height_t. (forest_store(Qd,Hd) & forest_store(Qa,Ha) & is_good(id)) -> ((Qd.block.parent = block_t.hash(Qa.block) & height_t.succ(Ha,Hd)) ->  (forall Qaa:cert_t. forall Haa:height_t. (forest_ancestor(Qd,Hd,Qaa,Haa) & (Qd ~= Qaa | Hd ~= Haa)) -> forest_ancestor(Qa,Ha,Qaa,Haa)))

    # invariant forall Qd:cert_t. forall Qa:cert_t. forall Hd:height_t. forall Ha:height_t. (forest_store(Qd,Hd) & forest_store(Qa,Ha) & is_good(id)) -> ((Qd.block.parent = block_t.hash(Qa.block) & height_t.succ(Ha,Hd)) ->  forest_succ(Qd,Hd,Qa,Ha))

	#invariant forall B:block_t. forall Bp:block_t. (exists N:node_t. (is_good(N) & gv.node_has_locked(N,B)) & B.parent=block_t.hash(Bp)) -> (exists Q:quorum_t. exists R:round_t. round_t.succ(B.round,R) & forall N1:node_t. ((quorum_t.member(N1,Q) & is_good(N1)) -> (Bp = block_t.nil | gv.node_has_locked_recently(N1,Bp,R))))

isolate gdc_properties3 = {

	#invariant forall Bc:block_t. forall Bp:block_t. forall R:round_t. (Bp ~= block_t.nil & gv.quorum_of_votes(Bc,Bp) & round_t.succ(Bc.round,R)) -> gv.quorum_of_recent_locks(Bp,R)

	#invariant forall B:block_t. forall Bp:block_t. (exists N:node_t. (is_good(N) & gv.node_has_locked(N,B)) & B.parent=block_t.hash(Bp)) -> (exists Q:quorum_t. forall N1:node_t. ((quorum_t.member(N1,Q) & is_good(N1)) -> (Bp = block_t.nil | (exists Rp:round_t. gv.node_has_locked_detail(N1,Bp,Rp) & Bp.round < Rp & Rp <= B.round))))

	#invariant forall B:block_t. forall Bp:block_t. (exists N:node_t. (is_good(N) & gv.node_has_locked(N,B)) & B.parent=block_t.hash(Bp) & round_t.succ(Bp.round,B.round)) -> (exists Q:quorum_t. forall N1:node_t. ((quorum_t.member(N1,Q) & is_good(N1)) -> (Bp = block_t.nil | (exists Rp:round_t. (round_t.succ(Bp.round, Rp) & gv.node_has_locked_detail(N1,Bp,Rp))))))

	#invariant forall B:block_t. forall Bp:block_t. (exists N:node_t. (is_good(N) & gv.node_has_locked(N,B)) & B.parent=block_t.hash(Bp) & round_t.succ(Bp.round,B.round)) -> (exists Q:quorum_t. exists Rp:round_t. (round_t.succ(Bp.round, Rp) & forall N1:node_t. ((quorum_t.member(N1,Q) & is_good(N1)) -> (Bp = block_t.nil |  gv.node_has_locked_detail(N1,Bp,Rp)))))

	#invariant forall N:node_t. forall B:block_t. forall R:round_t. (is_good(N) & gv.node_has_locked_detail(N,B,R)) -> B.round < R

	#invariant forall B:block_t. forall Bp:block_t. (exists N:node_t. (is_good(N) & gv.node_has_locked(N,B)) & B.parent=block_t.hash(Bp) & round_t.succ(Bp.round,B.round) & Bp ~= block_t.nil) -> gdc_properties.gdc(Bp)

	#invariant forall B:block_t. forall Bp:block_t. forall N:node_t. (is_good(N) & gv.node_has_locked(N,B) & B.parent=block_t.hash(Bp) & round_t.succ(Bp.round,B.round) & Bp ~= block_t.nil) -> gdc_properties.gdc(Bp)

	#invariant forall B:block_t. forall Bp:block_t. (exists N:node_t. (is_good(N) & gv.node_has_locked(N,B)) & B.parent=block_t.hash(Bp) & round_t.succ(Bp.round,B.round)) -> (exists Q:quorum_t. exists R:round_t. round_t.succ(Bp.round,R) & forall N1:node_t. (quorum_t.member(N1,Q) -> (Bp = block_t.nil | gv.node_has_locked_detail(N1,Bp,R))))

	#invariant forall B:block_t. forall Bc:block_t. forall N:node_t. (B ~= block_t.nil & Bc.parent ~= block_t.hash(block_t.nil) & Bc.parent = block_t.hash(B) & gv.node_has_locked(N,Bc) & is_good(N) & round_t.succ(B.round,Bc.round)) -> gdc(B)
} with gv, quorum_t, round_t, block_t, gdc_properties, gdc_properties2


	isolate ldc_properties2 = {
		relation gdc_req(N:node_t, Bp:block_t, Bc:block_t)

		definition gdc_req(N:node_t, Bp:block_t, Bc:block_t) = gv.node_has_locked(N,Bc) & Bc.parent=block_t.hash(Bp) & round_t.succ(Bp.round,Bc.round) & Bp ~= block_t.nil & is_good(N)

		invariant forall Bp:block_t. forall Bc:block_t. forall N:node_t. (Bp ~= block_t.nil & ldc_properties.ldc(N,Bp,Bc) & is_good(N)) -> gdc_req(N,Bp,Bc)

		private {	
			invariant forall B:block_t. forall Bp:block_t. (exists N:node_t. (is_good(N) & gv.node_has_locked(N,B)) & B.parent=block_t.hash(Bp) & is_good(N) & B ~= block_t.nil) -> (exists Q:quorum_t. exists R:round_t. round_t.succ(B.round,R) & forall N1:node_t. ((quorum_t.member(N1,Q) & is_good(N1)) -> (gv.node_has_voted_detail(N1,B,R,Bp) & is_good(N1))))
		}

		invariant forall B:block_t. forall Bp:block_t. forall N:node_t. (is_good(N) & gv.node_has_locked(N,B) & B.parent=block_t.hash(Bp) & round_t.succ(Bp.round,B.round) & Bp ~= block_t.nil) -> gdc_properties.gdc(Bp)

		invariant forall Bp:block_t. forall Bc:block_t. forall N:node_t. gdc_req(N,Bp,Bc) -> gdc_properties.gdc(Bp)

	} with processor, round_t, gv, cert_t, gdc_properties, gdc_properties3, ldc_properties

	isolate ldc_properties3 = {
		invariant forall Bp:block_t. forall Bc:block_t. forall N:node_t. (Bp ~= block_t.nil & ldc_properties.ldc(N,Bp,Bc) & is_good(N)) -> gdc_properties.gdc(Bp)

		#invariant forall N:node_t. forall B:block_t. forall Bp:block_t. forall R:round_t. (is_good(N) & gv.node_has_voted_detail(N,B,R,Bp) & B.parent ~= block_t.hash(block_t.nil)) -> (exists Rl:round_t. Rl <= R & gv.node_has_locked_detail(N,Bp,Rl))		
	} with processor, round_t, gv, cert_t, gdc_properties, gdc_properties3, gdc_properties2, ldc_properties, ldc_properties2