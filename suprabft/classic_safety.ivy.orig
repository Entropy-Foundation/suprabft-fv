#lang ivy1.8

include domain_model
include algorithm
include global_view

isolate gv =
{
	instantiate global_view

	axiom block_t.nil.round = 0

	invariant forall N:node_t. forall B1:block_t. forall B2:block_t. (is_good(N) & node_has_voted(N,B1) & node_has_voted(N,B2) & B1.round = B2.round) -> B1 = B2

	invariant forall N:node_t. forall B:block_t. node_has_locked(N,B) -> (exists Q:quorum_t. forall N1:node_t. quorum_t.member(N1, Q) -> node_has_voted(N1, B))

	invariant forall N1:node_t. forall N2:node_t. forall B1:block_t. forall B2:block_t. (is_good(N1) & is_good(N2) & node_has_locked(N1, B1) & node_has_locked(N2, B2) & B1.round = B2.round) -> B1 = B2
} with round_t, block_t, quorum_t, cert_t, shim

isolate parent_star_acyclic =
{
	relation is_parent(Bc:block_t, Bp:block_t) # Bp is the parent block of Bc
	definition is_parent(Bc:block_t, Bp:block_t) = Bc.parent = block_t.hash(Bp)

	invariant forall Bc:block_t. forall Bp:block_t. is_parent(Bc,Bp) -> Bp.round < Bc.round # parent must be strictly lesser than the child
} with round_t

isolate basic_safety = {
	instantiate supraBFT(gv)

	invariant forall N:node_t. forall H:height_t. validator(N).blockchain(H) ~= block_t.nil -> gv.node_has_locked(N,validator(N).blockchain(H))

	invariant [round_safety_statement] forall N1:node_t. forall N2:node_t. forall H1:height_t. forall H2:height_t. (is_good(N1)  & is_good(N2) & validator(N1).blockchain(H1) ~= block_t.nil & validator(N2).blockchain(H2) ~= block_t.nil &validator(N1).blockchain(H1).round = validator(N2).blockchain(H2).round ) -> validator(N1).blockchain(H1) = validator(N2).blockchain(H2)

<<<<<<< HEAD
	invariant forall N1:node_t. forall N2:node_t. forall H:height_t. (is_good(N1) & is_good(N2) & validator(N1).blockchain(H) ~= block_t.nil & validator(N2).blockchain(H) ~= block_t.nil) -> validator(N1).blockchain(H) = validator(N2).blockchain(H)
} with gv, round_t, height_t, block_t, cert_t, parent_star_acyclic
=======
	#invariant forall N1:node_t. forall N2:node_t. forall H:height_t. (is_good(N1) & is_good(N2) & validator(N1).blockchain(H) ~= block_t.nil & validator(N2).blockchain(H) ~= block_t.nil) -> validator(N1).blockchain(H) = validator(N2).blockchain(H)
} with gv, round_t, height_t, cert_t, proposal_t, parent_star_acyclic
>>>>>>> 956e586556c6b6a37c65def4779d95f71cd550de
