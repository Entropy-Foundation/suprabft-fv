#lang ivy1.8

include udp

include types

object msg_kind = {
    type this = {proposal_n, proposal_f, prepare, qc, timeout, tc, tcfpo}
}

object msg = {
    type this = struct {
        kind : msg_kind,
        prop_n : proposal_n_t,
        prop_f : proposal_f_t,
        prop_o : proposal_o_t,
        prep : prepare_t,
        qc : qc_t,
        t : timeout_t,
        tc : tc_t,
        tc_po: tc_fplusone_t,
        src : process_index_t
    }
}

instance net : udp_simple(process_index_t, msg)

isolate shim = {
    # In order not repeat the same code for each handler, we use a handler
    # module parameterized by the type of message it will handle. Below we
    # instantiate this module for the five types of messages of SupraBFT
    module handler(p_kind) = {
        action handle(dst:process_index_t, m:msg)
        object spec = {
            before handle {
                assert sent(m, dst) & m.kind = p_kind
            }
        }
    }

    instance proposal_n_handler : handler(msg_kind.proposal_n)
    instance proposal_f_handler : handler(msg_kind.proposal_f)
    instance proposal_o_handler : handler(msg_kind.proposal_o)
    instance prepare_handler : handler(msg_kind.prepare)
    instance qc_handler : handler(msg_kind.qc)
    instance timeout_handler : handler(msg_kind.timeout)
    instance tc_handler : handler(msg_kind.tc)
    instance tc_fplusone_handler: handler(msg_kind.tcfpo)

    relation sent(M:msg, N:process_index_t)

    action broadcast(src:process_index_t, m:msg)
    action send(src:process_index_t,dst:process_index_t, m:msg)

    specification {
        after init {
            sent(M, D) := false;
        }
        before broadcast {
            sent(m, D) := true
        }
        before send {
            sent(m, dst) := true
        }
    }

    # Here we give an implementation of it that satisfies its specification:
    implementation {
        implement net.recv(dst:process_index_t ,m:msg) {
            if m.kind = msg_kind.proposal_n {
                call proposal_n_handler.handle(dst, m)
            } else if m.kind = msg_kind.proposal_f {
                call proposal_f_handler.handle(dst, m)
            } else if m.kind = msg_kind.proposal_o {
                call proposal_o_handler.handle(dst, m)
            } else if m.kind = msg_kind.prepare {
                call prepare_handler.handle(dst, m)
            } else if m.kind = msg_kind.qc {
                call qc_handler.handle(dst, m)
            } else if m.kind = msg_kind.timeout {
                call timeout_handler.handle(dst, m)
            } else if m.kind = msg_kind.tc {
                call tc_handler.handle(dst, m)
            }
        }

        # broadcast sends to all nodes, including the sender.
        implement broadcast {
            var iter := process_index_t.iter.create(0);
            while ~iter.is_end
            invariant net.spec.sent(M,D) -> sent(M,D) {
                var n := iter.val;
                call net.send(src, n, m);
                iter := iter.next;
            }
        }

        implement send {
            call net.send(src, dst, m)
        }

        private {
            invariant net.spec.sent(M, D) -> sent(M, D)
        }
    }
# to prove that the shim implementation satisfies the shim specification, we rely on the specification of net and node.
} with net.spec, process_index_t
