#lang ivy1.8

include domain_model
include network_model
include algorithm
include global_view

# ivy_check trace=true isolate=gv classic_safety.ivy

# ivy_check trace=true isolate=gdc_properties classic_safety.ivy

# ivy_check trace=true isolate=gdc_properties classic_safety.ivy

# ivy_check trace=true isolate=basic_safety.processor classic_safety.ivy

# ivy_check trace=true isolate=basic_safety.continuity classic_safety.ivy

# ivy_check trace=true isolate=basic_safety.ldc_properties classic_safety.ivy

# ivy_check trace=true isolate=basic_safety.global_properties classic_safety.ivy

isolate gv = {

	axiom forall R:round_t. R = R

	instantiate global_view

	invariant forall N:node_t. forall B:block_t. forall R:round_t. forall Bl:block_t. (node_has_voted_detail(N,B,R,Bl) & is_good(N)) -> (round_t.succ(B.round,R) & B.parent = block_t.hash(Bl) & node_has_voted(N,B))

	invariant forall N:node_t. forall B:block_t. (is_good(N) & node_has_locked(N,B)) -> exists Q:quorum_t. forall N1:node_t. (quorum_t.member(N1,Q) -> node_has_voted(N1,B))

	invariant forall B1:block_t. forall B2:block_t. forall N:node_t. (is_good(N) & node_has_voted(N,B1) & node_has_voted(N,B2) & B1.round = B2.round) -> B1 = B2

	invariant forall N1:node_t. forall N2:node_t. forall B1:block_t. forall B2:block_t. (is_good(N1) & is_good(N2) & node_has_locked(N1, B1) & node_has_locked(N2, B2) & B1.round = B2.round) -> B1 = B2

	invariant forall N:node_t. forall Qc:cert_t. (is_good(N) & node_has_processed_qc(N,Qc)) -> exists Q:quorum_t. forall N1:node_t. (quorum_t.member(N1,Q) -> node_has_voted(N1,Qc.block))

	invariant forall N1:node_t. forall N2:node_t. forall Q1:cert_t. forall Q2:cert_t. (is_good(N1) & is_good(N2) & node_has_processed_qc(N1, Q1) & node_has_processed_qc(N2, Q2) & Q1.block.round = Q2.block.round) -> Q1.block = Q2.block

	############# starting experimentation from here

} with quorum_t, round_t, block_t

isolate gdc_properties = {

	relation gdc(B:block_t)

	definition gdc(B:block_t) = exists Q:quorum_t. exists R:round_t. (round_t.succ(B.round,R) & (forall N:node_t. (quorum_t.member(N,Q) & is_good(N)) -> gv.node_has_locked_detail(N,B,R)))

	invariant forall Bc:block_t. forall Bp:block_t. Bc.parent = block_t.hash(Bp) -> Bp.round < Bc.round

	invariant forall N:node_t. forall B:block_t. forall R:round_t. forall Bl:block_t. (gv.node_has_voted_detail(N,B,R,Bl) & is_good(N)) -> (round_t.succ(B.round,R) & B.parent = block_t.hash(Bl) & gv.node_has_voted(N,B) & (Bl = block_t.nil | gv.node_has_locked_recently(N,Bl,R)))

	invariant forall N:node_t. forall B:block_t. forall R:round_t. (is_good(N) & gv.node_has_locked_detail(N,B,R)) -> B.round < R

	private {
		invariant forall N:node_t. forall B:block_t. (is_good(N) & gv.node_has_voted(N,B)) -> exists R:round_t. exists Bp:block_t. (gv.node_has_voted_detail(N,B,R,Bp) & round_t.succ(B.round,R) & B.parent = block_t.hash(Bp))
	}

	invariant forall Bc:block_t. forall Bp:block_t. gv.quorum_of_votes(Bc,Bp) <-> exists Q:quorum_t. exists R:round_t. round_t.succ(Bc.round,R) &  Bc.parent=block_t.hash(Bp) & forall N1:node_t. ((quorum_t.member(N1,Q) & is_good(N1)) -> (gv.node_has_voted_detail(N1,Bc,R,Bp) & is_good(N1)))

	invariant forall Bc:block_t. forall Bp:block_t. forall N:node_t. (is_good(N) & gv.node_has_locked(N,Bc) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil) -> gv.quorum_of_votes(Bc,Bp)

	invariant forall Bp:block_t. forall R:round_t. (gv.quorum_of_recent_locks(Bp,R) <-> exists Q:quorum_t. forall N:node_t. (quorum_t.member(N,Q) & is_good(N)) -> gv.node_has_locked_recently(N,Bp,R))

	############# starting experimentation from here
} with gv, quorum_t, round_t, block_t

isolate gdc_properties2 = {

	private {
		invariant forall N:node_t. forall B:block_t. forall R:round_t. forall Bl:block_t. (gv.node_has_voted_detail(N,B,R,Bl) & is_good(N)) -> (round_t.succ(B.round,R) & B.parent = block_t.hash(Bl) & gv.node_has_voted(N,B) & (Bl = block_t.nil | gv.node_has_locked_recently(N,Bl,R)))
	}

	invariant forall Bc:block_t. forall Bp:block_t. forall R:round_t. (gv.quorum_of_votes(Bc,Bp) & round_t.succ(Bc.round,R) & Bp ~= block_t.nil) -> gv.quorum_of_recent_locks(Bp,R)

	invariant forall N:node_t. forall B:block_t. forall R:round_t. (is_good(N) & gv.node_has_locked_detail(N,B,R)) -> B.round < R

	invariant forall B:block_t. forall Bp:block_t. (exists N:node_t. (is_good(N) & gv.node_has_locked(N,B)) & B.parent=block_t.hash(Bp) & round_t.succ(Bp.round,B.round) & Bp ~= block_t.nil) -> gdc_properties.gdc(Bp)

	############################ start experimentation from here
} with gv, quorum_t, round_t, gdc_properties

isolate basic_safety = {

	isolate processor = {
		instantiate supraBFT(gv)

		invariant forall Bc:block_t. forall Bp:block_t. Bc.parent = block_t.hash(Bp) -> Bp.round < Bc.round

		invariant forall M:msg. forall D:node_t. (shim.sent(M,D) & M.kind = msg_kind.prepare) -> gv.node_has_voted(M.src,M.prep)

		invariant forall M:msg. forall D:node_t. (shim.sent(M,D) & M.kind=msg_kind.timeout) -> gv.node_sent_timeout(M.src,M.t)

		invariant forall N:node_t. forall H:height_t. (is_good(N) & validator(N).blockchain(H) ~= block_t.nil) -> exists Q:cert_t. (Q.block = validator(N).blockchain(H) & validator(N).qc_processed(Q))

		invariant forall N:node_t. forall B:block_t. forall R:round_t. (is_good(N) & gv.node_has_locked_detail(N,B,R)) -> B.round <= processor.validator(N).locked.block.round

		invariant forall N:node_t. forall B:block_t. forall Rl:round_t. forall Rs:round_t. (is_good(N) & gv.node_has_locked_detail(N,validator(N).locked.block,Rl) & Rl < Rs) -> ~gv.node_has_locked_detail(N,B,Rs)

		invariant forall N:node_t. forall B:block_t. forall R:round_t. forall Bl:block_t. (is_good(N) & gv.node_has_voted_detail(N,B,R,Bl)) -> R <= validator(N).r_c

		invariant forall N:node_t. forall B:block_t. forall R:round_t. (is_good(N) & gv.node_has_locked_detail(N,B,R)) -> R <= validator(N).r_c	

		invariant forall N:node_t. forall Q:cert_t. (is_good(N) & validator(N).qc_processed(Q)) -> gv.node_has_processed_qc(N,Q)

		########### starting experimentation from here
	} with gv, round_t, height_t, block_t, voted_t, cert_t, timeout_t, timeout_cert_t, proposal_t, shim, net.spec

	isolate continuity = {
    	invariant forall N:node_t. forall Qd:cert_t. forall Hd,Ha,Hi:height_t. (is_good(N) & processor.validator(N).forest_heights(Qd,Hd,Ha) & Ha <= Hi & Hi <= Hd) -> processor.validator(N).forest_heights(Qd,Hd,Hi)

    	invariant forall Hd,Hi,Ha:height_t. (Hd = Ha & Ha <= Hi & Hi <= Hd) -> Hi = Hd
	} with gv,processor, round_t, height_t

	isolate ldc_properties = {
		relation ldc(N:node_t, Bp:block_t, Bc:block_t)

		definition ldc(N:node_t, Bp:block_t, Bc:block_t) = Bc.parent = block_t.hash(Bp) & round_t.succ(Bp.round,Bc.round) & gv.node_has_locked(N,Bc)

		invariant forall N:node_t. forall B:block_t. forall R:round_t. gv.node_has_locked_detail(N,B,R) -> R <= processor.validator(N).r_c

		private {
			invariant forall N:node_t. forall B:block_t. forall R:round_t. (is_good(N) & gv.node_has_locked_detail(N,B,R)) -> exists Q:cert_t. (processor.validator(N).qc_processed(Q) & Q.block = B)
		}

		invariant forall N:node_t. forall B1:block_t. forall B2:block_t. forall R1:round_t. forall R2:round_t. (is_good(N) & gv.node_has_locked_detail(N,B1,R1) & gv.node_has_locked_detail(N,B2,R2) & R1 < R2) -> B1.round < B2.round

		invariant forall B:block_t. forall Bp:block_t. (exists N:node_t. (is_good(N) & gv.node_has_locked(N,B)) & B.parent=block_t.hash(Bp) & round_t.succ(Bp.round,B.round) & Bp ~= block_t.nil) -> gdc_properties.gdc(Bp)

		invariant forall B:block_t. forall Bp:block_t. (exists N:node_t. (is_good(N) & ldc(N,Bp,B) & Bp ~= block_t.nil)) -> gdc_properties.gdc(Bp)

		invariant forall N:node_t. forall H:height_t. (is_good(N) & height_t.succ(H,processor.validator(N).chain_size)) -> (gv.node_has_locked(N,processor.validator(N).tip_of_chain_qc.block) & round_t.succ(processor.validator(N).tip_of_chain_qc.block.round, processor.validator(N).dc_basis_block.round) & processor.validator(N).dc_basis_block.parent = block_t.hash(processor.validator(N).tip_of_chain_qc.block))

		invariant forall N:node_t. (is_good(N) & processor.validator(N).locked ~= cert_t.nil) -> processor.validator(N).forest_leaf(processor.validator(N).locked, processor.validator(N).locked_height)

		invariant forall N:node_t. (is_good(N) & processor.validator(N).dc_basis_qc ~= cert_t.nil) -> gv.node_has_locked(N,processor.validator(N).dc_basis_block)

		relation ldc_x(N:node_t, Bp:block_t, Bc:block_t)

		definition ldc_x(N,Bp:block_t,Bc:block_t) = Bc.parent = block_t.hash(Bp) & gv.node_has_locked(N,Bc) & Bp.round < Bc.round & forall Rp:round_t. (Bp.round < Rp -> Bc.round <= Rp)

		invariant forall N:node_t. forall Bp:block_t. forall Bc:block_t. ldc(N,Bp,Bc) <-> ldc_x(N,Bp,Bc)
		
		invariant forall N:node_t. (is_good(N)) -> processor.validator(N).qp_when_adding_qc = processor.validator(N).tip_of_chain_qc

		invariant forall N:node_t. (is_good(N) & processor.validator(N).tip_of_chain_qc ~= cert_t.nil) -> processor.validator(N).commit_candidates(processor.validator(N).tip_of_chain_qc,processor.validator(N).tip_of_chain_height)

		invariant forall N:node_t. (is_good(N) & processor.validator(N).tip_of_chain_qc ~= cert_t.nil) -> (processor.validator(N).blockchain(processor.validator(N).tip_of_chain_height) = processor.validator(N).tip_of_chain_qc.block & processor.validator(N).dc_basis_block.parent = block_t.hash(processor.validator(N).tip_of_chain_qc.block) & round_t.succ(processor.validator(N).tip_of_chain_qc.block.round, processor.validator(N).dc_basis_block.round))

		invariant forall N:node_t. forall H:height_t. (is_good(N) & height_t.succ(H, processor.validator(N).chain_size)) -> ldc_x(N,processor.validator(N).blockchain(H),processor.validator(N).dc_basis_block)

		invariant forall N:node_t. forall H:height_t. (is_good(N) & height_t.succ(H, processor.validator(N).chain_size)) -> gdc_properties.gdc(processor.validator(N).blockchain(H))

		########### starting experimentation from here
	} with processor, round_t, gv, cert_t, gdc_properties2, height_t, block_t

	isolate global_properties = {
		invariant forall N:node_t. forall H:height_t. (is_good(N) & processor.validator(N).blockchain(H) ~= block_t.nil) -> exists Q:cert_t. (processor.validator(N).qc_processed(Q) & Q.block = processor.validator(N).blockchain(H))

		invariant [round_safety_statement] forall N1:node_t. forall N2:node_t. forall H1:height_t. forall H2:height_t. (is_good(N1)  & is_good(N2) & processor.validator(N1).blockchain(H1) ~= block_t.nil & processor.validator(N2).blockchain(H2) ~= block_t.nil & processor.validator(N1).blockchain(H1).round = processor.validator(N2).blockchain(H2).round ) -> processor.validator(N1).blockchain(H1) = processor.validator(N2).blockchain(H2)

		invariant forall N:node_t. forall B:block_t. (is_good(N) & gv.node_has_voted(N,B)) -> B.parent = block_t.hash(block_t.nil) | exists Bp:block_t. (B.parent = block_t.hash(Bp) & gv.node_has_locked(N,Bp))

		########### starting experimentation from here
		#invariant forall N1:node_t. forall N2:node_t. (is_good(N1) & is_good(N2) & processor.validator(N1).blockchain(0) ~= block_t.nil & processor.validator(N2).blockchain(0) ~= block_t.nil) -> processor.validator(N1).blockchain(0) = processor.validator(N2).blockchain(0)

		#invariant forall N1:node_t. forall N2:node_t. forall H:height_t. (is_good(N1) & is_good(N2) & processor.validator(N1).blockchain(H) ~= block_t.nil & processor.validator(N2).blockchain(H) ~= block_t.nil) -> processor.validator(N1).blockchain(H) = processor.validator(N2).blockchain(H)
	} with gv, height_t, processor, ldc_properties, round_t, block_t
} with gv, round_t, height_t, block_t, cert_t, shim, net.spec, processor, gdc_properties, gdc_properties2
