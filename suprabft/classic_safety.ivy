#lang ivy1.8

include domain_model
include network_model
include algorithm
include global_view

# ivy_check trace=true isolate=basic_safety.gv classic_safety.ivy

# ivy_check trace=true isolate=basic_safety.processor classic_safety.ivy

# ivy_check trace=true isolate=basic_safety.global_properties classic_safety.ivy

isolate gv = {

	axiom forall R:round_t. R = R

	instantiate global_view

	invariant forall N:node_t. forall B:block_t. forall R:round_t. forall Bl:block_t. (node_has_voted_detail(N,B,R,Bl) & is_good(N)) -> (round_t.succ(B.round,R) & B.parent = block_t.hash(Bl) & node_has_voted(N,B))

	private {
		invariant forall N:node_t. forall B:block_t. node_has_voted(N,B) -> exists R:round_t. exists Bl:block_t. node_has_voted_detail(N,B,R,Bl)
	}

	invariant forall N:node_t. forall B:block_t. node_has_quorum(N,B) -> exists R:round_t. node_has_quorum_detail(N,B,R)

	invariant forall B1:block_t. forall B2:block_t. forall N:node_t. (is_good(N) & node_has_voted(N,B1) & node_has_voted(N,B2) & B1.round = B2.round) -> B1 = B2

	invariant forall N:node_t. forall B:block_t. node_has_quorum(N,B) -> (exists Q:quorum_t. forall N1:node_t. quorum_t.member(N1, Q) -> node_has_voted(N1, B))

	invariant forall N1:node_t. forall N2:node_t. forall B1:block_t. forall B2:block_t. (is_good(N1) & is_good(N2) & node_has_quorum(N1, B1) & node_has_quorum(N2, B2) & B1.round = B2.round) -> B1 = B2

	relation gdc(B:block_t)

	definition gdc(B:block_t) = exists Q:quorum_t. exists R:round_t. exists Bp:block_t. (round_t.succ(B.round,R) & B.parent = block_t.hash(Bp) & (forall N:node_t. (quorum_t.member(N,Q) & is_good(N)) -> node_has_voted_detail(N,B,R,Bp)))

	invariant forall B:block_t. forall N:node_t. (B ~= block_t.nil & node_has_quorum(N,B) & is_good(N)) -> gdc(B)
} with quorum_t, round_t, block_t

isolate gdc_properties1 = {
	invariant forall N:node_t. forall B:block_t. forall R:round_t. forall Bl:block_t. (gv.node_has_voted_detail(N,B,R,Bl) & is_good(N)) -> (round_t.succ(B.round,R) & B.parent = block_t.hash(Bl) & gv.node_has_voted(N,B) & (Bl = block_t.nil | gv.node_has_quorum(N,Bl)))
} with gv, quorum_t, round_t, block_t

isolate gdc_properties2 = {
	#invariant forall B:block_t. forall Bp:block_t. (gv.gdc(B) & B.parent = block_t.hash(Bp)) -> exists N:node_t. is_good(N) & (Bp = block_t.nil | gv.node_has_quorum(N,Bp))

	invariant forall B:block_t. forall Bp:block_t. (gv.gdc(B) & B.parent = block_t.hash(Bp)) -> (Bp = block_t.nil | gv.gdc(Bp))
} with gv, gdc_properties1, quorum_t, round_t, block_t
isolate basic_safety = {

	isolate processor = {
		instantiate supraBFT(gv)

		invariant forall M:msg. forall D:node_t. (shim.sent(M,D) & M.kind = msg_kind.prepare) -> gv.node_has_voted(M.src,M.prep)

		invariant forall M:msg. forall D:node_t. (shim.sent(M,D) & M.kind=msg_kind.timeout) -> gv.node_sent_timeout(M.src,M.t)

		invariant forall N:node_t. forall H:height_t. (is_good(N) & validator(N).blockchain(H) ~= block_t.nil) -> gv.node_has_quorum(N,validator(N).blockchain(H))

		relation ldc(N:node_t, B:block_t)

		definition ldc(N:node_t, B:block_t) = processor.validator(N).locked.block = B & exists Bc:block_t. (Bc.parent = block_t.hash(B) & round_t.succ(B.round,Bc.round) & gv.node_has_quorum(N,Bc))

		invariant forall B:block_t. forall N:node_t. (B ~= block_t.nil & gv.node_has_quorum(N,B) & is_good(N)) -> gv.gdc(B)
	} with gv, round_t, height_t, block_t, voted_t, cert_t, timeout_t, timeout_cert_t, proposal_t, shim, net.spec


	isolate global_properties = {
		invariant [round_safety_statement] forall N1:node_t. forall N2:node_t. forall H1:height_t. forall H2:height_t. (is_good(N1)  & is_good(N2) & processor.validator(N1).blockchain(H1) ~= block_t.nil & processor.validator(N2).blockchain(H2) ~= block_t.nil & processor.validator(N1).blockchain(H1).round = processor.validator(N2).blockchain(H2).round ) -> processor.validator(N1).blockchain(H1) = processor.validator(N2).blockchain(H2)

		invariant forall N:node_t. forall B:block_t. (is_good(N) & gv.node_has_voted(N,B)) -> B.parent = block_t.hash(block_t.nil) | exists Bp:block_t. (B.parent = block_t.hash(Bp) & gv.node_has_quorum(N,Bp))

		invariant forall B:block_t. forall N:node_t. (B ~= block_t.nil & is_good(N) & processor.ldc(N,B)) -> gv.node_has_quorum(N,B)

		invariant forall B:block_t. forall N:node_t. (B ~= block_t.nil & is_good(N) & processor.ldc(N,B)) -> gv.gdc(B) # Lemma 2 LDC -> GDC

		#invariant forall N1:node_t. forall N2:node_t. (is_good(N1) & is_good(N2) & processor.validator(N1).blockchain(0) ~= block_t.nil & processor.validator(N2).blockchain(0) ~= block_t.nil) -> processor.validator(N1).blockchain(0) = processor.validator(N2).blockchain(0)

		#invariant forall N1:node_t. forall N2:node_t. forall H:height_t. (is_good(N1) & is_good(N2) & processor.validator(N1).blockchain(H) ~= block_t.nil & processor.validator(N2).blockchain(H) ~= block_t.nil) -> processor.validator(N1).blockchain(H) = processor.validator(N2).blockchain(H)
	} with gv, height_t, processor, round_t, block_t
} with gv, round_t, height_t, block_t, cert_t, shim, net.spec
