#lang ivy1.8

include domain_model
include network_model
include algorithm
include global_view

# ivy_check trace=true isolate=<each_item_in_list_below> classic_safety.ivy
# gv
# gdc_properties
# gdc_properties1
# gdc_properties2
# gdc_properties3
# gdc_properties4
# gdc_properties5
# gdc_supplementary_defs
# gdc_properties6
# gdc_properties7m1
# gdc_properties7m2
# gdc_properties7
# gdc_properties8
# gdc_properties9
# gdc_properties10
# gdc_properties11
# basic_safety.processor
# basic_safety.continuity
# basic_safety.ldc_propertiesm1
# basic_safety.ldc_propertiesm2
# basic_safety.ldc_properties
# basic_safety.ldc_properties1
# basic_safety.ldc_properties2
# basic_safety.ldc_properties3
# basic_safety.ldc_properties4
# basic_safety.ldc_properties5
# basic_safety.ldc_properties6
# basic_safety.global_properties

isolate gv = {

	axiom forall R:round_t. R = R

	instantiate global_view

	invariant forall N:node_t. forall B:block_t. forall R:round_t. forall Bl:block_t. (node_has_voted_detail(N,B,R,Bl) & is_good(N)) -> (round_t.succ(B.round,R) & B.parent = block_t.hash(Bl) & node_has_voted(N,B))

	invariant forall N:node_t. forall B:block_t. (is_good(N) & node_has_locked(N,B)) -> exists Q:quorum_t. forall N1:node_t. (quorum_t.member(N1,Q) -> node_has_voted(N1,B))

	invariant forall B1:block_t. forall B2:block_t. forall N:node_t. (is_good(N) & node_has_voted(N,B1) & node_has_voted(N,B2) & B1.round = B2.round) -> B1 = B2

	invariant forall N1:node_t. forall N2:node_t. forall B1:block_t. forall B2:block_t. (is_good(N1) & is_good(N2) & node_has_locked(N1, B1) & node_has_locked(N2, B2) & B1.round = B2.round) -> B1 = B2

	invariant forall N:node_t. forall Qc:cert_t. (is_good(N) & node_has_processed_qc(N,Qc)) -> exists Q:quorum_t. forall N1:node_t. (quorum_t.member(N1,Q) -> node_has_voted(N1,Qc.block))

	invariant forall N1:node_t. forall N2:node_t. forall Q1:cert_t. forall Q2:cert_t. (is_good(N1) & is_good(N2) & node_has_processed_qc(N1, Q1) & node_has_processed_qc(N2, Q2) & Q1.block.round = Q2.block.round) -> Q1.block = Q2.block

	invariant forall N:node_t. forall B:block_t. forall R:round_t. (is_good(N) & node_has_voted_detail(N,B,R,block_t.nil)) -> (forall Rp:round_t. forall Bgdc:block_t. (Rp < R & node_has_locked_detail(N,Bgdc,Rp)) -> Bgdc = block_t.nil)

	############# starting experimentation from here

	invariant forall N:node_t. forall Qc:cert_t. (is_good(N) & node_has_processed_qc(N,Qc)) -> Qc.block ~= block_t.nil

} with quorum_t, round_t, block_t

isolate gdc_properties = {

	relation gdc(B:block_t)

	definition gdc(B:block_t) = exists Q:quorum_t. exists R:round_t. (round_t.succ(B.round,R) & (forall N:node_t. (quorum_t.member(N,Q) & is_good(N)) -> gv.node_has_locked_detail(N,B,R)))

	invariant forall Bc:block_t. forall Bp:block_t. Bc.parent = block_t.hash(Bp) -> Bp.round < Bc.round

	invariant forall B:block_t. block_t.nil.round <= B.round
} with gv,round_t, block_t

isolate gdc_properties1 = {
	invariant forall N:node_t. forall B:block_t. forall R:round_t. forall Bl:block_t. (gv.node_has_voted_detail(N,B,R,Bl) & is_good(N)) -> (round_t.succ(B.round,R) & B.parent = block_t.hash(Bl) & gv.node_has_voted(N,B) & (Bl = block_t.nil | gv.node_has_locked_recently(N,Bl,R)))

	invariant forall N:node_t. forall B:block_t. forall R:round_t. (is_good(N) & gv.node_has_locked_detail(N,B,R)) -> B.round < R

	private {
		invariant forall N:node_t. forall B:block_t. (is_good(N) & gv.node_has_voted(N,B)) -> exists R:round_t. exists Bp:block_t. (gv.node_has_voted_detail(N,B,R,Bp) & round_t.succ(B.round,R) & B.parent = block_t.hash(Bp))
	}

	invariant forall Bc:block_t. forall Bp:block_t. gv.quorum_of_votes(Bc,Bp) <-> exists Q:quorum_t. exists R:round_t. round_t.succ(Bc.round,R) &  Bc.parent=block_t.hash(Bp) & forall N1:node_t. ((quorum_t.member(N1,Q) & is_good(N1)) -> (gv.node_has_voted_detail(N1,Bc,R,Bp) & is_good(N1)))

	invariant forall Bc:block_t. forall Bp:block_t. forall N:node_t. (is_good(N) & gv.node_has_locked(N,Bc) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil) -> gv.quorum_of_votes(Bc,Bp)

	invariant forall Bp:block_t. forall R:round_t. (gv.quorum_of_recent_locks(Bp,R) <-> exists Q:quorum_t. forall N:node_t. (quorum_t.member(N,Q) & is_good(N) & Bp~= block_t.nil) -> gv.node_has_locked_recently(N,Bp,R))

	############# starting experimentation from here
} with gv, quorum_t, round_t, block_t

isolate gdc_properties2 = {

	private {
		invariant forall N:node_t. forall B:block_t. forall R:round_t. forall Bl:block_t. (gv.node_has_voted_detail(N,B,R,Bl) & is_good(N)) -> (round_t.succ(B.round,R) & B.parent = block_t.hash(Bl) & gv.node_has_voted(N,B) & (Bl = block_t.nil | gv.node_has_locked_recently(N,Bl,R)))

		invariant forall N:node_t. forall B:block_t. forall R:round_t. forall Bl:block_t. (gv.node_has_voted_detail(N,B,R,Bl) & is_good(N) & Bl ~= block_t.nil) -> (round_t.succ(B.round,R) & B.parent = block_t.hash(Bl) & gv.node_has_voted(N,B) & gv.node_has_locked_recently(N,Bl,R))
	}

	invariant forall Bc:block_t. forall Bp:block_t. forall R:round_t. (gv.quorum_of_votes(Bc,Bp) & round_t.succ(Bc.round,R) & Bp ~= block_t.nil) -> exists Q:quorum_t. exists R:round_t. round_t.succ(Bc.round,R) &  Bc.parent=block_t.hash(Bp) & forall N1:node_t. ((quorum_t.member(N1,Q) & is_good(N1)) -> (gv.node_has_voted_detail(N1,Bc,R,Bp) & is_good(N1)))

	invariant forall Bc:block_t. forall Bp:block_t. forall R:round_t. (gv.quorum_of_votes(Bc,Bp) & round_t.succ(Bc.round,R) & Bp ~= block_t.nil) -> gv.quorum_of_recent_locks(Bp,R)

	invariant forall N:node_t. forall B:block_t. forall R:round_t. (is_good(N) & gv.node_has_locked_detail(N,B,R)) -> B.round < R

	invariant forall B:block_t. forall Bp:block_t. (exists N:node_t. (is_good(N) & gv.node_has_locked(N,B)) & B.parent=block_t.hash(Bp) & round_t.succ(Bp.round,B.round) & Bp ~= block_t.nil) -> gdc_properties.gdc(Bp)
} with gv, quorum_t, round_t, gdc_properties,gdc_properties1

isolate gdc_properties3 = {

	############################ start experimentation from here
	invariant forall R1,R2,R3:round_t. (round_t.succ(R1,R2) & round_t.succ(R1,R3)) -> R2 = R3
	
	private {
		invariant forall N:node_t. forall B:block_t. forall R:round_t. forall Bp:block_t. (is_good(N) & gv.node_has_voted(N,B) & round_t.succ(B.round,R) & B.parent = block_t.hash(Bp)) -> gv.node_has_voted_detail(N,B,R,Bp)
	}

	invariant forall N:node_t. forall Bc:block_t. forall R:round_t. forall Bp:block_t. forall Qc:cert_t. (is_good(N) & gv.node_has_processed_qc(N,Qc) & Qc.block = Bc & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & round_t.succ(Bc.round,R)) -> forall N1:node_t. (is_good(N1) & quorum_t.member(N1,Qc.cert)) -> (is_good(N1) & gv.node_has_voted(N1,Bc) & round_t.succ(Bc.round,R) & Bc.parent=block_t.hash(Bp))

	invariant forall N:node_t. forall Bc:block_t. forall R:round_t. forall Bp:block_t. forall Qc:cert_t. (is_good(N) & gv.node_has_processed_qc(N,Qc) & Qc.block = Bc & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & round_t.succ(Bc.round,R)) -> forall N1:node_t. (is_good(N1) & quorum_t.member(N1,Qc.cert)) -> (is_good(N1) & gv.node_has_voted_detail(N1,Bc,R,Bp))

	invariant forall N:node_t. forall B:block_t. forall R:round_t. forall Bl:block_t. (gv.node_has_voted_detail(N,B,R,Bl) & is_good(N)) -> (round_t.succ(B.round,R) & B.parent = block_t.hash(Bl) & gv.node_has_voted(N,B) & (Bl = block_t.nil | gv.node_has_locked_recently(N,Bl,R)))

	invariant forall N:node_t. forall Bc:block_t. forall R:round_t. forall Bp:block_t. forall Qc:cert_t. (is_good(N) & gv.node_has_processed_qc(N,Qc) & Qc.block = Bc & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & round_t.succ(Bc.round,R)) -> forall N1:node_t. (is_good(N1) & quorum_t.member(N1,Qc.cert)) -> (is_good(N1) & (Bp ~= block_t.nil | gv.node_has_locked_recently(N1,Bp,R)))
} with gv, quorum_t, round_t, gdc_properties,gdc_properties1, gdc_properties2, block_t

isolate gdc_properties4 = {
	invariant forall Bgdc:block_t. forall Rgdc:round_t. (gdc_properties.gdc(Bgdc) & round_t.succ(Bgdc.round,Rgdc)) -> exists Q:quorum_t. (forall N:node_t. (quorum_t.member(N,Q) & is_good(N)) -> gv.node_has_locked_detail(N,Bgdc,Rgdc))

} with gv, quorum_t, round_t, block_t, gdc_properties,gdc_properties1

isolate gdc_properties5 = {
	relation quorum_of_locks(B:block_t, R:round_t)

	definition quorum_of_locks(B:block_t, R:round_t) = exists Q:quorum_t. forall N:node_t. (is_good(N) & quorum_t.member(N,Q)) -> gv.node_has_locked_detail(N,B,R)

	invariant forall Bp:block_t. forall R:round_t. (gv.quorum_of_recent_locks(Bp,R) & Bp ~= block_t.nil) -> exists Q:quorum_t. forall N:node_t. (quorum_t.member(N,Q) & is_good(N)) -> gv.node_has_locked_recently(N,Bp,R)

	invariant forall B:block_t. forall R:round_t. quorum_of_locks(B, R) -> exists Q:quorum_t. forall N:node_t. (is_good(N) & quorum_t.member(N,Q)) -> gv.node_has_locked_detail(N,B,R)

	#invariant exists Qgdc:quorum_t. exists Bgdc:block_t. exists Rgdc:round_t. ((forall N:node_t. (quorum_t.member(N,Q) & is_good(N)) -> gv.node_has_locked_detail(N,Bgdc,Rgdc)) -> (exists Qlr:quorum_t. exists Bplr:block_t. exists Rlr:round_t. ((forall N1:node_t. (is_good(N1) & quorum_t.member(N1,Qlr)) -> (is_good(N1) & (Bplr ~= block_t.nil | gv.node_has_locked_recently(N1,Bplr,Rlr)))) -> exists N2:node_t. (is_good(N2) & gv.node_has_locked_detail(N,Bgdc,Rgdc) & (Bplr ~= block_t.nil | gv.node_has_locked_recently(N1,Bplr,Rlr))))))

	invariant forall Bgdc:block_t. forall Rgdc:round_t. forall Blr:block_t. forall Rlr:round_t. (quorum_of_locks(Bgdc,Rgdc) & gv.quorum_of_recent_locks(Blr,Rlr) & Blr~= block_t.nil) -> exists N:node_t. (is_good(N) & gv.node_has_locked_detail(N,Bgdc,Rgdc)  & gv.node_has_locked_recently(N,Blr,Rlr))

	invariant forall Bgdc:block_t. forall Blr:block_t. exists Rgdc:round_t. exists Rlr:round_t. (quorum_of_locks(Bgdc,Rgdc) & gv.quorum_of_recent_locks(Blr,Rlr) & Blr~= block_t.nil & Rgdc < Rlr) -> exists N:node_t. (is_good(N) & gv.node_has_locked_detail(N,Bgdc,Rgdc)  & gv.node_has_locked_recently(N,Blr,Rlr) & Rgdc < Rlr)
} with gv,quorum_t

isolate gdc_supplementary_defs = {
	relation no_lock(N:node_t,Rl:round_t,Ru:round_t,Bs:block_t)

	definition no_lock(N,Rl,Ru,Bs:block_t) = forall R:round_t. forall B:block_t. (((Rl < R & R < Ru) -> ~gv.node_has_locked_detail(N,B,R)) & ((gv.node_has_locked_detail(N,B,Rl) & B ~= Bs) -> B.round < Bs.round))

	relation node_has_two_locks(Bc:block_t, Bgdc:block_t, Bp:block_t)

	definition node_has_two_locks(Bc:block_t, Bgdc:block_t, Bp:block_t) = exists N1:node_t. exists Rcp1:round_t. exists Rgdc:round_t. is_good(N1) &round_t.succ(Bc.round,Rcp1) & round_t.succ(Bgdc.round,Rgdc) & gv.node_has_locked_detail(N1,Bgdc,Rgdc) & gv.node_has_locked_recently(N1,Bp,Rcp1) & Rgdc < Rcp1 & Bc.parent=block_t.hash(Bp)

	relation node_has_recent_lock(Bc:block_t,Bgdc:block_t,Bp:block_t)

	definition node_has_recent_lock(Bc:block_t,Bgdc:block_t,Bp:block_t) = exists N1:node_t. exists Rcp1:round_t. exists Rl:round_t. exists Rgdc:round_t. is_good(N1) & round_t.succ(Bc.round,Rcp1) & round_t.succ(Bgdc.round,Rgdc) & Rgdc < Rcp1 & Bc.parent=block_t.hash(Bp) & Rgdc <= Rl & Rl < Rcp1 & gv.node_has_locked_detail(N1,Bp,Rl)& gv.node_has_locked_detail(N1,Bgdc,Rgdc) & no_lock(N1,Rl,Rcp1,Bp)
}

isolate gdc_properties6 = {

	private {
		invariant forall N:node_t. forall Bs:block_t. forall Rs:round_t. gv.node_has_locked_recently(N,Bs,Rs) -> exists Rl:round_t. (Rl < Rs & gv.node_has_locked_detail(N,Bs,Rl) & gdc_supplementary_defs.no_lock(N,Rl,Rs,Bs))
	}
	
	invariant forall N:node_t. forall Bs:block_t. forall Rs:round_t. forall Bgdc:block_t. forall Rgdc:round_t. (gv.node_has_locked_recently(N,Bs,Rs) & gv.node_has_locked_detail(N,Bgdc,Rgdc) & Rgdc < Rs) -> (forall Rl:round_t. Rl < Rgdc -> ~gdc_supplementary_defs.no_lock(N,Rl,Rs,Bs))

	#invariant  forall Bgdc:block_t. forall N:node_t. forall Bp:block_t. forall Bc:block_t. exists Rgdc:round_t. exists Rcp1:round_t. (round_t.succ(Bc.round,Rcp1) & gv.node_has_locked_detail(N,Bgdc,Rgdc) & gv.node_has_locked_recently(N,Bp,Rcp1) & round_t.succ(Bgdc.round,Rgdc) & Rgdc < Rcp1) -> exists Rl:round_t. (Rgdc <= Rl & Rl < Rcp1 & gv.node_has_locked_detail(N,Bp,Rl) & no_lock(N,Rl,Rcp1,Bp) & Rgdc < Rcp1)

	invariant  forall Bc:block_t. forall Bgdc:block_t. forall Bp:block_t. (gdc_supplementary_defs.node_has_two_locks(Bc,Bgdc,Bp) -> gdc_supplementary_defs.node_has_recent_lock(Bc,Bgdc,Bp))
} with gv, quorum_t, round_t, block_t,gdc_supplementary_defs

isolate gdc_properties7m1 = {
	invariant forall Bc:block_t. forall Bp:block_t. forall N:node_t. (is_good(N) & gv.node_has_locked(N,Bc) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil) -> gv.quorum_of_votes(Bc,Bp)
} with gv,round_t,gdc_properties1

isolate gdc_properties7m2 = {	

	invariant forall Bc:block_t. forall Bp:block_t. (gv.quorum_of_votes(Bc,Bp) & Bp ~= block_t.nil) -> (exists R:round_t. round_t.succ(Bc.round,R) & Bp ~= block_t.nil & gv.quorum_of_recent_locks(Bp,R))
} with gv,round_t,quorum_t,gdc_properties2


isolate gdc_properties7 = {

	# private {
	# 	invariant forall N:node_t. forall B:block_t. forall R:round_t. forall Bl:block_t. (gv.node_has_voted_detail(N,B,R,Bl) & is_good(N) & Bl ~= block_t.nil) -> gv.node_has_locked_recently(N,Bl,R)
	# }

	invariant forall Bc:block_t. forall Bp:block_t. forall N:node_t. (is_good(N) & gv.node_has_locked(N,Bc) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil) -> exists Rcp1:round_t. round_t.succ(Bc.round,Rcp1) & gv.quorum_of_recent_locks(Bp,Rcp1)
} with gv,round_t,gdc_properties7m1,gdc_properties7m2

isolate gdc_properties8 = {
	invariant forall Bgdc:block_t. gdc_properties.gdc(Bgdc) -> exists Rgdc:round_t. round_t.succ(Bgdc.round,Rgdc) & gdc_properties5.quorum_of_locks(Bgdc,Rgdc)
} with gv,round_t,gdc_properties5,quorum_t,gdc_properties

isolate gdc_properties9 = {
	invariant forall Bc:block_t. forall Bp:block_t. forall N:node_t. forall Bgdc:block_t. (is_good(N) & gv.node_has_locked(N,Bc) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & gdc_properties.gdc(Bgdc) & Bgdc.round < Bc.round) -> (exists Rcp1:round_t. round_t.succ(Bc.round,Rcp1) & gv.quorum_of_recent_locks(Bp,Rcp1) & exists Rgdc:round_t. round_t.succ(Bgdc.round,Rgdc) & gdc_properties5.quorum_of_locks(Bgdc,Rgdc) & Rgdc < Rcp1)

} with gv, round_t,gdc_properties7,gdc_properties8

isolate gdc_properties10 = {
	relation gdc_and_lock(Bc:block_t,Bp:block_t,N:node_t,Bgdc:block_t)

	definition gdc_and_lock(Bc:block_t,Bp:block_t,N:node_t,Bgdc:block_t) = is_good(N) & gv.node_has_locked(N,Bc) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & gdc_properties.gdc(Bgdc) & Bgdc.round < Bc.round
	
	invariant forall Bc:block_t. forall Bp:block_t. forall N:node_t. forall Bgdc:block_t. gdc_and_lock(Bc,Bp,N,Bgdc) -> gdc_supplementary_defs.node_has_two_locks(Bc,Bgdc,Bp)
} with gv, round_t,gdc_properties5,gdc_properties9,gdc_supplementary_defs

isolate gdc_properties11 = {
	#invariant  forall Bc:block_t. forall Bgdc:block_t. forall Bp:block_t. (gdc_properties10.node_has_two_locks(Bc,Bgdc,Bp) -> gdc_properties10.node_has_recent_lock(Bc,Bgdc,Bp))

	# theorem [chaining] {
	# 	type t1
	# 	type t2
	# 	relation rel1(Bc:t1,Bp:t1,N:t2,Bgdc:t1)
	# 	relation rel2(Bc:t1,Bgdc:t1,Bp:t1)
	# 	relation rel3(Bc:t1,Bgdc:t1,Bp:t1)
	# 	#---------------------------------------------------
	# 	property (forall Bc:t1. forall Bp:t1. forall N:t2. forall Bgdc:t1. rel1(Bc,Bp,N,Bgdc) -> rel2(Bc,Bgdc,Bp)) & (forall Bc:t1. forall Bgdc:t1. forall Bp:t1. (rel2(Bc,Bgdc,Bp) -> rel3(Bc,Bgdc,Bp))) -> (forall Bc:t1. forall Bp:t1. forall N:t2. forall Bgdc:t1. rel1(Bc,Bp,N,Bgdc) ->  rel3(Bc,Bgdc,Bp))
	# }

	#property (forall Bc:block_t. forall Bp:block_t. forall N:node_t. forall Bgdc:block_t. gdc_properties10.gdc_and_lock(Bc,Bp,N,Bgdc) -> gdc_supplementary_defs.node_has_two_locks(Bc,Bgdc,Bp)) & (forall Bc:block_t. forall Bgdc:block_t. forall Bp:block_t. (gdc_supplementary_defs.node_has_two_locks(Bc,Bgdc,Bp) -> gdc_supplementary_defs.node_has_recent_lock(Bc,Bgdc,Bp))) -> (forall Bc:block_t. forall Bp:block_t. forall N:node_t. forall Bgdc:block_t. gdc_properties10.gdc_and_lock(Bc,Bp,N,Bgdc) ->  gdc_supplementary_defs.node_has_recent_lock(Bc,Bgdc,Bp))
	# proof {
	# 	apply chaining with t1=block_t, t2=node_t
	# }

	invariant forall Bc:block_t. forall Bp:block_t. forall N:node_t. forall Bgdc:block_t. gdc_properties10.gdc_and_lock(Bc,Bp,N,Bgdc) ->  gdc_supplementary_defs.node_has_recent_lock(Bc,Bgdc,Bp)
} with gv,gdc_properties10,gdc_properties6

isolate gdc_properties9am1 = {

	#invariant forall Bc:block_t. forall Bp:block_t. forall R:round_t. (gv.quorum_of_votes(Bc,Bp) & round_t.succ(Bc.round,R) & Bp ~= block_t.nil) -> gv.quorum_of_recent_locks(Bp,R)

	#invariant forall Bc:block_t. forall Bp:block_t. (gv.quorum_of_votes(Bc,Bp) & round_t.succ(Bc.round,R) & Bp ~= block_t.nil) -> exists R:round_t. (round_t.succ(Bp.round,R) & gv.quorum_of_recent_locks(Bp,R))

	invariant forall Bc:block_t. forall Bp:block_t. (gv.quorum_of_votes(Bc,Bp) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil) -> (exists Rcp1:round_t. round_t.succ(Bc.round,Rcp1) & gv.quorum_of_recent_locks(Bp,Rcp1))

	#invariant forall Bc:block_t. forall Bp:block_t. forall R:round_t. (gv.quorum_of_votes(Bc,Bp) & round_t.succ(Bc.round,R) & Bp ~= block_t.nil) -> gv.quorum_of_recent_locks(Bp,R)

} with gdc_properties2,gv, round_t#,gdc_properties1

isolate gdc_properties9a = {

	private {
		invariant forall Bc:block_t. forall Bp:block_t. forall Rcp1:round_t. forall Bgdc:block_t. (round_t.succ(Bc.round,Rcp1) & gv.quorum_of_votes(Bc,Bp) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & gdc_properties.gdc(Bgdc) & Bgdc.round < Bc.round) -> (gv.quorum_of_recent_locks(Bp,Rcp1) & exists Rgdc:round_t. round_t.succ(Bgdc.round,Rgdc) & gdc_properties5.quorum_of_locks(Bgdc,Rgdc) & Rgdc < Rcp1)
	}
	invariant forall Bc:block_t. forall Bp:block_t. forall N:node_t. forall Bgdc:block_t. (is_good(N) & gv.quorum_of_votes(Bc,Bp) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & gdc_properties.gdc(Bgdc) & Bgdc.round < Bc.round) -> (exists Rcp1:round_t. round_t.succ(Bc.round,Rcp1) & gv.quorum_of_recent_locks(Bp,Rcp1) & exists Rgdc:round_t. round_t.succ(Bgdc.round,Rgdc) & gdc_properties5.quorum_of_locks(Bgdc,Rgdc) & Rgdc < Rcp1)

	invariant forall Bc:block_t. forall Bp:block_t. forall Bgdc:block_t. (gv.quorum_of_votes(Bc,Bp) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & gdc_properties.gdc(Bgdc) & Bgdc.round < Bc.round) -> (exists Rcp1:round_t. round_t.succ(Bc.round,Rcp1) & gv.quorum_of_recent_locks(Bp,Rcp1) & exists Rgdc:round_t. round_t.succ(Bgdc.round,Rgdc) & gdc_properties5.quorum_of_locks(Bgdc,Rgdc) & Rgdc < Rcp1)
} with gv, round_t,gdc_properties9am1,gdc_properties8

isolate gdc_properties10a = {
	relation gdc_and_quorum(Bc:block_t,Bp:block_t,Bgdc:block_t)

	definition gdc_and_quorum(Bc:block_t,Bp:block_t,Bgdc:block_t) = gv.quorum_of_votes(Bc,Bp) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & gdc_properties.gdc(Bgdc) & Bgdc.round < Bc.round
	
	invariant forall Bc:block_t. forall Bp:block_t. forall Bgdc:block_t. gdc_and_quorum(Bc,Bp,Bgdc) -> gdc_supplementary_defs.node_has_two_locks(Bc,Bgdc,Bp)
} with gv, round_t,gdc_properties5,gdc_properties9a,gdc_supplementary_defs

isolate gdc_properties11a = {
	invariant forall Bc:block_t. forall Bp:block_t. forall Bgdc:block_t. gdc_properties10a.gdc_and_quorum(Bc,Bp,Bgdc) ->  gdc_supplementary_defs.node_has_recent_lock(Bc,Bgdc,Bp)
} with gv,gdc_properties10a,gdc_properties6


isolate quorum_propogationm1 = {

	invariant forall Bc:block_t. forall Bp:block_t. forall R:round_t. (gv.quorum_of_votes(Bc,Bp) & round_t.succ(Bc.round,R) & Bp ~= block_t.nil) -> gv.quorum_of_recent_locks(Bp,R)

} with gv,gdc_properties2

isolate quorum_propogationm2 = {

	private {
		invariant forall N:node_t. forall B:block_t. (is_good(N) & gv.node_has_voted(N,B)) -> exists R:round_t. exists Bp:block_t. (gv.node_has_voted_detail(N,B,R,Bp) & round_t.succ(B.round,R) & B.parent = block_t.hash(Bp))
		
		#invariant forall N:node_t. forall B:block_t. forall Bp:block_t. forall R:round_t.  (is_good(N) & gv.node_has_voted(N,B) & B.parent = block_t.hash(Bp) & round_t.succ(B.round,R)) -> (gv.node_has_voted_detail(N,B,R,Bp))
	}

	invariant forall Bc:block_t. forall Bp:block_t. (Bc.parent = block_t.hash(Bp)) -> Bp.round < Bc.round

	invariant forall B:block_t. block_t.nil.round <= B.round

	invariant forall Bc:block_t. forall Bp:block_t. gv.quorum_of_votes(Bc,Bp) <-> exists Q:quorum_t. exists R:round_t. round_t.succ(Bc.round,R) &  Bc.parent=block_t.hash(Bp) & forall N1:node_t. ((quorum_t.member(N1,Q) & is_good(N1)) -> (gv.node_has_voted_detail(N1,Bc,R,Bp) & is_good(N1)))

	invariant forall B:block_t. forall Bp1:block_t. forall Bp2:block_t. (B.parent = block_t.hash(Bp1) & B.parent = block_t.hash(Bp2)) -> Bp1 = Bp2

	invariant forall N:node_t. forall B:block_t. forall R:round_t. gv.node_has_locked_detail(N,B,R) -> gv.node_has_locked(N,B)

	invariant forall Bp:block_t. forall Bgp:block_t. forall N:node_t. (is_good(N) & gv.node_has_locked(N,Bp) & Bp.parent=block_t.hash(Bgp)) -> gv.quorum_of_votes(Bp,Bgp)
} with gv,quorum_t,block_t,round_t,quorum_propogationm1

isolate quorum_propogation = {
	relation block_has_qov(B:block_t)

	definition block_has_qov(B:block_t) = B ~= block_t.nil & (exists Bp:block_t. (B.parent=block_t.hash(Bp) & gv.quorum_of_votes(B,Bp)))

	private {

		invariant forall Bp:block_t. forall R:round_t. (gv.quorum_of_recent_locks(Bp,R) & Bp ~= block_t.nil) -> exists N:node_t. (is_good(N) & gv.node_has_locked(N,Bp))

		invariant forall N:node_t. forall B:block_t. (is_good(N) & gv.node_has_voted(N,B)) -> exists Bp:block_t. ( B.parent = block_t.hash(Bp))

		#invariant forall N:node_t. forall Bp:block_t. (is_good(N) & gv.node_has_locked(N,Bp) & Bp ~= block_t.nil) -> exists Bgp:block_t. Bp.parent = block_t.hash(Bgp)
	}

	invariant forall B:block_t. forall Bp:block_t. (block_has_qov(B) & B.parent = block_t.hash(Bp) & Bp ~= block_t.nil) -> block_has_qov(Bp)
} with gv,quorum_t,block_t,quorum_propogationm1,quorum_propogationm2

isolate gdc_properties12 = {
	relation nil_locks_upto_round(N:node_t, R:round_t)

	definition nil_locks_upto_round(N:node_t, R:round_t) = forall Rp:round_t. forall B:block_t. (Rp <= R & gv.node_has_locked_detail(N,B,Rp) -> B=block_t.nil)

	invariant forall Bc:block_t. (quorum_propogation.block_has_qov(Bc) & Bc.parent = block_t.hash(block_t.nil)) -> gv.quorum_of_votes(Bc,block_t.nil)

	invariant forall Bc:block_t. gv.quorum_of_votes(Bc,block_t.nil) -> exists Q:quorum_t. forall N:node_t. ((is_good(N) & quorum_t.member(N,Q)) -> nil_locks_upto_round(N,Bc.round))

	invariant forall Bc:block_t. (quorum_propogation.block_has_qov(Bc) & Bc.parent = block_t.hash(block_t.nil)) -> exists Q:quorum_t. forall N:node_t. ((is_good(N) & quorum_t.member(N,Q)) -> nil_locks_upto_round(N,Bc.round))
} with gv,round_t,block_t,quorum_propogation,gdc_properties1

isolate gdc_properties13 = {
	invariant forall Bgdc:block_t. forall Bc:block_t. ((exists Q1:quorum_t. forall N:node_t. (quorum_t.member(N,Q1) & is_good(N)) -> gdc_properties12.nil_locks_upto_round(N,Bc.round))) & (exists Q2:quorum_t. exists R:round_t. (round_t.succ(Bgdc.round,R) & (forall N:node_t. (quorum_t.member(N,Q2) & is_good(N)) -> gv.node_has_locked_detail(N,Bgdc,R)))) -> exists N:node_t. (is_good(N) & quorum_t.member(N,Q1) & quorum_t.member(N,Q2))

	invariant forall Bgdc:block_t. forall Bc:block_t. (((exists Q1:quorum_t. forall N:node_t. (quorum_t.member(N,Q1) & is_good(N)) -> gdc_properties12.nil_locks_upto_round(N,Bc.round))) & (exists Q2:quorum_t. exists R:round_t. (round_t.succ(Bgdc.round,R) & (forall N:node_t. (quorum_t.member(N,Q2) & is_good(N)) -> gv.node_has_locked_detail(N,Bgdc,R)))) & Bgdc ~= block_t.nil)-> (exists N:node_t. is_good(N) & gdc_properties12.nil_locks_upto_round(N,Bc.round) & (exists R:round_t. (round_t.succ(Bgdc.round,R) & gv.node_has_locked_detail(N,Bgdc,R))) & Bgdc ~= block_t.nil)
	
	invariant forall Bgdc:block_t. forall Bc:block_t. (exists N:node_t. (is_good(N) & gdc_properties12.nil_locks_upto_round(N,Bc.round) & (exists R:round_t. (round_t.succ(Bgdc.round,R) & gv.node_has_locked_detail(N,Bgdc,R))) & Bgdc ~= block_t.nil)) -> Bc.round <= Bgdc.round 
	
	invariant forall Bgdc:block_t. forall Bc:block_t. ((exists Q1:quorum_t. forall N:node_t. (quorum_t.member(N,Q1) & is_good(N)) -> gdc_properties12.nil_locks_upto_round(N,Bc.round)) & (exists Q2:quorum_t. exists R:round_t. (round_t.succ(Bgdc.round,R) & (forall N:node_t. (quorum_t.member(N,Q2) & is_good(N)) -> gv.node_has_locked_detail(N,Bgdc,R)))) & Bgdc ~= block_t.nil) ->  Bc.round <= Bgdc.round
} with gv,round_t,block_t,quorum_t,gdc_properties12,gdc_properties,quorum_propogation

isolate gdc_properties14 = {

	invariant forall Bgdc:block_t. forall Bc:block_t. (quorum_propogation.block_has_qov(Bc) & Bc.parent = block_t.hash(block_t.nil) & gdc_properties.gdc(Bgdc) & Bgdc ~= block_t.nil) ->  Bc.round <= Bgdc.round

} with gv,round_t,block_t,quorum_t,gdc_properties,gdc_properties12,gdc_properties13

isolate gdc_properties15 = {

	invariant forall Bgdc:block_t. forall Bp:block_t. (gdc_properties.gdc(Bgdc) & Bgdc.parent=block_t.hash(Bp) & Bp ~= block_t.nil) -> exists N:node_t. (is_good(N) & gv.node_has_locked(N,Bgdc) & gv.quorum_of_votes(Bgdc,Bp))

	#invariant forall Bgdc:block_t. forall Bp:block_t. (gdc_properties.gdc(Bgdc) & Bgdc.parent=block_t.hash(Bp) & Bp ~= block_t.nil) -> exists N:node_t. (is_good(N) & gv.node_has_locked(N,Bgdc) & gv.quorum_of_votes(Bgdc,Bp) & quorum_propogation.block_has_qov(Bgdc))
} with gv, quorum_t, round_t, block_t,gdc_properties,gdc_properties1

isolate gdc_properties16 = {

	invariant forall Bgdc:block_t. forall Bp:block_t. (Bgdc.parent=block_t.hash(Bp) & gv.quorum_of_votes(Bgdc,Bp)) -> quorum_propogation.block_has_qov(Bgdc)

	invariant forall Bgdc:block_t. forall Bp:block_t. (gdc_properties.gdc(Bgdc) & Bgdc.parent=block_t.hash(Bp) & Bp ~= block_t.nil) -> exists N:node_t. (is_good(N) & gv.node_has_locked(N,Bgdc) & gv.quorum_of_votes(Bgdc,Bp))

	invariant forall Bgdc:block_t. forall Bp:block_t. (gdc_properties.gdc(Bgdc) & Bgdc.parent=block_t.hash(Bp) & Bp ~= block_t.nil) -> quorum_propogation.block_has_qov(Bgdc)
} with gv, quorum_t, round_t, block_t,gdc_properties,gdc_properties15,quorum_propogation

isolate basic_safety = {

	isolate processor = {
		instantiate supraBFT(gv)

		invariant forall Bc:block_t. forall Bp:block_t. Bc.parent = block_t.hash(Bp) -> Bp.round < Bc.round

		invariant forall B:block_t. block_t.nil.round <= B.round

		invariant forall M:msg. forall D:node_t. (shim.sent(M,D) & M.kind = msg_kind.prepare) -> gv.node_has_voted(M.src,M.prep)

		invariant forall M:msg. forall D:node_t. (shim.sent(M,D) & M.kind=msg_kind.timeout) -> gv.node_sent_timeout(M.src,M.t)

		invariant forall N:node_t. forall H:height_t. (is_good(N) & validator(N).blockchain(H) ~= block_t.nil) -> exists Q:cert_t. (Q.block = validator(N).blockchain(H) & validator(N).qc_processed(Q))

		invariant forall N:node_t. forall B:block_t. forall R:round_t. (is_good(N) & gv.node_has_locked_detail(N,B,R)) -> (B.round < validator(N).locked.block.round | B = validator(N).locked.block)

		invariant forall N:node_t. forall B:block_t. forall Rl:round_t. forall Rs:round_t. (is_good(N) & gv.node_has_locked_detail(N,validator(N).locked.block,Rl) & Rl < Rs) -> ~gv.node_has_locked_detail(N,B,Rs)

		invariant forall N:node_t. forall B:block_t. forall R:round_t. forall Bl:block_t. (is_good(N) & gv.node_has_voted_detail(N,B,R,Bl)) -> R <= validator(N).r_c

		invariant forall N:node_t. forall B:block_t. forall R:round_t. (is_good(N) & gv.node_has_locked_detail(N,B,R)) -> R <= validator(N).r_c	

		invariant forall N:node_t. forall Q:cert_t. (is_good(N) & validator(N).qc_processed(Q)) -> gv.node_has_processed_qc(N,Q)

		########### starting experimentation from here
	} with gv, round_t, height_t, block_t, voted_t, cert_t, timeout_t, timeout_cert_t, proposal_t, shim, net.spec

	isolate continuity = {
    	invariant forall N:node_t. forall Qd:cert_t. forall Hd,Ha,Hi:height_t. (is_good(N) & processor.validator(N).forest_heights(Qd,Hd,Ha) & Ha <= Hi & Hi <= Hd) -> processor.validator(N).forest_heights(Qd,Hd,Hi)

    	invariant forall Hd,Hi,Ha:height_t. (Hd = Ha & Ha <= Hi & Hi <= Hd) -> Hi = Hd
	} with gv,processor, round_t, height_t

	isolate ldc_propertiesm1 = {
		relation ldc(N:node_t, Bp:block_t, Bc:block_t)

		definition ldc(N:node_t, Bp:block_t, Bc:block_t) = Bc.parent = block_t.hash(Bp) & (forall Rp:round_t. (Bp.round < Rp -> Bc.round <= Rp)) & gv.node_has_locked(N,Bc)

		relation gdc_x(B:block_t)

		definition gdc_x(B:block_t) = exists Q:quorum_t. exists R:round_t. ((B.round < R & forall Ri:round_t. (B.round < Ri -> R <= Ri)) & (forall N:node_t. (quorum_t.member(N,Q) & is_good(N)) -> gv.node_has_locked_detail(N,B,R)))

		property forall B:block_t. gdc_x(B) <-> gdc_properties.gdc(B)

		# relation height_succ(H1:height_t, H2:height_t)

		# definition height_succ(H1,H2) = H1 < H2 & forall Hi:height_t. (H1 < Hi -> (H2 < Hi | H2 = Hi))

		# invariant forall H1,H2:height_t. height_succ(H1,H2) <-> height_t.succ(H1,H2)

	} with gv,gdc_properties,gdc_properties2, round_t, height_t

	isolate ldc_propertiesm2 = {
		#invariant forall B:block_t. forall Bp:block_t. (exists N:node_t. (is_good(N) & gv.node_has_locked(N,B)) & B.parent=block_t.hash(Bp) & round_t.succ(Bp.round,B.round) & Bp ~= block_t.nil) -> ldc_propertiesm1.gdc_x(Bp)

		invariant forall B:block_t. forall Bp:block_t. forall N:node_t. ((is_good(N) & ldc_propertiesm1.ldc(N,Bp,B) & Bp ~= block_t.nil) -> ldc_propertiesm1.gdc_x(Bp))
	} with gv,gdc_properties,gdc_properties2, round_t, height_t, ldc_propertiesm1

	# isolate ldc_properties = {

	# 	invariant forall B:block_t. forall Bp:block_t. (exists N:node_t. (is_good(N) & gv.node_has_locked(N,B)) & B.parent=block_t.hash(Bp) & (Bp.round < B.round & forall Ri:round_t. (Bp.round < Ri -> B.round <= Ri)) & Bp ~= block_t.nil) -> ldc_propertiesm1.gdc_x(Bp)

	# 	invariant forall B:block_t. forall Bp:block_t. (exists N:node_t. (is_good(N) & ldc_propertiesm1.ldc(N,Bp,B) & Bp ~= block_t.nil)) -> ldc_propertiesm1.gdc_x(Bp)
	# } with processor, round_t, gv, cert_t, height_t, block_t,ldc_propertiesm1,ldc_propertiesm2

	isolate ldc_properties = {
		invariant forall N:node_t. forall B:block_t. forall R:round_t. gv.node_has_locked_detail(N,B,R) -> R <= processor.validator(N).r_c

		private {
			invariant forall N:node_t. forall B:block_t. forall R:round_t. (is_good(N) & gv.node_has_locked_detail(N,B,R)) -> exists Q:cert_t. (processor.validator(N).qc_processed(Q) & Q.block = B)
		}

		invariant forall N:node_t. forall B1:block_t. forall B2:block_t. forall R1:round_t. forall R2:round_t. (is_good(N) & gv.node_has_locked_detail(N,B1,R1) & gv.node_has_locked_detail(N,B2,R2) & R1 < R2) -> B1.round < B2.round

		invariant forall N:node_t. forall H:height_t. (is_good(N) & height_t.succ(H,processor.validator(N).chain_size)) -> (gv.node_has_locked(N,processor.validator(N).tip_of_chain_qc.block) & round_t.succ(processor.validator(N).tip_of_chain_qc.block.round, processor.validator(N).dc_basis_block.round) & processor.validator(N).dc_basis_block.parent = block_t.hash(processor.validator(N).tip_of_chain_qc.block))

		invariant forall N:node_t. (is_good(N) & processor.validator(N).locked ~= cert_t.nil) -> processor.validator(N).forest_leaf(processor.validator(N).locked, processor.validator(N).locked_height)

		invariant forall N:node_t. (is_good(N) & processor.validator(N).dc_basis_qc ~= cert_t.nil) -> gv.node_has_locked(N,processor.validator(N).dc_basis_block)
		
		invariant forall N:node_t. (is_good(N)) -> processor.validator(N).qp_when_adding_qc = processor.validator(N).tip_of_chain_qc

		invariant forall N:node_t. (is_good(N) & processor.validator(N).tip_of_chain_qc ~= cert_t.nil) -> processor.validator(N).commit_candidates(processor.validator(N).tip_of_chain_qc,processor.validator(N).tip_of_chain_height)

		invariant forall N:node_t. (is_good(N) & processor.validator(N).tip_of_chain_qc ~= cert_t.nil) -> (processor.validator(N).blockchain(processor.validator(N).tip_of_chain_height) = processor.validator(N).tip_of_chain_qc.block & processor.validator(N).dc_basis_block.parent = block_t.hash(processor.validator(N).tip_of_chain_qc.block) & round_t.succ(processor.validator(N).tip_of_chain_qc.block.round, processor.validator(N).dc_basis_block.round))

		invariant forall N:node_t. forall H:height_t. (is_good(N) & height_t.succ(H,processor.validator(N).chain_size)) -> ldc_propertiesm1.ldc(N,processor.validator(N).blockchain(H),processor.validator(N).dc_basis_block)
	} with processor, round_t, gv, cert_t, height_t, block_t,gdc_properties,ldc_propertiesm1,ldc_propertiesm2, ldc_properties

	isolate ldc_properties1 = {
		invariant forall N:node_t. forall H:height_t. (is_good(N) & height_t.succ(H,processor.validator(N).chain_size)) -> ldc_propertiesm1.ldc(N,processor.validator(N).blockchain(H),processor.validator(N).dc_basis_block)	
	} with processor,gv,ldc_properties,ldc_propertiesm1,round_t,height_t

	isolate ldc_properties2 = {
		invariant forall N:node_t. forall H:height_t. (is_good(N) & height_t.succ(H, processor.validator(N).chain_size)) -> ldc_propertiesm1.gdc_x(processor.validator(N).blockchain(H))

		########### starting experimentation from here

		invariant  forall Bc:block_t. forall Bgdc:block_t. forall Bp:block_t. (gdc_supplementary_defs.node_has_recent_lock(Bc,Bgdc,Bp) & Bp ~= Bgdc & Bgdc ~= block_t.nil & Bp ~= block_t.nil) -> Bgdc.round < Bp.round

	} with processor, round_t, gv, cert_t, height_t, block_t,ldc_propertiesm2, ldc_properties1,ldc_properties,gdc_supplementary_defs

	isolate ldc_properties2a = {
		invariant  forall Bc:block_t. forall Bgdc:block_t. forall Bp:block_t. (gdc_supplementary_defs.node_has_recent_lock(Bc,Bgdc,Bp) & Bp ~= Bgdc & Bgdc ~= block_t.nil) -> Bgdc.round < Bp.round

	} with processor, round_t, gv, cert_t, height_t, block_t,ldc_propertiesm2, ldc_properties1,ldc_properties,gdc_supplementary_defs

	isolate ldc_properties3 = {
		invariant forall Bc:block_t. forall Bp:block_t. forall N:node_t. forall Bgdc:block_t. gdc_properties10.gdc_and_lock(Bc,Bp,N,Bgdc) ->  gdc_supplementary_defs.node_has_recent_lock(Bc,Bgdc,Bp)

		#invariant forall Bc:block_t. forall Bp:block_t. forall N:node_t. forall Bgdc:block_t. is_good(N) & gv.node_has_locked(N,Bc) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & ldc_propertiesm1.gdc_x(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & Bp ~= Bgdc -> Bgdc.round < Bp.round
	} with processor, gv,gdc_properties11,ldc_properties,round_t,block_t,gdc_properties10,gdc_properties6#,gdc_supplementary_defs

	isolate ldc_properties4 = {
		property forall Bc:block_t. forall Bp:block_t. forall N:node_t. forall Bgdc:block_t. (is_good(N) & gv.node_has_locked(N,Bc) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & ldc_propertiesm1.gdc_x(Bgdc) & Bgdc.round < Bc.round) -> gdc_properties10.gdc_and_lock(Bc,Bp,N,Bgdc)
	} with gdc_properties10,ldc_propertiesm1

	isolate ldc_properties5 = {
		invariant forall Bc:block_t. forall Bp:block_t. forall N:node_t. forall Bgdc:block_t. is_good(N) & gv.node_has_locked(N,Bc) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & ldc_propertiesm1.gdc_x(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & Bp ~= Bgdc -> gdc_supplementary_defs.node_has_recent_lock(Bc,Bgdc,Bp) & Bp ~= Bgdc & Bgdc ~= block_t.nil & Bp ~= block_t.nil

		#invariant forall Bc:block_t. forall Bp:block_t. forall N:node_t. forall Bgdc:block_t. is_good(N) & gv.node_has_locked(N,Bc) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & ldc_propertiesm1.gdc_x(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & Bp ~= Bgdc -> Bgdc.round < Bp.round		
	} with gv,processor,ldc_properties3,ldc_properties2,ldc_properties4

	isolate ldc_properties6 = {
		invariant forall Bc:block_t. forall Bp:block_t. forall N:node_t. forall Bgdc:block_t. is_good(N) & gv.node_has_locked(N,Bc) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & ldc_propertiesm1.gdc_x(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & Bp ~= Bgdc -> Bgdc.round < Bp.round
	} with gv,processor,ldc_properties2,ldc_properties5

	isolate ldc_properties3a = {
		invariant forall Bc:block_t. forall Bp:block_t. forall Bgdc:block_t. gdc_properties10a.gdc_and_quorum(Bc,Bp,Bgdc) ->  gdc_supplementary_defs.node_has_recent_lock(Bc,Bgdc,Bp)

		#invariant forall Bc:block_t. forall Bp:block_t. forall N:node_t. forall Bgdc:block_t. is_good(N) & gv.node_has_locked(N,Bc) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & ldc_propertiesm1.gdc_x(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & Bp ~= Bgdc -> Bgdc.round < Bp.round
	} with processor, gv,gdc_properties11a,ldc_properties,round_t,block_t,gdc_properties10a,gdc_properties6#,gdc_supplementary_defs

	isolate ldc_properties4a = {
		property forall Bc:block_t. forall Bp:block_t. forall Bgdc:block_t. (gv.quorum_of_votes(Bc,Bp) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & ldc_propertiesm1.gdc_x(Bgdc) & Bgdc.round < Bc.round) -> gdc_properties10a.gdc_and_quorum(Bc,Bp,Bgdc)
	} with gdc_properties10a,ldc_propertiesm1

	isolate ldc_properties5a = {
		#invariant forall Bc:block_t. forall Bp:block_t. forall N:node_t. forall Bgdc:block_t. is_good(N) & gv.quorum_of_votes(Bc,Bp) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & ldc_propertiesm1.gdc_x(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & Bp ~= Bgdc -> gdc_supplementary_defs.node_has_recent_lock(Bc,Bgdc,Bp) & Bp ~= Bgdc & Bgdc ~= block_t.nil & Bp ~= block_t.nil

		invariant forall Bc:block_t. forall Bp:block_t. forall Bgdc:block_t. (gv.quorum_of_votes(Bc,Bp) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & ldc_propertiesm1.gdc_x(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & Bp ~= Bgdc) -> (gdc_supplementary_defs.node_has_recent_lock(Bc,Bgdc,Bp) & Bp ~= Bgdc & Bgdc ~= block_t.nil & Bp ~= block_t.nil)


		#invariant forall Bc:block_t. forall Bp:block_t. forall N:node_t. forall Bgdc:block_t. is_good(N) & gv.node_has_locked(N,Bc) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & ldc_propertiesm1.gdc_x(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & Bp ~= Bgdc -> Bgdc.round < Bp.round		
	} with gv,processor,ldc_properties3a,ldc_properties2,ldc_properties4a,gdc_properties,round_t,block_t

	isolate ldc_properties6a = {
		invariant forall Bc:block_t. forall Bp:block_t. forall Bgdc:block_t. is_good(N) & gv.quorum_of_votes(Bc,Bp) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & ldc_propertiesm1.gdc_x(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & Bp ~= Bgdc -> Bgdc.round < Bp.round

		relation gdc_chain_condition(Bc:block_t,Bp:block_t,Bgdc:block_t)

		definition gdc_chain_condition(Bc:block_t,Bp:block_t,Bgdc:block_t) = gv.quorum_of_votes(Bc,Bp) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & ldc_propertiesm1.gdc_x(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & Bp ~= Bgdc

		invariant forall Bc:block_t. forall Bp:block_t. forall Bgdc:block_t. gdc_chain_condition(Bc,Bp,Bgdc) -> Bgdc.round < Bp.round
	
		
		#invariant forall Bc:block_t. forall Bp:block_t. forall Bgdc:block_t. (gv.quorum_of_votes(Bc,Bp) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & gdc_properties.gdc(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & Bp ~= Bgdc) -> Bgdc.round < Bp.round
	} with gv,processor,ldc_properties2,ldc_properties5a#,ldc_propertiesm1

	isolate ldc_properties6b = {

		invariant forall Bc:block_t. forall Bp:block_t. forall Bgdc:block_t. (gv.quorum_of_votes(Bc,Bp) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & gdc_properties.gdc(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & Bp ~= Bgdc) -> ldc_properties6a.gdc_chain_condition(Bc,Bp,Bgdc)
	} with gv,processor,ldc_properties2,ldc_properties5a,ldc_properties6a,ldc_propertiesm1

	isolate ldc_properties6c = {

		invariant forall Bc:block_t. forall Bp:block_t. forall Bgdc:block_t. (gv.quorum_of_votes(Bc,Bp) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & gdc_properties.gdc(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & Bp ~= Bgdc) -> Bgdc.round < Bp.round
		
	} with gv,processor,ldc_properties6a,ldc_properties6b

	isolate gdc_chain_lemma = {
		relation ascendant(Bd:block_t, Ba:block_t)

		object spec = {
			after init {
				#assume forall B:block_t. B.parent = block_t.hash(block_t.nil) if B ~= block_t.nil else hash_t.nil;

				#assume forall B:block_t. B.round = round_t.next(0) if B ~= block_t.nil else 0;

				ascendant(Bc,Bp) := true if (Bc = Bp | (Bc ~= block_t.nil & Bp = block_t.nil)) else false;
			}
		}
		invariant forall Bc:block_t. forall Bp:block_t. Bc.parent = block_t.hash(Bp) -> Bp.round < Bc.round

		invariant forall B:block_t. block_t.nil.round <= B.round

        invariant forall B1,B2:block_t. (ascendant(B1,B2) & ascendant(B2,B1)) <-> B1 = B2

		invariant forall B1,B2,B3:block_t. (ascendant(B1,B2) & ascendant(B2,B3)) -> ascendant(B1,B3)

		invariant forall B1,B2,B3:block_t. (ascendant(B1,B2) & ascendant(B1,B3)) -> (ascendant(B2,B3) | ascendant(B3,B2))

		relation block_parent(Bc:block_t, Bp:block_t)

		definition block_parent(Bc:block_t, Bp:block_t) = (ascendant(Bc,Bp) & Bc ~= Bp & (forall B:block_t. (ascendant(Bc,B) & Bc ~= B) -> ascendant(Bp,B)))

		invariant forall Bc:block_t. forall Bp:block_t. (block_parent(Bc,Bp) <-> Bc.parent=block_t.hash(Bp))

		#invariant forall Bc:block_t. forall Bp:block_t. (Bc.parent = block_t.hash(Bp)) -> block_parent(Bc,Bp)


	} with round_t,block_t,gv,quorum_propogation,processor,ldc_properties6a,ldc_propertiesm1

	isolate gdc_chain_lemma1 = {
		relation qov_after_gdc(R:round_t,Bgdc:block_t)

		definition qov_after_gdc(R:round_t, Bgdc:block_t) = forall B:block_t. (B.round <= R & gdc_properties.gdc(Bgdc) & Bgdc.round < B.round & quorum_propogation.block_has_qov(B) & Bgdc ~= block_t.nil) -> (gdc_chain_lemma.ascendant(B,Bgdc))

		property forall Bgdc:block_t. forall R1,R2:round_t. (R1 <= R2 & qov_after_gdc(R2,Bgdc)) -> qov_after_gdc(R1,Bgdc)
	} with round_t,block_t,ldc_properties6c,ldc_propertiesm1,gv,processor,quorum_propogation

	isolate gdc_chain_lemma2 = {
		invariant forall B:block_t. forall Bp:block_t. (quorum_propogation.block_has_qov(B) & B.parent = block_t.hash(Bp)) -> gv.quorum_of_votes(B,Bp)
	} with round_t,block_t,ldc_properties6c,ldc_propertiesm1,gv,processor,quorum_propogation

	isolate gdc_chain_lemma2a = {

		invariant forall Bc:block_t. forall Bp:block_t. forall Bgdc:block_t. (quorum_propogation.block_has_qov(Bc) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & gdc_properties.gdc(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & Bp ~= Bgdc )-> (Bgdc.round < Bp.round)

	} with round_t,block_t,ldc_properties6c,ldc_propertiesm1,gv,processor,gdc_chain_lemma2

	isolate gdc_chain_lemma3 = {
		invariant forall Bc:block_t. forall Bp:block_t. forall Bgdc:block_t. (quorum_propogation.block_has_qov(Bc) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & gdc_properties.gdc(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & Bp ~= Bgdc )-> (quorum_propogation.block_has_qov(Bp))

	} with round_t,block_t,ldc_properties6c,ldc_propertiesm1,gv,processor,quorum_propogation,gdc_chain_lemma1

	isolate gdc_chain_lemma4 = {

		invariant forall Bc:block_t. forall Bp:block_t. forall Bgdc:block_t. (quorum_propogation.block_has_qov(Bc) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & gdc_properties.gdc(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & Bp ~= Bgdc )-> (quorum_propogation.block_has_qov(Bp) & Bgdc.round < Bp.round & gdc_properties.gdc(Bgdc))

		invariant forall Bp:block_t. forall Bgdc:block_t. (quorum_propogation.block_has_qov(Bp) & Bgdc.round < Bp.round & gdc_properties.gdc(Bgdc) & Bgdc ~= block_t.nil & gdc_chain_lemma1.qov_after_gdc(Bp.round,Bgdc)) -> (gdc_chain_lemma.ascendant(Bp,Bgdc))

		invariant forall Bc:block_t. forall Bp:block_t. forall Bgdc:block_t. (quorum_propogation.block_has_qov(Bc) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & gdc_properties.gdc(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & Bp ~= Bgdc & gdc_chain_lemma1.qov_after_gdc(Bp.round,Bgdc)) -> (gdc_chain_lemma.ascendant(Bp,Bgdc))

	} with round_t,block_t,gv,processor,quorum_propogation,gdc_chain_lemma1,gdc_chain_lemma2a

	isolate gdc_chain_lemma5 = {

		invariant forall Bc:block_t. forall Bp:block_t. forall Bgdc:block_t. (Bc.parent=block_t.hash(Bp) & gdc_chain_lemma.ascendant(Bp,Bgdc)) -> gdc_chain_lemma.ascendant(Bc,Bgdc)

		invariant forall Bc:block_t. forall Bp:block_t. forall Bgdc:block_t. (quorum_propogation.block_has_qov(Bc) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & gdc_properties.gdc(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & Bp ~= Bgdc & gdc_chain_lemma1.qov_after_gdc(Bp.round,Bgdc)) -> (gdc_chain_lemma.ascendant(Bc,Bgdc))

		invariant forall Bc:block_t. forall Bp:block_t. forall Bgdc:block_t. (quorum_propogation.block_has_qov(Bc) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & gdc_properties.gdc(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & Bp = Bgdc & gdc_chain_lemma1.qov_after_gdc(Bp.round,Bgdc)) -> (gdc_chain_lemma.ascendant(Bc,Bgdc))

		invariant forall Bc:block_t. forall Bp:block_t. forall Bgdc:block_t. (quorum_propogation.block_has_qov(Bc) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & gdc_properties.gdc(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & gdc_chain_lemma1.qov_after_gdc(Bp.round,Bgdc)) -> (gdc_chain_lemma.ascendant(Bc,Bgdc))

		invariant forall Bc:block_t. forall Bgdc:block_t. (quorum_propogation.block_has_qov(Bc) & Bc.parent ~= block_t.hash(block_t.nil) & gdc_properties.gdc(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & (forall R:round_t. R < Bc.round -> gdc_chain_lemma1.qov_after_gdc(R,Bgdc))) -> (gdc_chain_lemma.ascendant(Bc,Bgdc))

		invariant forall Bc:block_t. forall Bgdc:block_t. (quorum_propogation.block_has_qov(Bc) & gdc_properties.gdc(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & (forall R:round_t. R < Bc.round -> gdc_chain_lemma1.qov_after_gdc(R,Bgdc))) -> (gdc_chain_lemma.ascendant(Bc,Bgdc))
	} with round_t,block_t,gv,processor,quorum_propogation,gdc_chain_lemma4,gdc_chain_lemma,gdc_properties14

	isolate gdc_chain_lemma6 = {

		invariant forall Bc:block_t. forall Bgdc:block_t. forall R:round_t. (quorum_propogation.block_has_qov(Bc) & gdc_properties.gdc(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & round_t.succ(R,Bc.round) & gdc_chain_lemma1.qov_after_gdc(R,Bgdc)) -> (gdc_chain_lemma.ascendant(Bc,Bgdc))

		invariant forall Bgdc:block_t. forall R1,R2:round_t. (round_t.succ(R1,R2) & gdc_chain_lemma1.qov_after_gdc(R1,Bgdc)) -> gdc_chain_lemma1.qov_after_gdc(R2,Bgdc)

		invariant gdc_chain_lemma1.qov_after_gdc(0,Bgdc)
	} with round_t,block_t,gv,processor,quorum_propogation,gdc_chain_lemma5,gdc_chain_lemma,gdc_properties14,gdc_chain_lemma1

	isolate gdc_chain_lemma7 = {

		axiom [round_induction] {
			relation rel1(R:round_t, Bgdc:block_t)
		 	#---------------------------------------------------
			property (forall Bgdc:block_t. rel1(0,Bgdc)) & (forall Bgdc:block_t. forall R1,R2:round_t. (round_t.succ(R1,R2) & rel1(R1,Bgdc)) -> rel1(R2,Bgdc)) -> forall R:round_t. forall Bgdc:block_t. rel1(R,Bgdc)
		}

		property (forall Bgdc:block_t. gdc_chain_lemma1.qov_after_gdc(0,Bgdc)) & (forall Bgdc:block_t. forall R1,R2:round_t. (round_t.succ(R1,R2) & gdc_chain_lemma1.qov_after_gdc(R1,Bgdc)) -> gdc_chain_lemma1.qov_after_gdc(R2,Bgdc)) -> forall R:round_t. forall Bgdc:block_t. gdc_chain_lemma1.qov_after_gdc(R,Bgdc)
		proof {
			apply round_induction
		}

		invariant forall R:round_t. gdc_chain_lemma1.qov_after_gdc(R,Bgdc)

		property forall Bgdc:block_t. forall B:block_t. (gdc_properties.gdc(Bgdc) & Bgdc.round < B.round & quorum_propogation.block_has_qov(B) & Bgdc ~= block_t.nil & gdc_chain_lemma1.qov_after_gdc(B.round,Bgdc)) -> gdc_chain_lemma.ascendant(B,Bgdc)

		invariant forall Bgdc:block_t. forall B:block_t. gdc_chain_lemma1.qov_after_gdc(B.round,Bgdc)

		invariant forall Bgdc:block_t. forall B:block_t. (gdc_properties.gdc(Bgdc) & Bgdc.round < B.round & quorum_propogation.block_has_qov(B) & Bgdc ~= block_t.nil) -> gdc_chain_lemma.ascendant(B,Bgdc)
	} with round_t,block_t,gv,processor,gdc_chain_lemma6,gdc_chain_lemma,gdc_chain_lemma1

	isolate gdc_chain_lemma8 = {
		invariant forall N:node_t. forall H:height_t. (is_good(N) & height_t.succ(H, processor.validator(N).chain_size)) -> ldc_propertiesm1.gdc_x(processor.validator(N).blockchain(H))
	} with height_t,block_t,processor,gv,ldc_properties2

	isolate gdc_chain_lemma9 = {
		invariant forall N:node_t. forall H:height_t. (is_good(N) & height_t.succ(H, processor.validator(N).chain_size)) -> gdc_properties.gdc(processor.validator(N).blockchain(H))

		invariant forall N:node_t. forall H:height_t. forall Hp:height_t.(is_good(N) & height_t.succ(H, processor.validator(N).chain_size) & height_t.succ(Hp,H)) -> (gdc_properties.gdc(processor.validator(N).blockchain(H)) & processor.validator(N).blockchain(H).parent = block_t.hash(processor.validator(N).blockchain(Hp)) &processor.validator(N).blockchain(Hp) ~= block_t.nil)

		invariant forall N:node_t. forall H:height_t. forall Hp:height_t.(is_good(N) & height_t.succ(H, processor.validator(N).chain_size) & height_t.succ(Hp,H)) -> quorum_propogation.block_has_qov(processor.validator(N).blockchain(H))

		invariant forall N1:node_t. forall N2:node_t. forall H1,H2,Hp1,Hp2:height_t. (is_good(N1) & is_good(N2) & height_t.succ(H1, processor.validator(N1).chain_size) & height_t.succ(H2, processor.validator(N2).chain_size) & height_t.succ(Hp1,H1) & height_t.succ(Hp2,H2)) -> (gdc_properties.gdc(processor.validator(N1).blockchain(H1)) & gdc_properties.gdc(processor.validator(N2).blockchain(H2)) & quorum_propogation.block_has_qov(processor.validator(N1).blockchain(H1)) & quorum_propogation.block_has_qov(processor.validator(N2).blockchain(H2)))

		invariant forall N1:node_t. forall N2:node_t. forall H1,H2,Hp1,Hp2:height_t. (is_good(N1) & is_good(N2) & height_t.succ(H1, processor.validator(N1).chain_size) & height_t.succ(H2, processor.validator(N2).chain_size) & height_t.succ(Hp1,H1) & height_t.succ(Hp2,H2) & processor.validator(N1).blockchain(H1).round < processor.validator(N2).blockchain(H2).round) -> (gdc_properties.gdc(processor.validator(N1).blockchain(H1)) & processor.validator(N1).blockchain(H1) ~= block_t.nil & quorum_propogation.block_has_qov(processor.validator(N2).blockchain(H2))& processor.validator(N1).blockchain(H1).round < processor.validator(N2).blockchain(H2).round)

		invariant forall N1:node_t. forall N2:node_t. forall H1:height_t. forall H2:height_t. forall Hp1:height_t. forall Hp2:height_t. (gdc_properties.gdc(processor.validator(N1).blockchain(H1)) & processor.validator(N1).blockchain(H1) ~= block_t.nil & quorum_propogation.block_has_qov(processor.validator(N2).blockchain(H2))& processor.validator(N1).blockchain(H1).round < processor.validator(N2).blockchain(H2).round) -> gdc_chain_lemma.ascendant(processor.validator(N2).blockchain(H2),processor.validator(N1).blockchain(H1))

		invariant forall N1:node_t. forall N2:node_t. forall H1,H2,Hp1,Hp2:height_t. (is_good(N1) & is_good(N2) & height_t.succ(H1, processor.validator(N1).chain_size) & height_t.succ(H2, processor.validator(N2).chain_size) & height_t.succ(Hp1,H1) & height_t.succ(Hp2,H2) & processor.validator(N2).blockchain(H2).round < processor.validator(N1).blockchain(H1).round) -> (gdc_properties.gdc(processor.validator(N2).blockchain(H2)) & processor.validator(N2).blockchain(H2) ~= block_t.nil & quorum_propogation.block_has_qov(processor.validator(N1).blockchain(H1))& processor.validator(N2).blockchain(H2).round < processor.validator(N1).blockchain(H1).round)

		invariant forall N1:node_t. forall N2:node_t. forall H1:height_t. forall H2:height_t. forall Hp1:height_t. forall Hp2:height_t. (gdc_properties.gdc(processor.validator(N2).blockchain(H2)) & processor.validator(N2).blockchain(H2) ~= block_t.nil & quorum_propogation.block_has_qov(processor.validator(N1).blockchain(H1))& processor.validator(N2).blockchain(H2).round < processor.validator(N1).blockchain(H1).round) -> gdc_chain_lemma.ascendant(processor.validator(N1).blockchain(H1),processor.validator(N2).blockchain(H2))
	} with height_t,block_t,processor,gv,gdc_chain_lemma8,gdc_properties,ldc_propertiesm1,gdc_properties16,gdc_chain_lemma,gdc_chain_lemma7

	isolate gdc_chain_lemma10 = {
		invariant forall N1:node_t. forall N2:node_t. forall H1,H2,Hp1,Hp2:height_t. (is_good(N1) & is_good(N2) & height_t.succ(H1, processor.validator(N1).chain_size) & height_t.succ(H2, processor.validator(N2).chain_size) & height_t.succ(Hp1,H1) & height_t.succ(Hp2,H2) & processor.validator(N1).blockchain(H1).round = processor.validator(N2).blockchain(H2).round) -> (processor.validator(N1).blockchain(H1) = processor.validator(N2).blockchain(H2))

		invariant forall N1:node_t. forall N2:node_t. forall H1,H2,Hp1,Hp2:height_t. (is_good(N1) & is_good(N2) & height_t.succ(H1, processor.validator(N1).chain_size) & height_t.succ(H2, processor.validator(N2).chain_size) & height_t.succ(Hp1,H1) & height_t.succ(Hp2,H2)) -> (gdc_chain_lemma.ascendant(processor.validator(N1).blockchain(H1),processor.validator(N2).blockchain(H2)) | gdc_chain_lemma.ascendant(processor.validator(N2).blockchain(H2),processor.validator(N1).blockchain(H1)))
	} with gv, height_t, processor, ldc_properties, round_t, block_t,gdc_chain_lemma9,gdc_chain_lemma

	# isolate gdc_chain_lemma2 = {
	# 	invariant forall Bc:block_t. forall Bp:block_t. forall Bgdc:block_t. (is_good(N) & quorum_propogation.block_has_qov(Bc) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & gdc_properties.gdc(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & Bp ~= Bgdc & gdc_chain_lemma1.qov_after_gdc(Bp.round,Bgdc)) -> (Bgdc.round < Bp.round & quorum_propogation.block_has_qov(Bp) & (gdc_chain_lemma.ascendant(Bp,Bgdc) | Bp.parent = block_t.hash(block_t.nil)))

	# 	invariant forall Bc:block_t. forall Bp:block_t. forall Bgdc:block_t. (is_good(N) & quorum_propogation.block_has_qov(Bc) & Bc.parent=block_t.hash(Bp) & Bp ~= block_t.nil & gdc_properties.gdc(Bgdc) & Bgdc.round < Bc.round & Bgdc ~= block_t.nil & Bp = Bgdc & gdc_chain_lemma1.qov_after_gdc(Bp.round,Bgdc)) -> (quorum_propogation.block_has_qov(Bp) & (gdc_chain_lemma.ascendant(Bp,Bgdc)))
	# } with round_t,block_t,quorum_propogation,ldc_properties6a,ldc_propertiesm1,gdc_chain_lemma,gv,processor,gdc_chain_lemma1


	isolate global_properties = {
		invariant forall N:node_t. forall H:height_t. (is_good(N) & processor.validator(N).blockchain(H) ~= block_t.nil) -> exists Q:cert_t. (processor.validator(N).qc_processed(Q) & Q.block = processor.validator(N).blockchain(H))

		invariant [round_safety_statement] forall N1:node_t. forall N2:node_t. forall H1:height_t. forall H2:height_t. (is_good(N1)  & is_good(N2) & processor.validator(N1).blockchain(H1) ~= block_t.nil & processor.validator(N2).blockchain(H2) ~= block_t.nil & processor.validator(N1).blockchain(H1).round = processor.validator(N2).blockchain(H2).round ) -> processor.validator(N1).blockchain(H1) = processor.validator(N2).blockchain(H2)

		invariant forall N:node_t. forall B:block_t. (is_good(N) & gv.node_has_voted(N,B)) -> B.parent = block_t.hash(block_t.nil) | exists Bp:block_t. (B.parent = block_t.hash(Bp) & gv.node_has_locked(N,Bp))

		########### starting experimentation from here
		#invariant forall N1:node_t. forall N2:node_t. (is_good(N1) & is_good(N2) & processor.validator(N1).blockchain(0) ~= block_t.nil & processor.validator(N2).blockchain(0) ~= block_t.nil) -> processor.validator(N1).blockchain(0) = processor.validator(N2).blockchain(0)

		#invariant forall N1:node_t. forall N2:node_t. forall H:height_t. (is_good(N1) & is_good(N2) & processor.validator(N1).blockchain(H) ~= block_t.nil & processor.validator(N2).blockchain(H) ~= block_t.nil) -> processor.validator(N1).blockchain(H) = processor.validator(N2).blockchain(H)
	} with gv, height_t, processor, ldc_properties, round_t, block_t
} with gv, round_t, height_t, block_t, cert_t, shim, net.spec, processor, gdc_properties, gdc_properties2
