#lang ivy1.8

include types
include network

object processor(id:process_index_t) = {
    # The highest round for which this process has accepted a Fallback Recovery Proposal by broadcasting a PF message.
    individual a_f: round_t

    # The highest round for which this process has accepted a Normal Proposal by broadcasting a PN message.
    individual a_n: round_t

    # The highest round for which this process has accepted an Optimistic Proposal by broadcasting a PO message.
    individual a_o: round_t

    # The block most recently appended to Bv, the block chain of this validator
    individual b_h: block_t

    # A representation of all blocks that are committed by this process
    relation b_v(B:block_t)

    # The block for which this process last broadcasted a PO message. In the specs, what is actually stored is the digest d_o of b_o, but we store b_o here to reduce complexity
    individual b_o: block_t

    # A set containing the identifiers of all rounds that this process considers to have expired due to having sent the corresponding Timeout message.
    relation expired_rounds(R:round_t)

    # The currently locked QC
    individual qc_l: qc_t

    # the set of qc's that have been processed
    relation processed_qc(B:block_t)

    # The current round
    individual r_c: round_t

    # The highest round for which this process has broadcasted a Timeout message
    individual t_l: round_t

    # The timer used to trigger Timeout events. In the actual implementation, this will be an actual timer; here we use a boolean, which will be true whenever the timer expires beyond the set limit
    individual t_r: bool

    relation received_proposal_n(B:block_t, Src:process_index_t)
    relation received_proposal_f(B:block_t, Src:process_index_t)
    relation received_proposal_o(B:block_t, Src:process_index_t)
    relation received_prepare_n(B:block_t, Src:process_index_t)
    relation received_prepare_f(B:block_t, Src:process_index_t)
    relation received_prepare_o(B:block_t, Src:process_index_t)
    relation received_qc(QC:qc_t)
    relation received_timeout(R:round_t, QC:qc_t, Src:process_index_t)
    relation received_tc(TC:tc_t)
    relation received_tc_fplusone(TC:tc_fplusone_t)

    relation ldc_pair(Bp:block_t, Bc:block_t)
    definition ldc_pair(Bp, Bc) = Bc ~= block_t.genesis & block_t.parent(Bc,Bp) & block_t_conv.successive_blocks(Bp,Bc) & processed_qc(Bp) & processed_qc(Bc)

    relation ldc(B:block_t)
    definition ldc(B) = exists Bc:block_t. ldc_pair(B,Bc)

    relation eligible_to_commit(Bp:block_t)
    definition eligible_to_commit(Bp) = ldc(Bp) & block_t.ancestor(Bp,b_h) & (forall Ba:block_t. block_t.ancestor(Bp,Ba) -> (processed_qc(Ba) | Ba = b_h | block_t.ancestor(b_h,Ba)))

    relation commit_candidate(Bp:block_t)
    definition commit_candidate(Bp) = eligible_to_commit(Bp) & (forall B:block_t. forall Rp,R:round_t. eligible_to_commit(B) & block_t.round(B,R) & block_t.round(Bp,Rp) -> R <= Rp)

    after init {
        a_f := 0;
        a_n := 0;
        a_o := 0;

        b_v(B) := B = block_t.genesis;

        b_o := block_t.unused;

        expired_rounds(R) := false;
        qc_l := qc_t.genesis;
        processed_qc(B) := B = block_t.genesis;

        r_c := *;
        assume round_t.succ(0, r_c);

        t_l := 0;

        t_r := false;

        received_proposal_n(B, Src) := B = block_t.genesis & Src = leader(0);
        received_proposal_f(B, Src) := false;
        received_proposal_o(B, Src) := false;
        received_prepare_n(B, Src) := B = block_t.genesis;
        received_prepare_f(B, Src) := B = block_t.genesis;
        received_prepare_o(B, Src) := B = block_t.genesis;
        received_qc(QC) := QC = qc_t.genesis;
        received_timeout(R, QC, Src) := false;
        received_tc(TC) := false;
        received_tc_fplusone(TC) := false;
    }

    implement shim.proposal_n_handler.handle(m:msg) {
            received_proposal_n(m.block, m.src) := true;
    }

    implement shim.proposal_f_handler.handle(m:msg) {
            received_proposal_f(m.block, m.src) := true;
            received_tc(m.tc) := true;
            #received_qc(m.qc) := true;
    }

    implement shim.proposal_o_handler.handle(m:msg) {
            received_proposal_o(m.block, m.src) := true;
    }

    implement shim.prepare_n_handler.handle(m:msg) {
            received_prepare_n(m.block, m.src) := true;
    }

    implement shim.prepare_f_handler.handle(m:msg) {
            received_prepare_f(m.block, m.src) := true;
    }

    implement shim.prepare_o_handler.handle(m:msg) {
            received_prepare_o(m.block, m.src) := true;
    }

    implement shim.qc_handler.handle(m:msg) {
            received_qc(m.qc) := true;
    }

    implement shim.timeout_handler.handle(m:msg) {
            received_timeout(m.round, m.qc, m.src) := true;
            received_qc(m.qc) := true;
    }

    implement shim.tc_handler.handle(m:msg) {
            received_tc(m.tc) := true;
            #received_qc(QC) := received_qc(QC) | qc_in_tc(m.tc,QC);
    }

    implement shim.tc_fplusone_handler.handle(m:msg) {
        received_tc_fplusone(m.tc_po) := true;
        #received_qc(QC) := received_qc(QC) | qc_in_tc_fp1(m.tc,QC);
    }

    # action proposal_f_get_tc(p:proposal_f_t) returns (tc:tc_t) = {
    #     if some p_tc:tc_t. proposal_f_t.tc(p, p_tc) {
    #         tc := p_tc;
    #     }
    # }

    # action timeout_get_qc(t:timeout_t) returns (qc:qc_t) = {
    #     if some t_qc:qc_t. timeout_t.qc(t, t_qc) {
    #         qc := t_qc;
    #     }
    # }

    # action qc_get_block(qc:qc_t) returns (b:block_t) = {
    #     if some qc_b:block_t. qc_t.block(qc, qc_b) {
    #         b := qc_b;
    #     }
    # }

    # action broadcast_tc(t:tc_t) = {
    #     var m : msg;
    #     m.kind := msg_kind.tc;
    #     m.tc := t;
    #     m.src := id;

    #     call shim.broadcast(id, m);
    # }


    action qc_processing(qc:qc_t) = {
        require received_qc(qc);

        var b_qc : block_t;
        if some b:block_t. qc_t.block(qc,b) {
            b_qc := b;
        }
        var r : round_t;
        if some r_b:round_t. block_t.round(b_qc,r_b) {
            r := round_t.next(r_b);
        }
        processed_qc(b_qc) := true;

        if (forall R, Rs1:round_t. block_t.round(b_qc,R) & round_t.succ(Rs1,r_c) -> Rs1 < R) {
            ### proposeNormal ###

            if leader(r) = id {
                    var b := block_t.block(r,b_qc);
                    var m : msg;
                    m.kind := msg_kind.proposal_n;
                    m.block := b;
                    m.src := id;
                    call shim.broadcast(id, m);
                }
        }

        if forall B_l:block_t. forall R_l,R_qc:round_t. qc_t.block(qc_l,B_l) & block_t.round(B_l,R_l) & block_t.round(b_qc,R_qc) -> R_l < R_qc {
            qc_l := qc;
        }

        ######### tryCommit ##########
        if some bp:block_t. commit_candidate(bp) {
            b_v(B) := b_v(B) | B = bp | (block_t.ancestor(bp,B) & block_t.ancestor(B,b_h));
            b_h := bp;
        }

        ######### multicastQC #########
        var m : msg;
        m.kind := msg_kind.qc;
        m.qc := qc;
        m.src := id;
        call shim.broadcast(id, m);

        ######### advanceToRound #############
        if r_c < r {
            r_c := r;
            t_r := false;
        }
    }

    action optimistic_proposal_processing(b_pr:block_t) = {
        require received_proposal_o(b_pr,leader(r_c));

        require block_t.round(b_pr,r_c);

        ###### proposeOptimistic ############
        var rs := round_t.next(r_c);
        if leader(rs) = id {
            var b := block_t.block(rs,b_pr);
            var m : msg;
            m.kind := msg_kind.proposal_o;
            m.block := b;
            m.src := id;

            call shim.broadcast(id, m);
        }

        if (a_f < r_c & a_n < r_c & (forall B_l:block_t. forall R_l:round_t. qc_t.block(qc_l,B_l) & block_t.round(B_l,R_l) -> block_t.parent(b_pr,B_l) & round_t.succ(R_l, r_c)) & (forall R_s:round_t. round_t.succ(R_s,r_c) -> t_l < R_s))
        {
            var m : msg;
            m.kind := msg_kind.prepare_o;
            m.block := b_pr;
            m.src := id;

            call shim.broadcast(id, m);

            a_o := r_c;
            b_o := b_pr;
        }
    }

    action normal_proposal_processing(b_pr:block_t, qc:qc_t) = {

        require received_proposal_n(b_pr, leader(r_c));
        
        call qc_processing(qc);

        require block_t.round(b_pr,r_c);

        ###### proposeOptimistic ############
        var rs := round_t.next(r_c);
        if leader(rs) = id {
            var b := block_t.block(rs,b_pr);
            var m : msg;
            m.kind := msg_kind.proposal_o;
            m.block := b;
            m.src := id;

            call shim.broadcast(id, m);
        }

        if (a_f < r_c & t_l < r_c & (a_o < r_c  | b_o = b_pr) & (forall B:block_t. forall R:round_t. qc_t.block(qc,B) & block_t.round(B,R) -> block_t.parent(b_pr,B) & round_t.succ(R, r_c))) {
            var m : msg;
            m.kind := msg_kind.prepare_n;
            m.block := b_pr;
            m.src := id;

            call shim.broadcast(id, m);

            a_n := r_c;
        }
    }

    action timer_expire = {
        require ~ round_t.succ(0,r_c);

        if (~ expired_rounds(r_c) & (forall B_l:block_t. forall R_l:round_t. qc_t.block(qc_l,B_l) & block_t.round(B_l,R_l) -> R_l < r_c)) {
            var m : msg;
            m.kind := msg_kind.timeout;
            m.round := r_c;
            m.qc := qc_l;
            m.src := id;

            call shim.broadcast(id, m);
        }
    }

    action timeout_sync(tc:tc_fplusone_t) = {
        require received_tc_fplusone(tc);
        require tc_fplusone_t.round(tc,R) -> round_t.succ(0,R);

        #ensure all QCs contained in tc are processed. In implementation, this is done by calling the subroutine for processing qc. Here, we constrain the environment to call qc_processing on the qcs before calling timeout_sync
        # require forall T:timeout_t. forall QC:qc_t. forall B:block_t. tc_fplusone_t.timeout(tc,T) & timeout_t.qc(T,QC) & qc_t.block(QC,B) -> observed_qc(B);
        if some tc_r:round_t. tc_fplusone_t.round(tc, tc_r) {
            if (~ expired_rounds(tc_r) & (forall B_l:block_t. forall R_l:round_t. qc_t.block(qc_l,B_l) & block_t.round(B_l,R_l) -> R_l < tc_r)) {
                var m : msg;
                m.kind := msg_kind.timeout;
                m.round := tc_r;
                m.qc := qc_l;
                m.src := id;

                call shim.broadcast(id, m);
            }
        }
    }

    action tc_processing(tc:tc_t) = {
        var tc_round : round_t;
        if some r:round_t. tc_t.round(tc, r) {
            tc_round := r;
        }
        var tc_round_s := round_t.next(tc_round);
        if (r_c < tc_round_s) {
            ##### proposeFallback #########
            if (id = leader(tc_round_s)) {
                if some qcp:qc_t. tc_t.maxQC(tc,qcp) {
                    if some b_qcp:block_t. qc_t.block(qcp,b_qcp) {
                        var b := block_t.block(tc_round_s,b_qcp);
                        var m : msg;
                        m.kind := msg_kind.proposal_f;
                        m.block := b;
                        m.src := id;

                        call shim.broadcast(id, m);
                    }
                }
            }
        }

        ####### forward ############
        var m:msg;
        m.kind := msg_kind.tc;
        m.src := id;
        m.tc := tc;
        shim.send(id,leader(tc_round_s),m);

        ########### timeout ############3
        if (~ expired_rounds(tc_round) & (forall B_l:block_t. forall R_l:round_t. qc_t.block(qc_l,B_l) & block_t.round(B_l,R_l) -> R_l < tc_round)) {
            var m : msg;
            m.kind := msg_kind.timeout;
            m.round := tc_round;
            m.qc := qc_l;
            m.src := id;

            call shim.broadcast(id, m);
        }

        ######### advanceToRound #############
        if r_c < tc_round_s {
            r_c := tc_round_s;
            t_r := false;
        }
    }

    action fallback_proposal_processing(b_pr:block_t, tc:tc_t) = {

        require received_proposal_f(b_pr, leader(r_c));
        require block_t.round(b_pr,r_c);

        var tc_r: round_t;
        if some r:round_t. tc_t.round(tc,r) {
            tc_r := r;
        }

        var qcp: qc_t;
        if some qc:qc_t. tc_t.maxQC(tc,qc) {
            qcp := qc;
        }
        var b_qcp:block_t;
        if some b:block_t. qc_t.block(qcp,b) {
            b_qcp := b;
        }
        var r_qcp:round_t;
        if some r:round_t. block_t.round(b_qcp,r) {
            r_qcp := r;
        }

        if (a_n < r_c & t_l < r_c & round_t.succ(tc_r,r_c) & r_qcp < tc_r & block_t.parent(b_pr,b_qcp)) {
            var m : msg;
            m.kind := msg_kind.prepare_f;
            m.block := b_pr;
            m.src := id;

            call shim.broadcast(id, m);
            a_f := r_c;
        }
    }

    # action byzantine_send_proposal_f = {
    #     var m : msg;
    #     var dst : process_index_t;
    #     assume global_view.proposal_f_valid(m.prop_f);

    #     if ~is_good(m.src) & m.kind = msg_kind.proposal_f {
    #         call shim.send(id, dst, m);
    #     }

    # }

    # action byzantine_send_proposal_n = {
    #     var m : msg;
    #     var dst : process_index_t;
    #     assume global_view.proposal_n_valid(m.prop_n);

    #     if ~is_good(m.src) & m.kind = msg_kind.proposal_n {
    #         call shim.send(id, dst, m);
    #     }

    # }

    # action byzantine_send_prepare_n = {
    #     var m : msg;
    #     var dst : process_index_t;
    #     assume prepare_t.cstd(m.prep);
    #     assume proposal_n_t.cstd(m.prop_n);

    #     if ~is_good(m.src) & m.kind = msg_kind.prepare & prepare_t.get_block(m.prep) = proposal_n_t.get_block(m.prop_n) & global_view.process_received_normal_proposal(m.src,m.prop_n)
    #     {
    #         call shim.send(id, dst, m);
    #         call global_view.vote_normal(m.src,m.prop_n);
    #     }

    # }

    # action byzantine_send_prepare_f = {
    #     var m : msg;
    #     var dst : process_index_t;
    #     assume prepare_t.cstd(m.prep);
    #     assume proposal_f_t.was_constructed(m.prop_f);

    #     if ~is_good(m.src) & m.kind = msg_kind.prepare & prepare_t.get_block(m.prep) = proposal_f_t.get_block(m.prop_f) & global_view_instance.proposal_f_valid(m.prop_f)
    #     {
    #         var q:quorum_t;
    #         assume proposal_f_t.tc(m.prop_f,TC) -> tc_t.quorum(TC,q);
    #         call shim.send(id, dst, m);
    #         call global_view.vote_fallback(m.src,m.prop_f,q);
    #     }

    # }

    # action byzantine_send_qc = {
    #     var m : msg;
    #     var dst : process_index_t;
    #     assume global_view.qc_valid(m.qc);

    #     if ~is_good(m.src) & m.kind = msg_kind.qc {
    #         call shim.send(id, dst, m);
    #     }

    # }

    # action byzantine_send_timeout = {
    #     var m : msg;
    #     var dst : process_index_t;
    #     assume global_view.timeout_valid(m.t);

    #     if ~is_good(m.src) & m.kind = msg_kind.timeout {
    #         call shim.send(id, dst, m);
    #         var tc_fp1:tc_fplusone_t;
    #         var tc:tc_t;
    #         var kind:to_kind;
    #         call global_view.timeout(m.src,timeout_t.get_round(m.t),timeout_get_qc(m.t), tc_fp1, tc, kind);
    #     }

    # }

    # action byzantine_send_tc = {
    #     var m : msg;
    #     var dst : process_index_t;
    #     assume global_view.tc_valid(m.tc);

    #     if ~is_good(m.src) & m.kind = msg_kind.tc {
    #         call shim.send(id, dst, m);
    #     }
    # }

    # export byzantine_send_prepare_f
    # export byzantine_send_prepare_n
    # export byzantine_send_proposal_f
    # export byzantine_send_proposal_n
    # export byzantine_send_qc
    # export byzantine_send_tc
    # export byzantine_send_timeout
    export fallback_proposal_processing
    export normal_proposal_processing
    export optimistic_proposal_processing
    export qc_processing
    export tc_processing
    export timeout_sync
    export timer_expire

    
} # object local_view