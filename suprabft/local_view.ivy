#lang ivy1.8

include types
include network

module supraBFT(global_view) = {
object local_view(id:process_index_t) = {
    individual last_committed : block_t
    individual last_prop_n : block_t

    individual locked : qc_t
    individual r_c : round_t
    individual r_c_m1 : round_t
    individual timer : bool
    # simplified, no need to store QCs here for our purposes
    relation commitQ(B:block_t)
    individual r_vf : round_t
    individual r_vn : round_t
    individual r_pf : round_t

    relation received_proposal_n(P:proposal_n_t, Src:process_index_t)
    relation received_proposal_f(P:proposal_f_t, Src:process_index_t)
    relation received_prepare(P:prepare_t, Src:process_index_t)
    relation received_qc(QC:qc_t)
    relation received_timeout(T:timeout_t, Src:process_index_t)
    relation received_tc(TC:tc_t)
    relation received_tc_fplusone(TC:tc_fplusone_t)

    relation observed_qc(B:block_t)
    function qc_for_block(B:block_t) : qc_t

    relation expired_rounds(R:round_t)

    relation qcs_in_tc_processed(TC:tc_t)

    definition qcs_in_tc_processed(TC) = forall T:timeout_t. forall QC:qc_t. forall B:block_t. tc_t.timeout(TC,T) & timeout_t.qc(T,QC) & qc_t.block(QC,B) -> observed_qc(B)

    relation qc_in_tc(TC:tc_t,QC:qc_t)

    definition qc_in_tc(TC,QC) = exists T:timeout_t. tc_t.timeout(TC,T) & timeout_t.qc(T,QC)

    relation ldc_pair(Bp:block_t, Bc:block_t)
    definition ldc_pair(Bp, Bc) = Bc ~= block_t.genesis & block_t.parent(Bc,Bp) & global_view.successive_blocks(Bp,Bc) & observed_qc(Bp) & commitQ(Bc)

    relation ldc(B:block_t)
    definition ldc(B) = exists Bc:block_t. ldc_pair(B,Bc)

    relation eligible_to_commit(Bp:block_t)
    definition eligible_to_commit(Bp) = commitQ(Bp) & ldc(Bp) & block_t.ancestor(Bp,last_committed) & (forall Ba:block_t. block_t.ancestor(Bp,Ba) -> (commitQ(Ba) | Ba = last_committed | block_t.ancestor(last_committed,Ba)))

    relation commit_candidate(Bp:block_t)
    definition commit_candidate(Bp) = eligible_to_commit(Bp) & (forall B:block_t. forall Rp,R:round_t. eligible_to_commit(B) & block_t.round(B,R) & block_t.round(Bp,Rp) -> R <= Rp)

    relation commitQ_empty
    definition commitQ_empty = forall B:block_t. ~ commitQ(B)

    relation commitQUgenesis(B:block_t)
    definition commitQUgenesis(B) = B = block_t.genesis | commitQ(B)

    relation max_commitQ(B:block_t)
    definition max_commitQ(B) = commitQUgenesis(B) & (forall Bq:block_t. commitQUgenesis(Bq) -> block_t_conv.round_lte(Bq,B))

    relation max_observed_qc(B:block_t)
    definition max_observed_qc(B) = observed_qc(B) & (forall Bp:block_t. observed_qc(Bp) -> block_t_conv.round_lte(Bp,B))

    after init {
        last_committed := block_t.genesis;
        last_prop_n := block_t.genesis;

        locked := qc_t.genesis;
        r_c := *;
        assume round_t.succ(0, r_c);
        r_c_m1 := 0;
        timer := false;
        commitQ(B) := false;
        r_vf := 0;
        r_vn := 0;
        r_pf := 0;

        received_proposal_n(P, Src) := P = proposal_n_t.genesis & Src = leader(0);
        received_proposal_f(P, Src) := false;
        received_prepare(P, Src) := P = prepare_t.genesis;
        received_qc(QC) := QC = qc_t.genesis;
        received_timeout(T, Src) := false;
        received_tc(TC) := false;
        received_tc_fplusone(TC) := false;

        observed_qc(B) := B = block_t.genesis;
        qc_for_block(block_t.genesis) := qc_t.genesis;

        expired_rounds(R) := false;
    }

    implement shim.proposal_n_handler.handle(m:msg) {
            received_proposal_n(m.prop_n, m.src) := true;
    }

    implement shim.proposal_f_handler.handle(m:msg) {
            received_proposal_f(m.prop_f, m.src) := true;
            var temp_tc := proposal_f_get_tc(m.prop_f);
            received_tc(temp_tc) := true;
            received_qc(QC) := received_qc(QC) | qc_in_tc(temp_tc,QC);
    }

    implement shim.prepare_handler.handle(m:msg) {
            received_prepare(m.prep, m.src) := true;
    }

    implement shim.qc_handler.handle(m:msg) {
            received_qc(m.qc) := true;
    }

    implement shim.timeout_handler.handle(m:msg) {
            received_timeout(m.t, m.src) := true;
            received_qc(timeout_get_qc(m.t)) := true;
    }

    implement shim.tc_handler.handle(m:msg) {
            received_tc(m.tc) := true;
            received_qc(QC) := received_qc(QC) | qc_in_tc(m.tc,QC);
    }

    implement shim.tc_fplusone_handler.handle(m:msg) {
        received_tc_fplusone(m.tc_po) := true;
    }

    action proposal_f_get_tc(p:proposal_f_t) returns (tc:tc_t) = {
        if some p_tc:tc_t. proposal_f_t.tc(p, p_tc) {
            tc := p_tc;
        }
    }

    action timeout_get_qc(t:timeout_t) returns (qc:qc_t) = {
        if some t_qc:qc_t. timeout_t.qc(t, t_qc) {
            qc := t_qc;
        }
    }

    action qc_get_block(qc:qc_t) returns (b:block_t) = {
        if some qc_b:block_t. qc_t.block(qc, qc_b) {
            b := qc_b;
        }
    }

    action broadcast_proposal_n(p:proposal_n_t) = {
        var m : msg;
        m.kind := msg_kind.proposal_n;
        m.prop_n := p;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_proposal_f(p:proposal_f_t) = {
        var m : msg;
        m.kind := msg_kind.proposal_f;
        m.prop_f := p;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_prepare(p:prepare_t) = {
        var m : msg;
        m.kind := msg_kind.prepare;
        m.prep := p;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_qc(q:qc_t) = {
        var m : msg;
        m.kind := msg_kind.qc;
        m.qc := q;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_timeout(t:timeout_t) = {
        var m : msg;
        m.kind := msg_kind.timeout;
        m.t := t;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_tc(t:tc_t) = {
        var m : msg;
        m.kind := msg_kind.tc;
        m.tc := t;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action cleanup(r:round_t) = {
        expired_rounds(R) := expired_rounds(R) & r < R;
    }

    action proposeNormal(pB:block_t) = {
        if leader(r_c) = id & r_pf < r_c & ~ block_t.parent(last_prop_n,pB) {
            last_prop_n := block_t.block(r_c, pB);
            var p := proposal_n_t.proposal_n(last_prop_n);
            call broadcast_proposal_n(p);
        }
    }

    action advanceToRound(r:round_t, b:block_t, tc:tc_t, qc_observed:bool) = {
        if r > r_c {
            r_c := r;
            global_view.enter_round(id,r,b,tc,qc_observed);
            r_c_m1 := round_t.prev(r_c);
            timer := false;
            call cleanup(round_t.prev(round_t.prev(r)));
        }
        else {
            global_view.enter_round(id,r_c,b,tc,qc_observed);
        }
    }

    action tryLock(qc:qc_t) = {
        var r := qc_get_round(qc);
        if (forall Bl:block_t. forall Rl:round_t. qc_t.block(locked, Bl) & block_t.round(Bl, Rl) -> r > Rl) & ~ expired_rounds(r) & r_c <= round_t.next(r) {
            locked := qc;

            call global_view.lock(id, qc_get_block(qc), qc);
        }
    }

    action tryCommit(b_qc:block_t) = {
        if some bp:block_t. commit_candidate(bp){
            call global_view.commit(id,bp,last_committed);
            last_committed := bp;
            commitQ(B) := commitQ(B) & block_t_conv.round_lt(last_committed,B);
        }
    }

    action qc_processing(qc:qc_t, b_qc:block_t) = {
        require received_qc(qc);
        require qc_t.block(qc,b_qc);

        if ~observed_qc(b_qc) {
            if (forall R:round_t. block_t.round(b_qc,R) -> r_c <= round_t.next(R))
            {
                call proposeNormal(b_qc);
            }
            commitQ(b_qc) := true;
            observed_qc(b_qc) := true;
            call global_view.receive_qc(id,qc_get_block(qc),qc);
            qc_for_block(b_qc) := qc;
            call tryLock(qc);
            call tryCommit(b_qc);
            call broadcast_qc(qc);
            var tc_temp:tc_t;
            advanceToRound(round_t.next(round_t.next(block_t_get_round(b_qc))), b_qc,tc_temp, true);
        }
    }

    action proposal_n_processing(p:proposal_n_t) = {
        require ~timer;

        require received_proposal_n(p, leader(r_c_m1));

        call global_view.receive_normal_proposal(id,p);

        var ok := true;
        ok := ok & forall B:block_t. forall R:round_t. proposal_n_t.block(p, B) & block_t.round(B, R) -> round_t.succ(R, r_c);
        ok := ok & ~timer;
        ok := ok & forall R:round_t. block_t.round(last_prop_n,R) -> R < r_c;
        if ok {
            call proposeNormal(proposal_n_t.get_block(p));
        }
        ok := ok & forall B:block_t. forall R:round_t. proposal_n_t.block(p, B) & block_t.round(B, R) -> ~expired_rounds(R);
        ok := ok & forall B:block_t. forall R:round_t. proposal_n_t.block(p, B) & block_t.round(B, R) -> r_vn < R;
        ok := ok & forall B1,B2:block_t. proposal_n_t.block(p, B1) & block_t.parent(B1, B2) -> qc_t.block(locked, B2) & global_view.successive_blocks(B2,B1);
        if ok {
            call broadcast_prepare(prepare_t.prepare(proposal_n_t.get_block(p)));
            call global_view.vote_normal(id,p);
            r_vn := round_t.prev(r_c);
        }
    }

    action proposeFR(tc:tc_t) = {

        var r = round_t.next(tc_get_round(tc));
        var ok := true;
        ok := ok & leader(r) = id;

        if ok {
            var qcp := tc_getMaxQC(tc);

            #ensure that qcp has been processed already. In implementation, this is done by calling the subroutine for processing qc. Here, we contrain the environment to call qc_processing on qcp before calling proposal_f_processing
            #require qc_t.block(qcp,B) & qcp ~= qc_t.genesis -> observed_qc(B);

            var b := block_t.block(r, qc_get_block(qcp));
            var p := proposal_f_t.proposal_f(b,tc);
            call broadcast_proposal_f(p);
            r_pf := r;
        }
    }

    action timeout(r:round_t, tc_fp1:tc_fplusone_t, tc:tc_t, kind:to_kind) = {
        if( ~expired_rounds(r)) {
            if some b_max_commitQ:block_t. max_commitQ(b_max_commitQ) {
                var qc_max_commitQ := qc_for_block(b_max_commitQ);
                var t := timeout_t.timeout(id, r, qc_max_commitQ);
                call broadcast_timeout(t);
                expired_rounds(r) := true;
                call global_view.timeout(id, r, qc_max_commitQ, tc_fp1, tc, kind);
            }
        }
    }

    action timer_expire = {
        require 0 < round_t.prev(r_c);
        
        timer := true;
        var tc_fp1_temp:tc_fplusone_t;
        var tc_temp:tc_t;
        call timeout(r_c_m1, tc_fp1_temp,tc_temp, to_kind.timer_expire);
    }

    action timeout_sync(tc:tc_fplusone_t) = {
        require received_tc_fplusone(tc);

        #ensure all QCs contained in tc are processed. In implementation, this is done by calling the subroutine for processing qc. Here, we constrain the environment to call qc_processing on the qcs before calling timeout_sync
        require forall T:timeout_t. forall QC:qc_t. forall B:block_t. tc_fplusone_t.timeout(tc,T) & timeout_t.qc(T,QC) & qc_t.block(QC,B) -> observed_qc(B);

        var r := tc_fplusone_get_round(tc);
        var ok := true;
        ok := ok & forall Rlc:round_t. block_t.round(last_committed, Rlc) -> Rlc < r;
        ok := ok & forall Bcq:block_t. forall Rcq:round_t. commitQ(Bcq) & block_t.round(Bcq,Rcq) -> Rcq ~= r;
        if (ok) {
            var tc_temp:tc_t;
            call timeout(r,tc,tc_temp, to_kind.timeout_sync);
        }

        
    }

    action tc_processing(tc:tc_t) = {

        var tc_round := tc_get_round(tc);

        if(r_c_m1 <= tc_round & tc_round > 0) {
            var tc_fp1_temp:tc_fplusone_t;
            call timeout(tc_round, tc_fp1_temp, tc, to_kind.tc_received);
        }
        var b_temp:block_t;
        advanceToRound(round_t.next(round_t.next(tc_round)), b_temp,tc, false);
        call proposeFR(tc,tc_round);
        if round_t.succ(round_t.next(tc_round),r_c)
        {
            #in real implementation, the timer has to be extended by \Delta. Here in IVy, timer is not maintained explicitly, but only maintained implecitly through a Boolean variable, so there is nothing to do
            #timer := false;
        }
        global_view.received_tc(id,tc);
    }

    action proposal_f_processing(p:proposal_f_t) = {
        require ~timer;

        require received_proposal_f(p, leader(r_c_m1));

        require proposal_f_t.tc(p,TC) -> received_tc(TC) & qcs_in_tc_processed(TC);

        call global_view.receive_fallback_proposal(id,p);

        var tcp := proposal_f_get_tc(p);
        var qcp := prop_f_getMaxQC(p);
        var ok := true;
        ok := ok & ~timer;
        ok := ok & forall B:block_t. forall R:round_t. proposal_f_t.block(p, B) & block_t.round(B, R) -> round_t.succ(R, r_c);
        ok := ok & forall TC:tc_t. forall B:block_t. forall R1,R2:round_t. proposal_f_t.tc(p, TC) & tc_t.round(TC, R1) &
                proposal_f_t.block(p, B) & block_t.round(B, R2) -> round_t.succ(R1, R2);
        ok := ok & forall B1,B2:block_t. proposal_f_t.block(p, B1) & block_t.parent(B1, B2) -> qc_t.block(qcp, B2);
        if ok {
            call tc_processing(proposal_f_get_tc(p));
            call proposeNormal(proposal_f_t.get_block(p));
        }
        ok := ok & forall B:block_t. forall Rb:round_t. proposal_f_t.block(p,B) & block_t.round(B,Rb) -> (~expired_rounds(Rb) & Rb > r_vf);
        if ok {
            call broadcast_prepare(prepare_t.prepare(proposal_f_t.get_block(p)));
            call global_view.vote_fallback(id,p,tc_get_quorum(tcp));
            if some bpr:block_t. proposal_f_t.block(p,bpr) {
                if some r:round_t. block_t.round(bpr,r) {
                    r_vf := r;
                }
            }
            #r_vf := block_t_get_round(proposal_f_t.get_block(p));
        }
        
    }

    action tc_getMaxQC(tc:tc_t) returns (qc:qc_t) = {
        assume exists T:timeout_t. global_view.timeout_valid(T) & tc_t.timeout(tc, T) & timeout_t.qc(T, qc);
        assume forall T:timeout_t. forall QC:qc_t. forall B1,B2:block_t. forall R1,R2:round_t. global_view.timeout_valid(T) & tc_t.timeout(tc, T) & timeout_t.qc(T, QC) &
                qc_t.block(QC, B1) & block_t.round(B1, R1) & qc_t.block(qc, B2) & block_t.round(B2, R2) -> R2 >= R1;
    }

    action prop_f_getMaxQC(p:proposal_f_t) returns (qc:qc_t) = {
        var tcp : tc_t;
        var to : timeout_t;

        assume proposal_f_t.tc(p,tcp);
        assume tc_t.timeout(tcp, to);
        assume timeout_t.qc(to,qc);
        assume forall T:timeout_t. forall QCt:qc_t. forall Br,Bt:block_t. forall Rr,Rt:round_t. tc_t.timeout(tcp, T) & timeout_t.qc(T, QCt) &
                qc_t.block(QCt, Bt) & block_t.round(Bt, Rt) & qc_t.block(qc, Br) & block_t.round(Br, Rr) -> Rt <= Rr;
    }

    action tc_get_round(tc:tc_t) returns (r:round_t) = {
        if some tc_r:round_t. tc_t.round(tc, tc_r) {
            r := tc_r;
        }
    }

    action tc_get_quorum(tc:tc_t) returns (q:quorum_t) = {
        if some tc_q:quorum_t. tc_t.quorum(tc,tc_q) {
            q := tc_q;
        }
    }

    action qc_get_round(qc:qc_t) returns (r:round_t) = {
        if some qc_b:block_t. qc_t.block(qc, qc_b) {
            r := block_t_get_round(qc_b);
        }
    }

    action tc_fplusone_get_round(tc:tc_fplusone_t) returns (r:round_t) = {
        if some tc_r:round_t. tc_fplusone_t.round(tc, tc_r) {
            r := tc_r;
        }
    }

    action block_t_get_round(b:block_t) returns (r:round_t) = {
        if some b_r:round_t. block_t.round(b, b_r) {
            r := b_r;
        }
    }

    action byzantine_send_proposal_f = {
        var m : msg;
        var dst : process_index_t;
        assume global_view.proposal_f_valid(m.prop_f);

        if ~is_good(m.src) & m.kind = msg_kind.proposal_f {
            call shim.send(id, dst, m);
        }

    }

    action byzantine_send_proposal_n = {
        var m : msg;
        var dst : process_index_t;
        assume global_view.proposal_n_valid(m.prop_n);

        if ~is_good(m.src) & m.kind = msg_kind.proposal_n {
            call shim.send(id, dst, m);
        }

    }

    action byzantine_send_prepare_n = {
        var m : msg;
        var dst : process_index_t;
        assume prepare_t.cstd(m.prep);
        assume proposal_n_t.cstd(m.prop_n);

        if ~is_good(m.src) & m.kind = msg_kind.prepare & prepare_t.get_block(m.prep) = proposal_n_t.get_block(m.prop_n) & global_view.process_received_normal_proposal(m.src,m.prop_n)
        {
            call shim.send(id, dst, m);
            call global_view.vote_normal(m.src,m.prop_n);
        }

    }

    action byzantine_send_prepare_f = {
        var m : msg;
        var dst : process_index_t;
        assume prepare_t.cstd(m.prep);
        assume proposal_f_t.was_constructed(m.prop_f);

        if ~is_good(m.src) & m.kind = msg_kind.prepare & prepare_t.get_block(m.prep) = proposal_f_t.get_block(m.prop_f) & global_view_instance.proposal_f_valid(m.prop_f)
        {
            var q:quorum_t;
            assume proposal_f_t.tc(m.prop_f,TC) -> tc_t.quorum(TC,q);
            call shim.send(id, dst, m);
            call global_view.vote_fallback(m.src,m.prop_f,q);
        }

    }

    action byzantine_send_qc = {
        var m : msg;
        var dst : process_index_t;
        assume global_view.qc_valid(m.qc);

        if ~is_good(m.src) & m.kind = msg_kind.qc {
            call shim.send(id, dst, m);
        }

    }

    action byzantine_send_timeout = {
        var m : msg;
        var dst : process_index_t;
        assume global_view.timeout_valid(m.t);

        if ~is_good(m.src) & m.kind = msg_kind.timeout {
            call shim.send(id, dst, m);
            var tc_fp1:tc_fplusone_t;
            var tc:tc_t;
            var kind:to_kind;
            call global_view.timeout(m.src,timeout_t.get_round(m.t),timeout_get_qc(m.t), tc_fp1, tc, kind);
        }

    }

    action byzantine_send_tc = {
        var m : msg;
        var dst : process_index_t;
        assume global_view.tc_valid(m.tc);

        if ~is_good(m.src) & m.kind = msg_kind.tc {
            call shim.send(id, dst, m);
        }
    }

    # action byzantine_send = {
    #     var m : msg;
    #     var dst : process_index_t;
    #     assume global_view.proposal_n_valid(m.prop_n);
    #     assume global_view.proposal_f_valid(m.prop_f);
    #     assume prepare_t.cstd(m.prep);
    #     assume global_view.proposal_n_valid(m.prop_n);
    #     assume global_view.proposal_f_valid(m.prop_f);
    #     assume global_view.qc_valid(m.qc);
    #     assume global_view.timeout_valid(m.t);
    #     assume global_view.tc_valid(m.tc);

    #     if ~is_good(m.src) {
    #         if m.kind = msg_kind.tc {
    #             call shim.send(id, dst, m);
    #         }
    #     }
    # }

    export byzantine_send_prepare_f
    export byzantine_send_prepare_n
    export byzantine_send_proposal_f
    export byzantine_send_proposal_n
    export byzantine_send_qc
    export byzantine_send_tc
    export byzantine_send_timeout
    export proposal_f_processing
    export proposal_n_processing
    export qc_processing
    export tc_processing
    export timeout_sync
    export timer_expire

    
} # object local_view
} # module supraBFT
