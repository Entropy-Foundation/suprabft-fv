#lang ivy1.8

include types
include network

module supraBFT(global_view) = {
object local_view(id:process_index_t) = {
    individual commit_mode : bool
    individual commit_mode_block : block_t
    individual last_committed : block_t

    individual locked : qc_t
    individual r_p : round_t
    individual r_c : round_t
    individual r_c_m1 : round_t
    individual timer : bool
    # simplified, no need to store QCs here for our purposes
    relation uncommitted(B:block_t)
    individual r_vf : round_t
    individual r_vn : round_t

    relation received_proposal_n(P:proposal_n_t, Src:process_index_t)
    relation received_proposal_f(P:proposal_f_t, Src:process_index_t)
    relation received_prepare(P:prepare_t, Src:process_index_t)
    relation received_qc(QC:qc_t)
    relation received_timeout(T:timeout_t, Src:process_index_t)
    relation received_tc(TC:tc_t)
    relation received_tc_fplusone(TC:tc_fplusone_t)

    relation processed_qc(B:block_t)
    function qc_for_block(B:block_t) : qc_t

    relation expired_rounds(R:round_t)

    relation qcs_in_tc_processed(TC:tc_t)

    definition qcs_in_tc_processed(TC) = forall T:timeout_t. forall QC:qc_t. forall B:block_t. tc_t.timeout(TC,T) & timeout_t.qc(T,QC) & qc_t.block(QC,B) -> processed_qc(B)

    relation qc_in_tc(TC:tc_t,QC:qc_t)

    definition qc_in_tc(TC,QC) = exists T:timeout_t. tc_t.timeout(TC,T) & timeout_t.qc(T,QC)

    after init {
        commit_mode := false;
        commit_mode_block := block_t.unused;
        last_committed := block_t.unused;

        locked := qc_t.genesis;
        r_p := 0;
        r_c := *;
        assume round_t.succ(0, r_c);
        r_c_m1 := 0;
        timer := false;
        uncommitted(B) := false;
        r_vf := 0;
        r_vn := 0;

        received_proposal_n(P, Src) := P = proposal_n_t.genesis & Src = leader(0);
        received_proposal_f(P, Src) := false;
        received_prepare(P, Src) := P = prepare_t.genesis;
        received_qc(QC) := QC = qc_t.genesis;
        received_timeout(T, Src) := false;
        received_tc(TC) := false;
        received_tc_fplusone(TC) := false;

        processed_qc(B) := B = block_t.genesis;
        qc_for_block(block_t.genesis) := qc_t.genesis;

        expired_rounds(R) := false;
    }

    implement shim.proposal_n_handler.handle(m:msg) {
            received_proposal_n(m.prop_n, m.src) := true;
    }

    implement shim.proposal_f_handler.handle(m:msg) {
            received_proposal_f(m.prop_f, m.src) := true;
            var temp_tc := proposal_f_get_tc(m.prop_f);
            received_tc(temp_tc) := true;
            received_qc(QC) := received_qc(QC) | qc_in_tc(temp_tc,QC);
    }

    implement shim.prepare_handler.handle(m:msg) {
            received_prepare(m.prep, m.src) := true;
    }

    implement shim.qc_handler.handle(m:msg) {
            received_qc(m.qc) := true;
    }

    implement shim.timeout_handler.handle(m:msg) {
            received_timeout(m.t, m.src) := true;
            received_qc(timeout_get_qc(m.t)) := true;
    }

    implement shim.tc_handler.handle(m:msg) {
            received_tc(m.tc) := true;
            received_qc(QC) := received_qc(QC) | qc_in_tc(m.tc,QC);
    }

    implement shim.tc_fplusone_handler.handle(m:msg) {
        received_tc_fplusone(m.tc_po) := true;
    }

    action proposal_f_get_tc(p:proposal_f_t) returns (tc:tc_t) = {
        if some p_tc:tc_t. proposal_f_t.tc(p, p_tc) {
            tc := p_tc;
        }
    }

    action timeout_get_qc(t:timeout_t) returns (qc:qc_t) = {
        if some t_qc:qc_t. timeout_t.qc(t, t_qc) {
            qc := t_qc;
        }
    }

    action qc_get_block(qc:qc_t) returns (b:block_t) = {
        if some qc_b:block_t. qc_t.block(qc, qc_b) {
            b := qc_b;
        }
    }

    action broadcast_proposal_n(p:proposal_n_t) = {
        var m : msg;
        m.kind := msg_kind.proposal_n;
        m.prop_n := p;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_proposal_f(p:proposal_f_t) = {
        var m : msg;
        m.kind := msg_kind.proposal_f;
        m.prop_f := p;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_prepare(p:prepare_t) = {
        var m : msg;
        m.kind := msg_kind.prepare;
        m.prep := p;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_qc(q:qc_t) = {
        var m : msg;
        m.kind := msg_kind.qc;
        m.qc := q;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_timeout(t:timeout_t) = {
        var m : msg;
        m.kind := msg_kind.timeout;
        m.t := t;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_tc(t:tc_t) = {
        var m : msg;
        m.kind := msg_kind.tc;
        m.tc := t;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action commit = {

        if some b:block_t. commit_mode_block ~= last_committed & ((b = commit_mode_block & ((commit_mode_block = block_t.genesis & last_committed = block_t.unused) | block_t.parent(commit_mode_block, last_committed))) |
                (uncommitted(b) & block_t.ancestor(commit_mode_block, b) & block_t.parent(b, last_committed))) {
            assume block_t.height(b,Hb) & global_view.process_committed(id,B) & block_t.height(B,Hc) -> Hc < Hb;#_#
            last_committed := b;
            uncommitted(B) := uncommitted(B) & (b = block_t.genesis -> B ~= block_t.genesis) & block_t.ancestor(B, last_committed);

            call global_view.commit(id, last_committed);
        }

        if commit_mode_block = last_committed {
            commit_mode := false;
            commit_mode_block := block_t.unused;
        }
    }

    action cleanup(r:round_t) = {
        expired_rounds(R) := expired_rounds(R) & r < R;
    }

    action proposeNormal(pB:block_t) = {
        if leader(r_c) = id {
            var b := block_t.block(r_c, pB);
            var p := proposal_n_t.proposal_n(b);
            call broadcast_proposal_n(p);
            r_p := r_c;
        }
    }

    action advanceToRound(r:round_t) returns (r_c_updated : bool)= {
        if r > r_c {
            r_c_updated := true;
            r_c := r;
            r_c_m1 := round_t.prev(r_c);
            timer := false;
            call cleanup(round_t.prev(round_t.prev(r)));
        } else {
            r_c_updated := false;
        }
    }

    action tryLock(qc:qc_t) = {
        var r := qc_get_round(qc);
        if (forall Bl:block_t. forall Rl:round_t. qc_t.block(locked, Bl) & block_t.round(Bl, Rl) -> r > Rl) & ~ expired_rounds(r) & r_c <= round_t.next(r) {
            locked := qc;

            call global_view.lock(id, qc_get_block(qc), qc);
        }
    }

    action tryCommit(b:block_t) = {
        if some bp:block_t. block_t.parent(b, bp) & uncommitted(bp) & global_view.successive_blocks(bp,b) {
            commit_mode_block := bp;

            if (commit_mode_block = block_t.genesis | (forall B:block_t. block_t.ancestor(commit_mode_block, B) & block_t.ancestor(B, last_committed) ->
                    uncommitted(B))) {
                        commit_mode := true;
            }
        }
        else if some bc:block_t. block_t.parent(bc, b) & uncommitted(bc) & global_view.successive_blocks(b,bc) {
            commit_mode_block := b;

            # the code is duplicated here rather than outside these blocks to avoid using an uninitialised commit_mode_block
            if commit_mode_block ~= last_committed & (commit_mode_block = block_t.genesis | (forall B:block_t. block_t.ancestor(commit_mode_block, B) & block_t.ancestor(B, last_committed) ->
                    uncommitted(B))) {
                        commit_mode := true;
            }
        }
    }

    action qc_processing(qc:qc_t) = {
        require received_qc(qc);

        
        var b_qc := qc_get_block(qc);
        if ~processed_qc(b_qc) {
            if (r_p < r_c & (forall R:round_t. block_t.round(b_qc,R) -> round_t.succ(R,r_c))) {
                call proposeNormal(b_qc);
            }
            uncommitted(b_qc) := true;
            call tryLock(qc);
            call tryCommit(b_qc);
            call broadcast_qc(qc);
            processed_qc(b_qc) := true;
            var r_c_updated := advanceToRound(round_t.next(round_t.next(block_t.get_round(b_qc))));
            global_view.process_qc(id,qc_get_block(qc),qc);
            var tc_temp:tc_t;
            if r_c_updated {
                global_view.enter_round(id,round_t.next(round_t.next(block_t.get_round(b_qc))),qc_get_block(qc),tc_temp);
            }
            qc_for_block(b_qc) := qc;
        }
    }

    action proposal_n_processing(p:proposal_n_t) = {
        call global_view.receive_normal_proposal(id,p);

        var ok := true;
        ok := ok & forall B:block_t. forall R:round_t. proposal_n_t.block(p, B) & block_t.round(B, R) -> round_t.succ(R, r_c);
        ok := ok & forall B,Bp:block_t. proposal_n_t.block(p, B) & block_t.parent(B,Bp) -> uncommitted(Bp);
        ok := ok & ~timer;
        if ok {
            call proposeNormal(proposal_n_t.get_block(p));
        }
        ok := ok & forall B:block_t. forall R:round_t. proposal_n_t.block(p, B) & block_t.round(B, R) -> ~expired_rounds(R);
        ok := ok & forall B:block_t. forall R:round_t. proposal_n_t.block(p, B) & block_t.round(B, R) -> r_vn < R;
        ok := ok & forall B1,B2:block_t. proposal_n_t.block(p, B1) & block_t.parent(B1, B2) -> qc_t.block(locked, B2);
        if ok {
            call broadcast_prepare(prepare_t.prepare(proposal_n_t.get_block(p)));
            call global_view.vote_normal(id,p);
            r_vn := r_c;
        }
    }

    action proposeFR(tc:tc_t) = {

        var ok := true;
        var r := round_t.next(tc_get_round(tc));
        ok := ok & round_t.succ(r, r_c);
        ok := ok & leader(r) = id;

        if ok {
            var qcp := tc_getMaxQC(tc);

            #ensure that qcp has been processed already. In implementation, this is done by calling the subroutine for processing qc. Here, we contrain the environment to call qc_processing on qcp before calling proposal_f_processing
            #require qc_t.block(qcp,B) & qcp ~= qc_t.genesis -> processed_qc(B);

            var b := block_t.block(r, qc_get_block(qcp));
            var p := proposal_f_t.proposal_f(b,tc);
            call broadcast_proposal_f(p);
            r_p := r;
        }
    }

    action timeout(r:round_t) = {
        if( ~expired_rounds(r)) {
            var t := timeout_t.timeout(r, locked);
            call broadcast_timeout(t);
            expired_rounds(r) := true;
            call global_view.timeout(id, r,locked);
        }
    }

    action timer_expire = {
        
        timer := true;
        call timeout(round_t.prev(r_c));
    }

    action timeout_sync(tc:tc_fplusone_t) = {
        var r := tc_fplusone_get_round(tc);
        if (round_t.prev(r_c) <= r) {
            call timeout(r);
        }

        
    }

    action tc_processing(tc:tc_t) = {
        if(r_c_m1 <= tc_get_round(tc) & tc_get_round(tc) > 0) {
            call timeout(tc_get_round(tc));
        }
        var r_c_updated := advanceToRound(round_t.next(round_t.next(tc_get_round(tc))));
        call proposeFR(tc);
        if round_t.succ(round_t.next(tc_get_round(tc)),r_c)
        {
            #in real implementation, the timer has to be extended by \Delta. Here in IVy, timer is not maintained explicitly, but only maintained implecitly through a Boolean variable, so there is nothing to do
            #timer := false;
        }
        global_view.processed_tc(id,tc);
        var b_temp:block_t;
        if r_c_updated {
            global_view.enter_round(id,round_t.next(round_t.next(tc_get_round(tc))),b_temp,tc);
        }
    }

    action proposal_f_processing(p:proposal_f_t) = {

        call global_view.receive_fallback_proposal(id,p);

        var tcp := proposal_f_get_tc(p);
        var tp := tc_getMaxTC(proposal_f_get_tc(p));
        var qcp := timeout_get_qc(tp);
        var ok := true;
        ok := ok & ~timer;
        ok := ok & forall B:block_t. forall R:round_t. proposal_f_t.block(p, B) & block_t.round(B, R) -> round_t.succ(R, r_c);
        ok := ok & forall TC:tc_t. forall B:block_t. forall R1,R2:round_t. proposal_f_t.tc(p, TC) & tc_t.round(TC, R1) &
                proposal_f_t.block(p, B) & block_t.round(B, R2) -> round_t.succ(R1, R2);
        ok := ok & forall B1,B2:block_t. proposal_f_t.block(p, B1) & block_t.parent(B1, B2) -> qc_t.block(qcp, B2);
        if ok {
            call tc_processing(proposal_f_get_tc(p));
            call proposeNormal(proposal_f_t.get_block(p));
        }
        ok := ok & forall B:block_t. forall Rb:round_t. proposal_f_t.block(p,B) & block_t.round(B,Rb) -> ~expired_rounds(Rb) & Rb > r_vf;
        if ok {
            call broadcast_prepare(prepare_t.prepare(proposal_f_t.get_block(p)));
            call global_view.vote_fallback(id,p,tc_get_quorum(tcp));
            r_vf := block_t.get_round(proposal_f_t.get_block(p));
        }
        
    }

    action tc_getMaxQC(tc:tc_t) returns (qc:qc_t) = {
        assume exists T:timeout_t. global_view.timeout_valid(T) & tc_t.timeout(tc, T) & timeout_t.qc(T, qc);
        assume forall T:timeout_t. forall QC:qc_t. forall B1,B2:block_t. forall R1,R2:round_t. global_view.timeout_valid(T) & tc_t.timeout(tc, T) & timeout_t.qc(T, QC) &
                qc_t.block(QC, B1) & block_t.round(B1, R1) & qc_t.block(qc, B2) & block_t.round(B2, R2) -> R2 >= R1;
    }

    action tc_getMaxTC(tc:tc_t) returns (t:timeout_t) = {
        assume tc_t.timeout(tc, t);
        assume forall T:timeout_t. forall QCc,QCt:qc_t. forall Bc,Bt:block_t. forall Rc,Rt:round_t. tc_t.timeout(tc, T) & timeout_t.qc(T, QCc) &
                qc_t.block(QCc, Bc) & block_t.round(Bc, Rc) & timeout_t.qc(t,QCt) & qc_t.block(QCt, Bt) & block_t.round(Bt, Rt) -> Rc <= Rt;
    }

    action tc_get_round(tc:tc_t) returns (r:round_t) = {
        if some tc_r:round_t. tc_t.round(tc, tc_r) {
            r := tc_r;
        }
    }

    action tc_get_quorum(tc:tc_t) returns (q:quorum_t) = {
        if some tc_q:quorum_t. tc_t.quorum(tc,tc_q) {
            q := tc_q;
        }
    }

    action qc_get_round(qc:qc_t) returns (r:round_t) = {
        if some qc_b:block_t. qc_t.block(qc, qc_b) {
            r := block_t.get_round(qc_b);
        }
    }

    action tc_fplusone_get_round(tc:tc_fplusone_t) returns (r:round_t) = {
        if some tc_r:round_t. tc_fplusone_t.round(tc, tc_r) {
            r := tc_r;
        }
    }

    action byzantine_send_proposal_f = {
        var m : msg;
        var dst : process_index_t;
        assume global_view.proposal_f_valid(m.prop_f);

        if ~is_good(m.src) & m.kind = msg_kind.proposal_f {
            call shim.send(id, dst, m);
        }

    }

    action byzantine_send_proposal_n = {
        var m : msg;
        var dst : process_index_t;
        assume global_view.proposal_n_valid(m.prop_n);

        if ~is_good(m.src) & m.kind = msg_kind.proposal_n {
            call shim.send(id, dst, m);
        }

    }

    action byzantine_send_prepare_n = {
        var m : msg;
        var dst : process_index_t;
        assume prepare_t.cstd(m.prep);

        if ~is_good(m.src) & m.kind = msg_kind.prepare & prepare_t.get_block(m.prep) = proposal_n_t.get_block(m.prop_n)
        {
            call shim.send(id, dst, m);
            call global_view.vote_normal(m.src,m.prop_n);
        }

    }

    action byzantine_send_prepare_f = {
        var m : msg;
        var dst : process_index_t;
        assume prepare_t.cstd(m.prep);

        if ~is_good(m.src) & m.kind = msg_kind.prepare & prepare_t.get_block(m.prep) = proposal_f_t.get_block(m.prop_f)
        {
            var q:quorum_t;
            call shim.send(id, dst, m);
            call global_view.vote_fallback(m.src,m.prop_f,q);
        }

    }

    action byzantine_send_qc = {
        var m : msg;
        var dst : process_index_t;
        assume global_view.qc_valid(m.qc);

        if ~is_good(m.src) & m.kind = msg_kind.qc {
            call shim.send(id, dst, m);
        }

    }

    action byzantine_send_timeout = {
        var m : msg;
        var dst : process_index_t;
        assume global_view.timeout_valid(m.t);

        if ~is_good(m.src) & m.kind = msg_kind.timeout {
            call shim.send(id, dst, m);
            call global_view.timeout(m.src,timeout_t.get_round(m.t),timeout_get_qc(m.t));
        }

    }

    action byzantine_send_tc = {
        var m : msg;
        var dst : process_index_t;
        assume global_view.tc_valid(m.tc);

        if ~is_good(m.src) & m.kind = msg_kind.tc {
            call shim.send(id, dst, m);
        }
    }

    # action byzantine_send = {
    #     var m : msg;
    #     var dst : process_index_t;
    #     assume global_view.proposal_n_valid(m.prop_n);
    #     assume global_view.proposal_f_valid(m.prop_f);
    #     assume prepare_t.cstd(m.prep);
    #     assume global_view.proposal_n_valid(m.prop_n);
    #     assume global_view.proposal_f_valid(m.prop_f);
    #     assume global_view.qc_valid(m.qc);
    #     assume global_view.timeout_valid(m.t);
    #     assume global_view.tc_valid(m.tc);

    #     if ~is_good(m.src) {
    #         if m.kind = msg_kind.tc {
    #             call shim.send(id, dst, m);
    #         }
    #     }
    # }

    export commit
    export qc_processing
    export proposal_n_processing
    export timer_expire
    export timeout_sync
    export tc_processing
    export proposal_f_processing
    export byzantine_send_proposal_f
    export byzantine_send_proposal_n
    export byzantine_send_prepare_n
    export byzantine_send_prepare_f
    export byzantine_send_qc
    export byzantine_send_timeout
    export byzantine_send_tc
    
} # object local_view
} # module supraBFT
