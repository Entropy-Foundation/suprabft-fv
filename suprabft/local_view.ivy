#lang ivy1.8

include types
include network

module supraBFT(global_view) = {
object local_view(id:process_index_t) = {
    individual commit_mode : bool
    individual commit_mode_block : block_t
    individual last_committed : block_t

    individual locked : qc_t
    individual r_p : round_t
    individual r_c : round_t
    individual timer : bool
    # simplified, no need to store QCs here for our purposes
    relation uncommitted(B:block_t)
    individual r_vf : round_t
    individual r_vn : round_t

    relation received_proposal_n(P:proposal_n_t, Src:process_index_t)
    relation received_proposal_f(P:proposal_f_t, Src:process_index_t)
    relation received_prepare(P:prepare_t, Src:process_index_t)
    relation received_qc(QC:qc_t)
    relation received_timeout(T:timeout_t, Src:process_index_t)
    relation received_tc(TC:tc_t)
    relation received_tc_fplusone(TC:tc_fplusone_t)

    relation processed_qc(B:block_t)

    relation expired_rounds(R:round_t)

    relation qcs_in_tc_processed(TC:tc_t)

    definition qcs_in_tc_processed(TC) = forall T:timeout_t. forall QC:qc_t. forall B:block_t. tc_t.timeout(TC,T) & timeout_t.qc(T,QC) & qc_t.block(QC,B) -> processed_qc(B)

    relation qc_in_tc(TC:tc_t,QC:qc_t)

    definition qc_in_tc(TC,QC) = exists T:timeout_t. tc_t.timeout(TC,T) & timeout_t.qc(T,QC)

    after init {
        commit_mode := false;
        commit_mode_block := block_t.unused;
        last_committed := block_t.unused;

        locked := qc_t.genesis;
        r_p := 0;
        r_c := *;
        assume round_t.succ(0, r_c);
        timer := false;
        uncommitted(B) := false;
        r_vf := 0;
        r_vn := 0;

        received_proposal_n(P, Src) := P = proposal_n_t.genesis & Src = leader(0);
        received_proposal_f(P, Src) := false;
        received_prepare(P, Src) := P = prepare_t.genesis;
        received_qc(QC) := QC = qc_t.genesis;
        received_timeout(T, Src) := false;
        received_tc(TC) := false;
        received_tc_fplusone(TC) := false;

        processed_qc(B) := B = block_t.genesis;

        expired_rounds(R) := false;
    }

    implement shim.proposal_n_handler.handle(m:msg) {
        if proposal_n_t.valid(m.prop_n) {
            received_proposal_n(m.prop_n, m.src) := true;
        }
    }

    implement shim.proposal_f_handler.handle(m:msg) {
        if global_view.proposal_f_valid(m.prop_f) {
            received_proposal_f(m.prop_f, m.src) := true;
            var temp_tc := proposal_f_get_tc(m.prop_f);
            received_tc(temp_tc) := true;
            received_qc(QC) := received_qc(QC) | qc_in_tc(temp_tc,QC);
        }
    }

    implement shim.prepare_handler.handle(m:msg) {
        if prepare_t.valid(m.prep) {
            received_prepare(m.prep, m.src) := true;
        }
    }

    implement shim.qc_handler.handle(m:msg) {
        if global_view.qc_valid(m.qc) {
            received_qc(m.qc) := true;
        }
    }

    implement shim.timeout_handler.handle(m:msg) {
        if global_view.timeout_valid(m.t) {
            received_timeout(m.t, m.src) := true;
            received_qc(timeout_get_qc(m.t)) := true;
        }
    }

    implement shim.tc_handler.handle(m:msg) {
        if global_view.tc_valid(m.tc) {
            received_tc(m.tc) := true;
            received_qc(QC) := received_qc(QC) | qc_in_tc(m.tc,QC);
        }
    }

    action proposal_f_get_tc(p:proposal_f_t) returns (tc:tc_t) = {
        require global_view.proposal_f_valid(p);

        if some p_tc:tc_t. proposal_f_t.tc(p, p_tc) {
            tc := p_tc;
        }

        ensure proposal_f_t.tc(p, tc);
    }

    action timeout_get_qc(t:timeout_t) returns (qc:qc_t) = {
        require global_view.timeout_valid(t);

        if some t_qc:qc_t. timeout_t.qc(t, t_qc) {
            qc := t_qc;
        }

        ensure timeout_t.qc(t, qc);
    }

    action qc_get_block(qc:qc_t) returns (b:block_t) = {
        require global_view.qc_valid(qc);

        if some qc_b:block_t. qc_t.block(qc, qc_b) {
            b := qc_b;
        }

        ensure qc_t.block(qc, b);
    }

    action broadcast_proposal_n(p:proposal_n_t) = {
        var m : msg;
        m.kind := msg_kind.proposal_n;
        m.prop_n := p;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_proposal_f(p:proposal_f_t) = {
        var m : msg;
        m.kind := msg_kind.proposal_f;
        m.prop_f := p;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_prepare(p:prepare_t) = {
        var m : msg;
        m.kind := msg_kind.prepare;
        m.prep := p;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_qc(q:qc_t) = {
        var m : msg;
        m.kind := msg_kind.qc;
        m.qc := q;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_timeout(t:timeout_t) = {
        var m : msg;
        m.kind := msg_kind.timeout;
        m.t := t;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_tc(t:tc_t) = {
        var m : msg;
        m.kind := msg_kind.tc;
        m.tc := t;
        m.src := id;

        call shim.broadcast(id, m);
    }

    export action commit = {
        require commit_mode;

        if some b:block_t. (b = commit_mode_block & ((commit_mode_block = block_t.genesis & last_committed = block_t.unused) | block_t.parent(commit_mode_block, last_committed))) |
                (uncommitted(b) & block_t.ancestor(commit_mode_block, b) & block_t.parent(b, last_committed)) {
            last_committed := b;
            uncommitted(B) := uncommitted(B) & (b = block_t.genesis -> B ~= block_t.genesis) & block_t.ancestor(B, last_committed);

            call global_view.commit(id, last_committed);
        }

        if commit_mode_block = last_committed {
            commit_mode := false;
            commit_mode_block := block_t.unused;
        }
    }

    action cleanup(r:round_t) = {
        expired_rounds(R) := expired_rounds(R) & r < R;
    }

    action proposeNormal(pB:block_t) = {
        require block_t.round(pB,Rp) -> round_t.succ(Rp,r_c);

        if leader(r_c) = id {
            var b := block_t.block(r_c, pB);
            var p := proposal_n_t.proposal_n(b);
            call broadcast_proposal_n(p);
            r_p := r_c;
        }
    }

    action advanceToRound(r:round_t) = {
        if r > r_c {
            r_c := r;
            global_view.enter_round(id,r);
            timer := false;
            call cleanup(round_t.prev(round_t.prev(r)));
        }
    }

    action tryLock(qc:qc_t) = {
        var r := qc_get_round(qc);
        if (forall Bl:block_t. forall Rl:round_t. qc_t.block(locked, Bl) & block_t.round(Bl, Rl) -> r > Rl) & ~ expired_rounds(r) & r_c <= round_t.next(r) {
            locked := qc;

            call global_view.lock(id, qc_get_block(qc), qc);
        }
    }

    action tryCommit(b:block_t) = {
        if some bp:block_t. block_t.parent(b, bp) & uncommitted(bp) & (forall R1,R2:round_t. block_t.round(bp, R1) & block_t.round(b, R2) -> round_t.succ(R1, R2)) {
            commit_mode_block := bp;

            if commit_mode_block = block_t.genesis | (forall B:block_t. block_t.ancestor(commit_mode_block, B) & block_t.ancestor(B, last_committed) ->
                    uncommitted(B)) {
                commit_mode := true;
            }
        }
        else if some bc:block_t. block_t.parent(bc, b) & uncommitted(bc) & (forall R1,R2:round_t. block_t.round(bc, R1) & block_t.round(b, R2) ->
                round_t.succ(R2, R1)) {
            commit_mode_block := b;

            # the code is duplicated here rather than outside these blocks to avoid using an uninitialised commit_mode_block
            if commit_mode_block = block_t.genesis | (forall B:block_t. block_t.ancestor(commit_mode_block, B) & block_t.ancestor(B, last_committed) ->
                    uncommitted(B)) {
                commit_mode := true;
            }
        }
    }

    export action qc_processing(qc:qc_t) = {

        require received_qc(qc);

        var b_qc := qc_get_block(qc);
        if ~processed_qc(b_qc) {
            if (r_p < r_c & (forall R:round_t. block_t.round(b_qc,R) -> round_t.succ(R,r_c))) {
                call proposeNormal(b_qc);
            }
            uncommitted(b_qc) := true;
            call tryLock(qc);
            call tryCommit(b_qc);
            call broadcast_qc(qc);
            call advanceToRound(round_t.next(round_t.next(block_t.get_round(b_qc))));
            global_view.process_qc(id,qc_get_block(qc),qc);
            processed_qc(b_qc) := true;
        }
    }

    export action proposal_n_processing(p:proposal_n_t) = {
        require ~timer;
        require proposal_n_t.block(p, B) & block_t.parent(B,Bp) & block_t.round(B,R) & block_t.round(Bp,Rp) -> round_t.succ(Rp,R);

        require received_proposal_n(p, leader(round_t.prev(r_c)));

        var ok := true;
        ok := ok & forall B:block_t. forall R:round_t. proposal_n_t.block(p, B) & block_t.round(B, R) -> round_t.succ(R, r_c);
        ok := ok & forall B,Bp:block_t. proposal_n_t.block(p, B) & block_t.parent(B,Bp) -> uncommitted(Bp);
        ok := ok & ~timer;
        if ok {
            call proposeNormal(proposal_n_t.get_block(p));
        }
        ok := ok & forall B:block_t. forall R:round_t. proposal_n_t.block(p, B) & block_t.round(B, R) -> ~expired_rounds(R);
        ok := ok & forall B:block_t. forall R:round_t. proposal_n_t.block(p, B) & block_t.round(B, R) -> r_vn < R;
        ok := ok & forall B1,B2:block_t. proposal_n_t.block(p, B1) & block_t.parent(B1, B2) -> qc_t.block(locked, B2);
        if ok {
            call broadcast_prepare(prepare_t.prepare(proposal_n_t.get_block(p)));
            call global_view.vote_normal(id,proposal_n_t.get_block(p));
            r_vn := r_c;
        }
    }

    action proposeFR(tc:tc_t) = {

        var ok := true;
        var r := round_t.next(tc_get_round(tc));
        ok := ok & round_t.succ(r, r_c);
        ok := ok & leader(r) = id;

        if ok {
            var qcp := tc_getMaxQC(tc);

            #ensure that qcp has been processed already. In implementation, this is done by calling the subroutine for processing qc. Here, we contrain the environment to call qc_processing on qcp before calling proposal_f_processing
            require qc_t.block(qcp,B) & qcp ~= qc_t.genesis -> processed_qc(B);

            var b := block_t.block(r, qc_get_block(qcp));
            var p := proposal_f_t.proposal_f(b,tc);
            call broadcast_proposal_f(p);
            r_p := r;
        }
    }

    action timeout(r:round_t) = {
        if( ~expired_rounds(r)) {
            var t := timeout_t.timeout(r, locked);
            call broadcast_timeout(t);
            expired_rounds(r) := true;
            call global_view.timeout(id, r,locked);
        }
    }

    export action timer_expire = {
        require ~timer;
        require round_t.succ(0,R1) -> R1 < r_c;
        
        timer := true;
        call timeout(round_t.prev(r_c));
    }

    export action timeout_sync(tc:tc_fplusone_t) = {
        require received_tc_fplusone(tc);

        #ensure all QCs contained in tc are processed. In implementation, this is done by calling the subroutine for processing qc. Here, we contrain the environment to call qc_processing on the qcs before calling timeout_sync
        require forall T:timeout_t. forall QC:qc_t. forall B:block_t. tc_fplusone_t.timeout(tc,T) & timeout_t.qc(T,QC) & qc_t.block(QC,B) -> processed_qc(B);

        var r := tc_fplusone_get_round(tc);
        if (round_t.prev(r_c) <= r) {
            call timeout(r);
        }

        
    }

    export action tc_processing(tc:tc_t) = {
        require qcs_in_tc_processed(tc);
        require received_tc(tc);

        if(round_t.next(round_t.next(tc_get_round(tc))) > r_c) {
            call timeout(tc_get_round(tc));
        }
        call advanceToRound(round_t.next(round_t.next(tc_get_round(tc))));
        call proposeFR(tc);
        if round_t.succ(round_t.next(tc_get_round(tc)),r_c)
        {
            #in real implementation, the timer has to be extended by \Delta. Here in IVy, timer is not maintained explicitly, but only maintained implecitly through a Boolean variable, so there is nothing to do
            #timer := false;
        }
        global_view.processed_tc(id,tc);
    }

    export action proposal_f_processing(p:proposal_f_t) = {
        require ~timer;

        require received_proposal_f(p, leader(round_t.prev(r_c)));

        require proposal_f_t.tc(p,TC) -> qcs_in_tc_processed(TC);

        var tcp := tc_getMaxTC(proposal_f_get_tc(p));
        var qcp := timeout_get_qc(tcp);
        var ok := true;
        ok := ok & ~timer;
        ok := ok & forall B:block_t. forall R:round_t. proposal_f_t.block(p, B) & block_t.round(B, R) -> round_t.succ(R, r_c);
        ok := ok & forall TC:tc_t. forall B:block_t. forall R1,R2:round_t. proposal_f_t.tc(p, TC) & tc_t.round(TC, R1) &
                proposal_f_t.block(p, B) & block_t.round(B, R2) -> round_t.succ(R1, R2);
        ok := ok & forall B1,B2:block_t. proposal_f_t.block(p, B1) & block_t.parent(B1, B2) -> qc_t.block(qcp, B2);
        if ok {
            call tc_processing(proposal_f_get_tc(p));
            call proposeNormal(proposal_f_t.get_block(p));
        }
        ok := ok & forall B:block_t. forall Rb:round_t. proposal_f_t.block(p,B) & block_t.round(B,Rb) -> ~expired_rounds(Rb) & Rb > r_vf;
        if ok {
            call broadcast_prepare(prepare_t.prepare(proposal_f_t.get_block(p)));
            call global_view.vote_fallback(id,proposal_f_t.get_block(p),tcp);
            r_vf := block_t.get_round(proposal_f_t.get_block(p));
        }
        
    }

    action tc_getMaxQC(tc:tc_t) returns (qc:qc_t) = {
        require global_view.tc_valid(tc);
        assume exists T:timeout_t. global_view.timeout_valid(T) & tc_t.timeout(tc, T) & timeout_t.qc(T, qc);
        assume forall T:timeout_t. forall QC:qc_t. forall B1,B2:block_t. forall R1,R2:round_t. global_view.timeout_valid(T) & tc_t.timeout(tc, T) & timeout_t.qc(T, QC) &
                qc_t.block(QC, B1) & block_t.round(B1, R1) & qc_t.block(qc, B2) & block_t.round(B2, R2) -> R2 >= R1;

        ensure global_view.qc_valid(qc);
    }

    action tc_getMaxTC(tc:tc_t) returns (t:timeout_t) = {
        require global_view.tc_valid(tc);
        assume tc_t.timeout(tc, t);
        assume forall T:timeout_t. forall QCc,QCt:qc_t. forall Bc,Bt:block_t. forall Rc,Rt:round_t. tc_t.timeout(tc, T) & timeout_t.qc(T, QCc) &
                qc_t.block(QCc, Bc) & block_t.round(Bc, Rc) & timeout_t.qc(t,QCt) & qc_t.block(QCt, Bt) & block_t.round(Bt, Rt) -> Rc <= Rt;
    }

    action tc_get_round(tc:tc_t) returns (r:round_t) = {
        require global_view.tc_valid(tc);

        if some tc_r:round_t. tc_t.round(tc, tc_r) {
            r := tc_r;
        }

        ensure tc_t.round(tc, r);
    }

    action qc_get_round(qc:qc_t) returns (r:round_t) = {
        require global_view.qc_valid(qc);

        if some qc_b:block_t. qc_t.block(qc, qc_b) {
            r := block_t.get_round(qc_b);
        }

        ensure forall B:block_t. qc_t.block(qc,B) -> block_t.round(B, r);
    }

    action tc_fplusone_get_round(tc:tc_fplusone_t) returns (r:round_t) = {
        require global_view.tc_fplusone_valid(tc);

        if some tc_r:round_t. tc_fplusone_t.round(tc, tc_r) {
            r := tc_r;
        }

        ensure tc_fplusone_t.round(tc, r);
    }

    export action byzantine_send = {
        require ~is_good(id);

        var m : msg;
        var dst : process_index_t;
        if ~is_good(m.src) {
            if m.kind = msg_kind.proposal_n & proposal_n_t.valid(m.prop_n) {
                call shim.send(id, dst, m);
            }
            if m.kind = msg_kind.proposal_f & global_view.proposal_f_valid(m.prop_f) {
                call shim.send(id, dst, m);
            }
            if m.kind = msg_kind.prepare {
                call shim.send(id, dst, m);
                if * 
                {
                    call global_view.vote_normal(m.src,prepare_t.get_block(m.prep));
                }
                else
                {
                    var t:timeout_t;
                    call global_view.vote_fallback(m.src,prepare_t.get_block(m.prep),t);
                }
            }
            if m.kind = msg_kind.qc & global_view.qc_valid(m.qc) {
                call shim.send(id, dst, m);
            }
            if m.kind = msg_kind.timeout & global_view.qc_valid(timeout_get_qc(m.t)) {
                call shim.send(id, dst, m);
                call global_view.timeout(m.src,timeout_t.get_round(m.t),timeout_get_qc(m.t));
            }
            if m.kind = msg_kind.tc & global_view.tc_valid(m.tc) {
                call shim.send(id, dst, m);
            }
        }
    }

    invariant r_c > 0

    invariant received_proposal_n(P, N) -> proposal_n_t.valid(P)
    invariant received_proposal_f(P, N) -> global_view.proposal_f_valid(P)
    invariant received_prepare(P, N) -> prepare_t.valid(P)
    invariant received_qc(QC) -> global_view.qc_valid(QC)
    invariant received_timeout(T, N) -> global_view.timeout_valid(T)
    invariant received_tc(TC) -> global_view.tc_valid(TC)
    invariant received_tc_fplusone(TC) -> global_view.tc_fplusone_valid(TC)

    invariant is_good(id) & global_view.process_voted_normal(id,B) & block_t.round(B,R) -> R <= r_vn
    invariant is_good(id) & global_view.process_voted_fallback(id,B) & block_t.round(B,R) -> R <= r_vf
    invariant global_view.process_in_round(id,r_c)

    invariant forall R:round_t. expired_rounds(R) -> exists QC:qc_t. global_view.process_sent_timeout(id,R,QC)

    invariant forall R,Rs1,Rs2:round_t. forall QC:qc_t. is_good(id) & global_view.process_sent_timeout(id,R,QC) & round_t.succ(R,Rs1) & round_t.succ(Rs1,Rs2) & Rs2 > r_c -> expired_rounds(R)

    invariant timer & round_t.succ(Rp,r_c) -> exists QC:qc_t. global_view.process_sent_timeout(id,Rp,QC)

    invariant processed_qc(QC) <-> global_view.process_processed_qc(id,QC)

    invariant qc_t.block(locked,B) -> processed_qc(B)

    invariant qc_t.block(locked,B) -> global_view.process_locked(id,B)
    
    invariant qc_t.block(locked,B) & block_t.round(B,R) & round_t.succ(R,Rs) & B ~= block_t.genesis -> Rs < r_c

    invariant processed_qc(B) -> exists QC:qc_t. global_view.qc_valid(QC) & qc_t.block(QC,B)

    invariant commit_mode -> uncommitted(commit_mode_block)

    invariant uncommitted(B) -> processed_qc(B)

    invariant last_committed ~= block_t.unused -> global_view.process_committed(id,last_committed)
} # object local_view
} # module supraBFT
