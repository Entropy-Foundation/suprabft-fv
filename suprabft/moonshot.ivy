#lang ivy1.8

include types
include network

module processors = {
object processor(id:process_index_t) = {
    # The highest round for which this process has accepted a Fallback Recovery Proposal by broadcasting a PF message.
    individual a_f: round_t

    # The highest round for which this process has accepted a Normal Proposal by broadcasting a PN message.
    individual a_n: round_t

    # The highest round for which this process has accepted an Optimistic Proposal by broadcasting a PO message.
    individual a_o: round_t

    # The block most recently appended to Bv, the block chain of this validator
    individual b_h: block_t

    # A representation of all blocks that are committed by this process
    relation b_v(B:block_t)

    # The block for which this process last broadcasted a PO message. In the specs, what is actually stored is the digest d_o of b_o, but we store b_o here to reduce complexity
    individual b_o: block_t

    # A set containing the identifiers of all rounds that this process considers to have expired due to having sent the corresponding Timeout message.
    relation expired_rounds(R:round_t)

    # The currently locked QC
    individual qc_l: qc_t

    # the set of qc's that have been processed
    relation processed_qc(B:block_t)

    # The current round
    individual r_c: round_t

    # The highest round for which this process has broadcasted a Timeout message
    individual t_l: round_t

    # The timer used to trigger Timeout events. In the actual implementation, this will be an actual timer; here we use a boolean, which will be true whenever the timer expires beyond the set limit
    individual t_r: bool

    # This is to let the leader of round 1 send an optimistic proposal exactly once
    individual sent_np_r1: bool

    # this is to implement the semantics of "upon first possessing a O(B)" in line 37 of algorithm 2.
    relation possessed_optimistic_for_round(R:round_t)

    # this is to implement the semantics of "upon first possessing a N(B,QC)" in line 49 of algorithm 2.
    relation possessed_normal_for_round(R:round_t)

    # this is to implement the semantics of "upon first observing a set of f+1 T(r,_)" in line 76 of algorithm 3.
    relation timeout_sync_for_round(R:round_t)

    # this is to implement the semantics of "upon first observing tc <- TC(r,qc',c)" in line 80 of algorithm 3.
    relation observed_tc_for_round(R:round_t)

    # this is to implement the semantics of "upon first possessing a F(B,TC)" in line 89 of algorithm 3.
    relation possessed_fallback_for_round(R:round_t)

    relation received_proposal_n(B:block_t, Src:process_index_t)
    relation received_proposal_f(B:block_t, Src:process_index_t)
    relation received_proposal_o(B:block_t, Src:process_index_t)
    relation received_prepare_n(B:block_t, Src:process_index_t)
    relation received_prepare_f(B:block_t, Src:process_index_t)
    relation received_prepare_o(B:block_t, Src:process_index_t)
    relation received_qc(QC:qc_t)
    relation received_timeout(R:round_t, QC:qc_t, Src:process_index_t)
    relation received_tc(TC:tc_t)
    relation received_tc_fplusone(TC:tc_fplusone_t)

    relation ldc_pair(Bp:block_t, Bc:block_t)
    definition ldc_pair(Bp, Bc) = Bc ~= block_t.genesis & block_t.parent(Bc,Bp) & block_t_conv.successive_blocks(Bp,Bc) & processed_qc(Bp) & processed_qc(Bc)

    relation ldc(B:block_t)
    definition ldc(B) = exists Bc:block_t. ldc_pair(B,Bc)

    # relation eligible_to_commit(Bp:block_t)
    # definition eligible_to_commit(Bp) = ldc(Bp) & block_t.ancestor(Bp,b_h) & (forall Ba:block_t. block_t.ancestor(Bp,Ba) -> (processed_qc(Ba) | Ba = b_h | block_t.ancestor(b_h,Ba)))

    # relation commit_candidate(Bp:block_t)
    # definition commit_candidate(Bp) = eligible_to_commit(Bp) & (forall B:block_t. forall Rp,R:round_t. eligible_to_commit(B) & block_t.round(B,R) & block_t.round(Bp,Rp) -> R <= Rp)

    after init {
        a_f := 0;
        a_n := 0;
        a_o := 0;

        b_h := block_t.genesis;

        b_v(B) := B = block_t.genesis;

        b_o := block_t.unused;

        expired_rounds(R) := false;
        qc_l := qc_t.genesis;
        processed_qc(B) := B = block_t.genesis;

        r_c := *;
        assume round_t.succ(0, r_c);

        t_l := 0;

        t_r := false;

        possessed_normal_for_round(R) := R = 0;

        sent_np_r1 := false;

        # these relations keep track of messages received through the network
        received_proposal_n(B, Src) := B = block_t.genesis & Src = leader(0);
        received_proposal_f(B, Src) := false;
        received_proposal_o(B, Src) := false;
        received_prepare_n(B, Src) := B = block_t.genesis;
        received_prepare_f(B, Src) := false;
        received_prepare_o(B, Src) := false;
        received_qc(QC) := QC = qc_t.genesis;
        received_timeout(R, QC, Src) := false;
        received_tc(TC) := false;
        received_tc_fplusone(TC) := false;
    }

    implement shim.proposal_n_handler.handle(m:msg) {
            received_proposal_n(m.block, m.src) := true;
            received_qc(m.qc) := true;
    }

    implement shim.proposal_f_handler.handle(m:msg) {
            received_proposal_f(m.block, m.src) := true;
            received_tc(m.tc) := true;
            if some n:process_index_t. n=n {
                if some qc:qc_t. tc_t.to_messages(m.tc, n,qc) {
                    received_qc(qc) := true;
                }
            } 
    }

    implement shim.proposal_o_handler.handle(m:msg) {
            received_proposal_o(m.block, m.src) := true;
    }

    implement shim.prepare_n_handler.handle(m:msg) {
            received_prepare_n(m.block, m.src) := true;
    }

    implement shim.prepare_f_handler.handle(m:msg) {
            received_prepare_f(m.block, m.src) := true;
    }

    implement shim.prepare_o_handler.handle(m:msg) {
            received_prepare_o(m.block, m.src) := true;
    }

    implement shim.qc_handler.handle(m:msg) {
            received_qc(m.qc) := true;
    }

    implement shim.timeout_handler.handle(m:msg) {
            received_timeout(m.round, m.qc, m.src) := true;
            received_qc(m.qc) := true;
    }

    implement shim.tc_handler.handle(m:msg) {
        received_tc(m.tc) := true;
        if some n:process_index_t. n=n {
            if some qc:qc_t. tc_t.to_messages(m.tc, n,qc) {
                received_qc(qc) := true;
            }
        } 
                
    }

    implement shim.tc_fplusone_handler.handle(m:msg) {
        received_tc_fplusone(m.tc_po) := true;
        if some n:process_index_t. n=n {
            if some qc:qc_t. tc_fplusone_t.to_messages(m.tc_po, n,qc) {
                received_qc(qc) := true;
            }
        }
    }


    action qc_processing(qc:qc_t) = {
        require received_qc(qc);
        require forall B:block_t. qc_t.block(qc,B) -> ~ processed_qc(B); # this is to reflect the semantics of "upon first observing qc" in line 27 of algorithm 2. This action should not be invoked more than once for the same block

        var b_qc : block_t;
        if some b:block_t. qc_t.block(qc,b) {
            b_qc := b;
        }
        var r : round_t;
        if some r_b:round_t. block_t.round(b_qc,r_b) {
            r := round_t.next(r_b);
        }
        processed_qc(b_qc) := true;

        if (forall R, Rs1:round_t. block_t.round(b_qc,R) & round_t.succ(Rs1,r_c) -> Rs1 < R) {

            ### procedure calls in the pseudocode are inlined here to speed up IVy verification
            ### proposeNormal ###

            if leader(r) = id {
                    var b := block_t.block(r,b_qc);
                    var m : msg;
                    m.kind := msg_kind.proposal_n;
                    m.block := b;
                    m.src := id;
                    m.qc := qc;
                    call shim.broadcast(id, m);
                }
        }

        if forall B_l:block_t. forall R_l,R_qc:round_t. qc_t.block(qc_l,B_l) & block_t.round(B_l,R_l) & block_t.round(b_qc,R_qc) -> R_l < R_qc {
            qc_l := qc;
        }

        ######### tryCommit ##########
        # if some bp:block_t. commit_candidate(bp) {
        #     b_v(B) := b_v(B) | B = bp | (block_t.ancestor(bp,B) & block_t.ancestor(B,b_h));
        #     b_h := bp;
        # }

        ######### multicastQC #########
        var m : msg;
        m.kind := msg_kind.qc;
        m.qc := qc;
        m.src := id;
        call shim.broadcast(id, m);

        ######### advanceToRound #############
        if r_c < r {
            r_c := r;
            t_r := false;
        }
    }

    function send_prepare_o_condition(B_pr:block_t): bool
    definition send_prepare_o_condition(B_pr) = block_t.round(B_pr,r_c) & a_f < r_c & a_n < r_c & (forall B_l:block_t. forall R_l:round_t. qc_t.block(qc_l,B_l) & block_t.round(B_l,R_l) -> block_t.parent(B_pr,B_l) & round_t.succ(R_l, r_c)) & (forall R_s:round_t. round_t.succ(R_s,r_c) -> t_l < R_s)

    action optimistic_proposal_processing(b_pr:block_t) = {
        require received_proposal_o(b_pr,leader(r_c));

        require send_prepare_o_condition(b_pr);

        require block_t.cstd(b_pr);

        require ~ t_r;

        require ~ possessed_optimistic_for_round(r_c);

        possessed_optimistic_for_round(r_c) := true;

        ###### proposeOptimistic ############
        var rs := round_t.next(r_c);
        if leader(rs) = id & b_o ~= b_pr {
            var b := block_t.block(rs,b_pr);
            var m : msg;
            m.kind := msg_kind.proposal_o;
            m.block := b;
            m.src := id;

            call shim.broadcast(id, m);
        }

        ensure qc_t.block(qc_l,Bl) & block_t.round(Bl,Rl) -> block_t.parent(b_pr,Bl) & Rl < r_c;

        var m : msg;
        m.kind := msg_kind.prepare_o;
        m.block := b_pr;
        m.src := id;

        call shim.broadcast(id, m);

        a_o := r_c;
        b_o := b_pr;
    }

    function send_prepare_n_condition(B_pr:block_t, QC:qc_t) : bool
    definition send_prepare_n_condition(B_pr, QC) = block_t.round(B_pr,r_c) & a_f < r_c & t_l < r_c & (a_o < r_c  | b_o = B_pr) & (forall B:block_t. forall R:round_t. qc_t.block(QC,B) & block_t.round(B,R) -> block_t.parent(B_pr,B) & round_t.succ(R, r_c))

    action normal_proposal_processing(b_pr:block_t, qc:qc_t) = {

        require received_proposal_n(b_pr, leader(r_c));
        require received_qc(qc);
        require block_t.cstd(b_pr);
        require ~ t_r;
        require ~ possessed_normal_for_round(r_c);
        
        possessed_normal_for_round(r_c) := true;

        if some b:block_t. qc_t.block(qc,b) & ~ processed_qc(b) {
            call qc_processing(qc);
        }

        require send_prepare_n_condition(b_pr,qc);

        ensure block_t.parent(b_pr,Bp) & block_t.round(Bp,Rp) -> Rp < r_c;

        ###### proposeOptimistic ############
        var rs := round_t.next(r_c);
        if leader(rs) = id & b_o ~= b_pr{
            var b := block_t.block(rs,b_pr);
            var m : msg;
            m.kind := msg_kind.proposal_o;
            m.block := b;
            m.src := id;

            call shim.broadcast(id, m);
        }

        if send_prepare_n_condition(b_pr,qc) {
            var m : msg;
            m.kind := msg_kind.prepare_n;
            m.block := b_pr;
            m.src := id;

            call shim.broadcast(id, m);

            a_n := r_c;
        }
    }

    # This action broadcasts a normal proposal for round 1, with the genesis block as parent. Ideally, this action need not have been there; the leader of round 1 would automatically send this as part of qc_processing when it is in round 0. But all processes are initialized with round 1, so this is necessary.
    action propose_normal_r1 = {
        require round_t.succ(0,r_c);
        require leader(r_c) = id;
        require ~ sent_np_r1;

        var b := block_t.block(round_t.next(0),block_t.genesis);
        var m : msg;
        m.kind := msg_kind.proposal_n;
        m.block := b;
        m.src := id;
        m.qc := qc_t.genesis;
        call shim.broadcast(id, m);
    }

    relation timeout_condition(R:round_t)
    definition timeout_condition(R) = ~ expired_rounds(R) & r_c <= R

    action timer_expire = {
        t_r := true;

        if timeout_condition(r_c) {
            var m : msg;
            m.kind := msg_kind.timeout;
            m.round := r_c;
            m.qc := qc_l;
            m.src := id;

            call shim.broadcast(id, m);
            expired_rounds(r_c) := true;
            if (t_l < r_c) {
                t_l := r_c;
            }
        }
    }

    action timeout_sync(tc:tc_fplusone_t) = {
        require received_tc_fplusone(tc);

        require forall R:round_t. tc_fplusone_t.round(tc,R) -> ~ timeout_sync_for_round(R);

        timeout_sync_for_round(R) := timeout_sync_for_round(R) | tc_fplusone_t.round(tc,R);

        #ensure all QCs contained in tc are processed. In implementation, this is done by calling the subroutine for processing qc. Here, we constrain the environment to call qc_processing on the qcs before calling timeout_sync
        require forall N:process_index_t. forall QC:qc_t. forall B:block_t. tc_fplusone_t.to_messages(tc,N, QC) & qc_t.block(QC,B) -> processed_qc(B);
        if forall R:round_t. tc_fplusone_t.round(tc,R) -> timeout_condition(R) {
            if some tc_r:round_t. tc_fplusone_t.round(tc,tc_r) {
                var m : msg;
                m.kind := msg_kind.timeout;
                m.round := tc_r;
                m.qc := qc_l;
                m.src := id;

                call shim.broadcast(id, m);
                expired_rounds(tc_r) := true;
                if (t_l < tc_r) {
                    t_l := tc_r;
                }
            }
        }
    }

    action tc_processing(tc:tc_t) = {
        require forall R:round_t. tc_t.round(tc,R) -> ~ observed_tc_for_round(R);
        require forall N:process_index_t. forall QC:qc_t. forall B:block_t. tc_t.to_messages(tc,N,QC) & qc_t.block(QC,B)-> processed_qc(B); # this is to ensure that all QC's included in tc are processed first
        var tc_round : round_t;
        if some r:round_t. tc_t.round(tc, r) {
            tc_round := r;
        }
        observed_tc_for_round(tc_round) := true;
        var tc_round_s := round_t.next(tc_round);
        if (r_c < tc_round_s) {
            ##### proposeFallback #########
            if (id = leader(tc_round_s)) {
                if some qcp:qc_t. tc_t.maxQC(tc,qcp) {
                    if some b_qcp:block_t. qc_t.block(qcp,b_qcp) {
                        var b := block_t.block(tc_round_s,b_qcp);
                        var m : msg;
                        m.kind := msg_kind.proposal_f;
                        m.block := b;
                        m.tc := tc;
                        m.src := id;

                        call shim.broadcast(id, m);
                    }
                }
            }
        }

        ####### forward ############
        var m:msg;
        m.kind := msg_kind.tc;
        m.src := id;
        m.tc := tc;
        shim.send(id,leader(tc_round_s),m);

        ########### timeout ############
        if timeout_condition(tc_round) {
            var m : msg;
            m.kind := msg_kind.timeout;
            m.round := tc_round;
            m.qc := qc_l;
            m.src := id;

            call shim.broadcast(id, m);
            expired_rounds(tc_round) := true;
            if (t_l < tc_round) {
                t_l := tc_round;
            }
        }

        ######### advanceToRound #############
        if r_c < tc_round_s {
            r_c := tc_round_s;
            t_r := false;
        }
    }

    function send_prepare_f_condition(B_pr:block_t, TC:tc_t): bool
    definition send_prepare_f_condition(B_pr, TC) = block_t.round(B_pr,r_c) & a_n < r_c & t_l < r_c & (forall QCp:qc_t. forall B_qcp:block_t. tc_t.maxQC(TC,QCp) & qc_t.block(QCp,B_qcp) -> block_t.parent(B_pr,B_qcp)) & (forall R_tc:round_t. tc_t.round(TC,R_tc) -> round_t.succ(R_tc,r_c))

    action fallback_proposal_processing(b_pr:block_t, tc:tc_t) = {

        require received_proposal_f(b_pr, leader(r_c));
        require forall N:process_index_t. forall QC:qc_t. forall B:block_t. tc_t.to_messages(tc,N,QC) & qc_t.block(QC,B)-> processed_qc(B);
        require send_prepare_f_condition(b_pr,tc);
        require block_t.cstd(b_pr);
        require ~ t_r;
        require ~ possessed_fallback_for_round(r_c);

        possessed_fallback_for_round(r_c) := true;

        if some r:round_t. tc_t.round(tc,r) & ~ observed_tc_for_round(r) {
            call tc_processing(tc);
        }

        ###### proposeOptimistic ############
        var rs := round_t.next(r_c);
        if leader(rs) = id & b_o ~= b_pr {
            var b := block_t.block(rs,b_pr);
            var m : msg;
            m.kind := msg_kind.proposal_o;
            m.block := b;
            m.src := id;

            call shim.broadcast(id, m);
        }

        ensure tc_t.maxQC(tc,QCp) & qc_t.block(QCp,B_qcp) & block_t.round(B_qcp,Rp) -> block_t.parent(b_pr,B_qcp) & processed_qc(B_qcp) & Rp < r_c;
        
        var m : msg;
        m.kind := msg_kind.prepare_f;
        m.block := b_pr;
        m.src := id;

        call shim.broadcast(id, m);
        a_f := r_c;
    }

    action byzantine_send(m:msg) = {
        require ~ is_good(id);
        require ~ is_good(m.src);
        var dst: process_index_t;
        call shim.send(id, dst, m);
    }

    export byzantine_send
    export fallback_proposal_processing
    export normal_proposal_processing
    export optimistic_proposal_processing
    export propose_normal_r1
    export qc_processing
    export tc_processing
    export timeout_sync
    export timer_expire
} # object processor
} # module processors