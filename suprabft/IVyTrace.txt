
Isolate iso_valid_received_proposal_f:
Turning off macro_finder
type proposal_f_t
type process_index_t
type round_t
type quorum_fplusone_t
type prepare_t
type tc_t
type tc_fplusone_t
type timeout_t
type qc_t
type quorum_t
type msg
type index
type height_t
type proposal_n_t
type block_t
type msg_kind = {msg_kind.proposal_n,msg_kind.proposal_f,msg_kind.prepare,msg_kind.qc,msg_kind.timeout,msg_kind.tc,msg_kind.tcfpo}
relation tc_fplusone_t.round(V0:tc_fplusone_t,V1:round_t)
relation local_view_instance.local_view.received_proposal_f(V0:process_index_t,V1:proposal_f_t,V2:process_index_t)
function local_view_instance.local_view.r_vf(V0:process_index_t) : round_t
function msg.t(V0:msg) : timeout_t
function local_view_instance.local_view.last_committed(V0:process_index_t) : block_t
relation local_view_instance.local_view.observed_qc(V0:process_index_t,V1:block_t)
relation block_t.cstd(V0:block_t)
relation global_view_instance.qc_valid(V0:qc_t)
relation timeout_t.qc(V0:timeout_t,V1:qc_t)
relation global_view_instance.process_voted_fallback(V0:process_index_t,V1:block_t,V2:quorum_t)
function local_view_instance.local_view.r_c(V0:process_index_t) : round_t
relation global_view_instance.qc_round_in_tc(V0:qc_t,V1:round_t,V2:tc_t)
relation local_view_instance.local_view.ldc_pair(V0:process_index_t,V1:block_t,V2:block_t)
relation global_view_instance.qc_round_in_tc_fplusone(V0:qc_t,V1:round_t,V2:tc_fplusone_t)
relation local_view_instance.local_view.expired_rounds(V0:process_index_t,V1:round_t)
individual proposal_n_t.genesis : proposal_n_t
relation local_view_instance.local_view.received_proposal_n(V0:process_index_t,V1:proposal_n_t,V2:process_index_t)
relation qc_t.block(V0:qc_t,V1:block_t)
individual msg_kind.timeout : {msg_kind.proposal_n,msg_kind.proposal_f,msg_kind.prepare,msg_kind.qc,msg_kind.timeout,msg_kind.tc,msg_kind.tcfpo}
relation qc_t.quorum(V0:qc_t,V1:quorum_t)
relation block_t.round_exists(V0:block_t)
function local_view_instance.local_view.r_vn(V0:process_index_t) : round_t
relation proposal_f_t.was_constructed(V0:proposal_f_t)
function msg.prop_f(V0:msg) : proposal_f_t
individual msg_kind.proposal_f : {msg_kind.proposal_n,msg_kind.proposal_f,msg_kind.prepare,msg_kind.qc,msg_kind.timeout,msg_kind.tc,msg_kind.tcfpo}
relation block_t.parent_exists(V0:block_t)
function msg.prop_n(V0:msg) : proposal_n_t
relation global_view_instance.tc_valid(V0:tc_t)
relation local_view_instance.local_view.qc_in_tc(V0:process_index_t,V1:tc_t,V2:qc_t)
individual msg_kind.proposal_n : {msg_kind.proposal_n,msg_kind.proposal_f,msg_kind.prepare,msg_kind.qc,msg_kind.timeout,msg_kind.tc,msg_kind.tcfpo}
function msg.tc(V0:msg) : tc_t
function msg.qc(V0:msg) : qc_t
relation tc_t.timeout(V0:tc_t,V1:timeout_t)
function local_view_instance.local_view.locked(V0:process_index_t) : qc_t
relation quorum_fplusone_t.member(V0:quorum_fplusone_t,V1:process_index_t)
relation proposal_f_t.tc(V0:proposal_f_t,V1:tc_t)
individual quorum_t.genesis : quorum_t
relation is_good(V0:process_index_t)
relation tc_t.quorum(V0:tc_t,V1:quorum_t)
relation global_view_instance.successive_blocks(V0:block_t,V1:block_t)
individual block_t.genesis : block_t
relation local_view_instance.local_view.ldc(V0:process_index_t,V1:block_t)
relation global_view_instance.timeout_valid(V0:timeout_t)
relation index.succ(V0:index,V1:index)
relation local_view_instance.local_view.received_qc(V0:process_index_t,V1:qc_t)
function local_view_instance.local_view.r_pf(V0:process_index_t) : round_t
relation global_view_instance.process_voted(V0:process_index_t,V1:block_t)
relation timeout_t.was_constructed(V0:timeout_t)
relation local_view_instance.local_view.eligible_to_commit(V0:process_index_t,V1:block_t)
individual prepare_t.genesis : prepare_t
relation local_view_instance.local_view.commit_candidate(V0:process_index_t,V1:block_t)
function local_view_instance.local_view.r_c_m1(V0:process_index_t) : round_t
function global_view_instance.process_locked(V0:process_index_t) : block_t
relation local_view_instance.local_view.received_tc_fplusone(V0:process_index_t,V1:tc_fplusone_t)
relation tc_fplusone_t.timeout(V0:tc_fplusone_t,V1:timeout_t)
individual msg_kind.qc : {msg_kind.proposal_n,msg_kind.proposal_f,msg_kind.prepare,msg_kind.qc,msg_kind.timeout,msg_kind.tc,msg_kind.tcfpo}
individual msg_kind.prepare : {msg_kind.proposal_n,msg_kind.proposal_f,msg_kind.prepare,msg_kind.qc,msg_kind.timeout,msg_kind.tc,msg_kind.tcfpo}
relation block_t.round(V0:block_t,V1:round_t)
function local_view_instance.local_view.qc_for_block(V0:process_index_t,V1:block_t) : qc_t
function global_view_instance.process_in_round(V0:process_index_t) : round_t
relation prepare_t.cstd(V0:prepare_t)
relation local_view_instance.local_view.commitQUgenesis(V0:process_index_t,V1:block_t)
relation tc_fplusone_t.quorum(V0:tc_fplusone_t,V1:quorum_fplusone_t)
relation proposal_f_t.block(V0:proposal_f_t,V1:block_t)
function leader(V0:round_t) : process_index_t
function msg.kind(V0:msg) : {msg_kind.proposal_n,msg_kind.proposal_f,msg_kind.prepare,msg_kind.qc,msg_kind.timeout,msg_kind.tc,msg_kind.tcfpo}
relation local_view_instance.local_view.max_commitQ(V0:process_index_t,V1:block_t)
relation local_view_instance.local_view.timer(V0:process_index_t)
relation global_view_instance.process_voted_normal(V0:process_index_t,V1:block_t)
relation global_view_instance.process_committed(V0:process_index_t,V1:block_t)
relation tc_t.round(V0:tc_t,V1:round_t)
relation global_view_instance.proposal_n_valid(V0:proposal_n_t)
individual msg_kind.tc : {msg_kind.proposal_n,msg_kind.proposal_f,msg_kind.prepare,msg_kind.qc,msg_kind.timeout,msg_kind.tc,msg_kind.tcfpo}
relation timeout_t.round(V0:timeout_t,V1:round_t)
relation global_view_instance.process_sent_timeout(V0:process_index_t,V1:round_t,V2:qc_t)
relation local_view_instance.local_view.commitQ(V0:process_index_t,V1:block_t)
function msg.prep(V0:msg) : prepare_t
relation round_t.succ(V0:round_t,V1:round_t)
relation global_view_instance.tc_fplusone_valid(V0:tc_fplusone_t)
relation local_view_instance.local_view.received_tc(V0:process_index_t,V1:tc_t)
relation shim.sent(V0:msg,V1:process_index_t)
relation global_view_instance.proposal_f_valid(V0:proposal_f_t)
relation proposal_n_t.block(V0:proposal_n_t,V1:block_t)
relation proposal_n_t.cstd(V0:proposal_n_t)
relation block_t_conv.round_lte(V0:block_t,V1:block_t)
relation global_view_instance.process_received_normal_proposal(V0:process_index_t,V1:proposal_n_t)
relation quorum_t.member(V0:quorum_t,V1:process_index_t)
relation global_view_instance.quorum_is_subset(V0:tc_t)
relation block_t.parent(V0:block_t,V1:block_t)
relation global_view_instance.timeout_round_exists(V0:timeout_t)
relation local_view_instance.local_view.qcs_in_tc_processed(V0:process_index_t,V1:tc_t)
relation block_t.ancestor(V0:block_t,V1:block_t)
relation global_view_instance.timeout_qc_exists(V0:timeout_t)
individual qc_t.genesis : qc_t
function msg.src(V0:msg) : process_index_t
relation block_t.height(V0:block_t,V1:height_t)
relation prepare_t.block(V0:prepare_t,V1:block_t)
function local_view_instance.local_view.last_prop_n(V0:process_index_t) : block_t

axiom [global_view_instance.axiom228] exists R. round_t.succ(0,R)
property [index.spec.prop4] index.succ(X,Z) -> X < Z & ~(X < Y & Y < Z)
property [index.spec.transitivity] T:index < U & U < V -> T < V
property [index.spec.antisymmetry] ~(T:index < U & U < T)
property [index.spec.totality] T:index < U | T = U | U < T
property [index.spec.prop1] 0:index <= X
property [round_t.spec.transitivity] T:round_t < U & U < V -> T < V
property [round_t.spec.antisymmetry] ~(T:round_t < U & U < T)
property [round_t.spec.totality] T:round_t < U | T = U | U < T
property [round_t.spec.prop1] 0:round_t <= X
property [global_view_instance.prop229] global_view_instance.process_voted(N,B) | ~global_view_instance.process_voted(N,B)
property [global_view_instance.prop230] global_view_instance.proposal_f_valid(P) | ~global_view_instance.proposal_f_valid(P)
property [global_view_instance.prop231] global_view_instance.tc_valid(TC) | ~global_view_instance.tc_valid(TC)
property [local_view_instance.prop352] block_t.parent_exists(B) | ~block_t.parent_exists(B)
property [local_view_instance.prop353] global_view_instance.proposal_f_valid(P) & proposal_f_t.tc(P,TC) -> global_view_instance.tc_valid(TC)
property [lv_basic_invariants.prop393] block_t.parent_exists(B) | ~block_t.parent_exists(B)
property [lv_basic_invariants.prop394] block_t.round_exists(B) | ~block_t.round_exists(B)
conjecture [iso_valid_received_proposal_f.valid_received_proposal_f] local_view_instance.local_view.received_proposal_f(Id,P,N) -> global_view_instance.proposal_f_valid(P)
conjecture [iso_valid_received_proposal_f.invar380] forall M. shim.sent(M,D) & msg.kind(M) = msg_kind.proposal_f -> global_view_instance.proposal_f_valid(msg.prop_f(M))
definition [round_t.successor_definition] round_t.succ(X,Z) = X:round_t < Z & (forall Y. X < Y -> Z < Y | Z = Y)
definition [block_t.def76] block_t.round_exists(B) = exists R. block_t.round(B,R)
definition [block_t.def78] block_t.parent_exists(B) = exists P. block_t.parent(B,P)
definition [global_view_instance.def189] global_view_instance.process_voted(N,B) = global_view_instance.process_voted_normal(N,B) | (exists Q. global_view_instance.process_voted_fallback(N,B,Q))
definition [global_view_instance.def190] global_view_instance.qc_valid(QC) = (exists B. qc_t.block(QC,B) & block_t.cstd(B)) & (exists Q. qc_t.quorum(QC,Q)) & (forall B1,B2. qc_t.block(QC,B1) & qc_t.block(QC,B2) -> B1 = B2) & (forall Q1,Q2. qc_t.quorum(QC,Q1) & qc_t.quorum(QC,Q2) -> Q1 = Q2) & (forall N,Q,B. qc_t.quorum(QC,Q) & quorum_t.member(Q,N) & qc_t.block(QC,B) -> global_view_instance.process_voted(N,B))
definition [global_view_instance.def191] global_view_instance.timeout_round_exists(T) = exists R. timeout_t.round(T,R)
definition [global_view_instance.def192] global_view_instance.timeout_qc_exists(T) = exists QC. timeout_t.qc(T,QC) & global_view_instance.qc_valid(QC)
definition [global_view_instance.def193] global_view_instance.timeout_valid(T) = timeout_t.was_constructed(T) & global_view_instance.timeout_round_exists(T) & global_view_instance.timeout_qc_exists(T) & (forall QC. timeout_t.qc(T,QC) -> global_view_instance.qc_valid(QC)) & (forall Rt,Rq. (forall QC. (forall B. timeout_t.qc(T,QC) & qc_t.block(QC,B) & block_t.round(B,Rq) & timeout_t.round(T,Rt) -> Rq < Rt)))
definition [global_view_instance.def194] global_view_instance.qc_round_in_tc_fplusone(QC,R,TC) = exists T. tc_fplusone_t.timeout(TC,T) & timeout_t.round(T,R) & timeout_t.qc(T,QC)
definition [global_view_instance.def195] global_view_instance.tc_fplusone_valid(TC) = (exists R. tc_fplusone_t.round(TC,R)) & (exists Q. tc_fplusone_t.quorum(TC,Q)) & (exists T. tc_fplusone_t.timeout(TC,T)) & (forall R1,R2. tc_fplusone_t.round(TC,R1) & tc_fplusone_t.round(TC,R2) -> R1 = R2) & (forall Q1,Q2. tc_fplusone_t.quorum(TC,Q1) & tc_fplusone_t.quorum(TC,Q2) -> Q1 = Q2) & (forall T. tc_fplusone_t.timeout(TC,T) -> global_view_instance.timeout_valid(T)) & (forall T,R. tc_fplusone_t.timeout(TC,T) & timeout_t.round(T,R) -> tc_fplusone_t.round(TC,R)) & (forall N,Q,R. tc_fplusone_t.quorum(TC,Q) & tc_fplusone_t.round(TC,R) -> (quorum_fplusone_t.member(Q,N) -> (exists QC. global_view_instance.qc_round_in_tc_fplusone(QC,R,TC) & global_view_instance.process_sent_timeout(N,R,QC))))
definition [global_view_instance.def196] global_view_instance.qc_round_in_tc(QC,R,TC) = exists T. tc_t.timeout(TC,T) & timeout_t.round(T,R) & timeout_t.qc(T,QC)
definition [global_view_instance.def197] global_view_instance.quorum_is_subset(TC) = forall Q. (forall N. (forall Rt. (forall QC. tc_t.quorum(TC,Q) & quorum_t.member(Q,N) & is_good(N) & tc_t.round(TC,Rt) & global_view_instance.process_sent_timeout(N,Rt,QC) -> global_view_instance.qc_round_in_tc(QC,Rt,TC))))
definition [global_view_instance.def198] global_view_instance.tc_valid(TC) = (exists R. tc_t.round(TC,R)) & (exists Q. tc_t.quorum(TC,Q)) & (exists T. tc_t.timeout(TC,T)) & (forall R1,R2. tc_t.round(TC,R1) & tc_t.round(TC,R2) -> R1 = R2) & (forall Q1,Q2. tc_t.quorum(TC,Q1) & tc_t.quorum(TC,Q2) -> Q1 = Q2) & (forall T. tc_t.timeout(TC,T) -> global_view_instance.timeout_valid(T)) & (forall T,R. tc_t.timeout(TC,T) & timeout_t.round(T,R) -> tc_t.round(TC,R)) & global_view_instance.quorum_is_subset(TC) & (forall Q. (forall N. (forall Rt. tc_t.quorum(TC,Q) & quorum_t.member(Q,N) & tc_t.round(TC,Rt) -> (exists QC. global_view_instance.process_sent_timeout(N,Rt,QC) & global_view_instance.qc_round_in_tc(QC,Rt,TC)))))
definition [global_view_instance.def199] global_view_instance.proposal_f_valid(P) = proposal_f_t.was_constructed(P) & (forall TC. proposal_f_t.tc(P,TC) -> global_view_instance.tc_valid(TC)) & (forall TC. (forall Rt,R. (forall B. proposal_f_t.tc(P,TC) & proposal_f_t.block(P,B) & block_t.round(B,R) & tc_t.round(TC,Rt) -> round_t.succ(Rt,R)))) & (forall Rp,Bp,Rs,Br,Rr. proposal_f_t.block(P,Br) & block_t.parent(Br,Bp) & block_t.round(Br,Rr) & block_t.round(Bp,Rp) & round_t.succ(Rp,Rs) -> Rs < Rr)
definition [global_view_instance.def200] global_view_instance.proposal_n_valid(P) = proposal_n_t.cstd(P) & (forall Bp,Br. (forall Rp,Rr. proposal_n_t.block(P,Br) & block_t.parent(Br,Bp) & block_t.round(Br,Rr) & block_t.round(Bp,Rp) -> Br ~= block_t.genesis & round_t.succ(Rp,Rr) | Br = block_t.genesis & Rp = 0 & Rr = 0))
definition [global_view_instance.def205] global_view_instance.successive_blocks(Bp,Bc) = forall Rp,Rc. block_t.round(Bp,Rp) & block_t.round(Bc,Rc) -> round_t.succ(Rp,Rc)
definition [local_view_instance.local_view.def210(V0:process_index_t)] local_view_instance.local_view.qcs_in_tc_processed(V0,TC) = forall T. (forall QC. (forall B. tc_t.timeout(TC,T) & timeout_t.qc(T,QC) & qc_t.block(QC,B) -> local_view_instance.local_view.observed_qc(V0,B)))
definition [local_view_instance.local_view.def211(V0:process_index_t)] local_view_instance.local_view.qc_in_tc(V0,TC,QC) = exists T. tc_t.timeout(TC,T) & timeout_t.qc(T,QC)
definition [local_view_instance.local_view.def212(V0:process_index_t)] local_view_instance.local_view.ldc_pair(V0,Bp,Bc) = Bc:block_t ~= block_t.genesis & block_t.parent(Bc,Bp) & global_view_instance.successive_blocks(Bp,Bc) & local_view_instance.local_view.observed_qc(V0,Bp) & local_view_instance.local_view.commitQ(V0,Bc)
definition [local_view_instance.local_view.def213(V0:process_index_t)] local_view_instance.local_view.ldc(V0,B) = exists Bc. local_view_instance.local_view.ldc_pair(V0,B,Bc)
definition [local_view_instance.local_view.def214(V0:process_index_t)] local_view_instance.local_view.eligible_to_commit(V0,Bp) = local_view_instance.local_view.commitQ(V0,Bp) & local_view_instance.local_view.ldc(V0,Bp) & block_t.ancestor(Bp,local_view_instance.local_view.last_committed(V0)) & (forall Ba. block_t.ancestor(Bp,Ba) -> local_view_instance.local_view.commitQ(V0,Ba) | Ba = local_view_instance.local_view.last_committed(V0) | block_t.ancestor(local_view_instance.local_view.last_committed(V0),Ba))
definition [local_view_instance.local_view.def215(V0:process_index_t)] local_view_instance.local_view.commit_candidate(V0,Bp) = local_view_instance.local_view.eligible_to_commit(V0,Bp) & (forall B. (forall Rp,R. local_view_instance.local_view.eligible_to_commit(V0,B) & block_t.round(B,R) & block_t.round(Bp,Rp) -> R <= Rp))
definition [local_view_instance.local_view.def217(V0:process_index_t)] local_view_instance.local_view.commitQUgenesis(V0,B) = B:block_t = block_t.genesis | local_view_instance.local_view.commitQ(V0,B)
definition [local_view_instance.local_view.def218(V0:process_index_t)] local_view_instance.local_view.max_commitQ(V0,B) = local_view_instance.local_view.commitQUgenesis(V0,B) & (forall Bq. local_view_instance.local_view.commitQUgenesis(V0,Bq) -> block_t_conv.round_lte(Bq,B))

after init {
    {
        block_t.cstd(B) := B:block_t = block_t.genesis;
        block_t.round(B,R) := B:block_t = block_t.genesis & R:round_t = 0;
        block_t.parent(B,P) := B:block_t = block_t.genesis & P:block_t = block_t.genesis;
        block_t.ancestor(B,A) := B:block_t = block_t.genesis & A:block_t = block_t.genesis;
        block_t.height(B,H) := B:block_t = block_t.genesis & H:height_t = 0
    }
}
after init {
    {
        proposal_n_t.cstd(P) := P:proposal_n_t = proposal_n_t.genesis;
        proposal_n_t.block(P,B) := P:proposal_n_t = proposal_n_t.genesis & B:block_t = block_t.genesis
    }
}
after init {
    {
        prepare_t.cstd(P) := P:prepare_t = prepare_t.genesis;
        prepare_t.block(P,B) := P:prepare_t = prepare_t.genesis & B:block_t = block_t.genesis
    }
}
after init {
    {
        qc_t.block(qc_t.genesis,B) := B:block_t = block_t.genesis;
        qc_t.quorum(qc_t.genesis,Q) := Q:quorum_t = quorum_t.genesis
    }
}
after init {
    {
        timeout_t.was_constructed(T) := false;
        timeout_t.round(T,R) := false;
        timeout_t.qc(T,QC) := false
    }
}
after init {
    {
        proposal_f_t.was_constructed(P) := false;
        proposal_f_t.block(P,B) := false;
        proposal_f_t.tc(P,TC) := false
    }
}
after init {
    shim.sent(M,D) := false
}
after init {
    {
        call global_view_instance.process_in_round(N) := ext:round_t.next(0:round_t);
        global_view_instance.process_received_normal_proposal(N,P) := false;
        {
            
        };
        global_view_instance.process_voted_normal(N,B) := B:block_t = block_t.genesis;
        global_view_instance.process_voted_fallback(N,B,Q) := false;
        {
            
        };
        {
            
        };
        global_view_instance.process_locked(N) := block_t.genesis;
        {
            
        };
        global_view_instance.process_committed(N,B) := B:block_t = block_t.genesis;
        {
            
        };
        global_view_instance.process_sent_timeout(N,R,QC) := false;
        {
            
        }
    }
}
after init {
    {
        local_view_instance.local_view.last_committed(Yprm:V0) := block_t.genesis;
        local_view_instance.local_view.last_prop_n(Yprm:V0) := block_t.genesis;
        local_view_instance.local_view.locked(Yprm:V0) := qc_t.genesis;
        local_view_instance.local_view.r_c(Yprm:V0) := *;
        assume round_t.succ(0,local_view_instance.local_view.r_c(Yprm:V0));
        local_view_instance.local_view.r_c_m1(Yprm:V0) := 0:round_t;
        local_view_instance.local_view.timer(Yprm:V0) := false;
        local_view_instance.local_view.commitQ(Yprm:V0,B) := false;
        local_view_instance.local_view.r_vf(Yprm:V0) := 0:round_t;
        local_view_instance.local_view.r_vn(Yprm:V0) := 0:round_t;
        local_view_instance.local_view.r_pf(Yprm:V0) := 0:round_t;
        local_view_instance.local_view.received_proposal_n(Yprm:V0,P,Src) := P:proposal_n_t = proposal_n_t.genesis & Src:process_index_t = leader(0);
        local_view_instance.local_view.received_proposal_f(Yprm:V0,P,Src) := false;
        {
            
        };
        local_view_instance.local_view.received_qc(Yprm:V0,QC) := QC:qc_t = qc_t.genesis;
        {
            
        };
        local_view_instance.local_view.received_tc(Yprm:V0,TC) := false;
        local_view_instance.local_view.received_tc_fplusone(Yprm:V0,TC) := false;
        local_view_instance.local_view.observed_qc(Yprm:V0,B) := B:block_t = block_t.genesis;
        local_view_instance.local_view.qc_for_block(Yprm:V0,block_t.genesis) := qc_t.genesis;
        local_view_instance.local_view.expired_rounds(Yprm:V0,R) := false
    }
}
action ext:local_view_instance.local_view.tc_processing(prm:V0:process_index_t,tc:tc_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    local loc:0 {
        call loc:0 := ext:local_view_instance.local_view.tc_get_round(prm:V0, tc);
        local loc:tc_round {
            loc:tc_round := loc:0;
            if local_view_instance.local_view.r_c_m1(prm:V0) <= loc:tc_round & loc:tc_round > 0 {
                call ext:local_view_instance.local_view.timeout(prm:V0, loc:tc_round)
            };
            local loc:b_temp {
                local loc:0,loc:1 {
                    call loc:0 := ext:round_t.next(loc:tc_round);
                    call loc:1 := ext:round_t.next(loc:0);
                    call ext:local_view_instance.local_view.advanceToRound(prm:V0, loc:1, loc:b_temp, tc, false)
                };
                call ext:local_view_instance.local_view.proposeFR(prm:V0, tc, loc:tc_round);
                local loc:0 {
                    call loc:0 := ext:round_t.next(loc:tc_round);
                    if round_t.succ(loc:0,local_view_instance.local_view.r_c(prm:V0)) {
                        
                    }
                };
                call ext:global_view_instance.received_tc(prm:V0, tc)
            }
        }
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:proposal_n_t.get_block(p:proposal_n_t) returns(b:block_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    if some loc:p_b. proposal_n_t.block(p,loc:p_b) {
        b := loc:p_b
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:local_view_instance.local_view.timeout(prm:V0:process_index_t,r:round_t) = {
    assume round_t.succ(r,Rs) -> global_view_instance.process_in_round(prm:V0) <= Rs;
    assume r ~= 0;
    if ~local_view_instance.local_view.expired_rounds(prm:V0,r) {
        if some loc:b_max_commitQ. local_view_instance.local_view.max_commitQ(prm:V0,loc:b_max_commitQ) {
            local loc:qc_max_commitQ {
                loc:qc_max_commitQ := local_view_instance.local_view.qc_for_block(prm:V0,loc:b_max_commitQ);
                local loc:0 {
                    call loc:0 := ext:timeout_t.timeout(r, loc:qc_max_commitQ);
                    local loc:t {
                        loc:t := loc:0;
                        call ext:local_view_instance.local_view.broadcast_timeout(prm:V0, loc:t);
                        local_view_instance.local_view.expired_rounds(prm:V0,r) := true;
                        call ext:global_view_instance.timeout(prm:V0, r, loc:qc_max_commitQ)
                    }
                }
            }
        }
    }
}
action ext:block_t.get_height(b:block_t) returns(h:height_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    if some loc:b_h. block_t.height(b,loc:b_h) {
        h := loc:b_h
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:global_view_instance.enter_round(n:process_index_t,r:round_t,b:block_t,tc:tc_t,qc_observed:Boolean) = {
    global_view_instance.process_in_round(n) := r;
    if qc_observed {
        {
            
        };
        {
            
        }
    }
}
action ext:global_view_instance.timeout(n:process_index_t,r:round_t,locked:qc_t) = {
    global_view_instance.process_sent_timeout(n,r,locked) := true
}
action ext:global_view_instance.receive_normal_proposal(n:process_index_t,p:proposal_n_t) = {
    global_view_instance.process_received_normal_proposal(n,p) := true
}
action ext:block_t.get_parent(b:block_t) returns(pB:block_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    if some loc:b_pB. block_t.parent(b,loc:b_pB) {
        pB := loc:b_pB
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:global_view_instance.receive_qc(n:process_index_t,b:block_t,qc:qc_t) = {
    
}
action ext:local_view_instance.local_view.byzantine_send_prepare_n(prm:V0:process_index_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    local loc:m {
        local loc:dst {
            assume prepare_t.cstd(msg.prep(loc:m));
            assume proposal_n_t.cstd(msg.prop_n(loc:m));
            local loc:0,loc:1 {
                call loc:0 := ext:prepare_t.get_block(msg.prep(loc:m));
                call loc:1 := ext:proposal_n_t.get_block(msg.prop_n(loc:m));
                if ~is_good(msg.src(loc:m)) & msg.kind(loc:m) = msg_kind.prepare & loc:0 = loc:1 & global_view_instance.process_received_normal_proposal(msg.src(loc:m),msg.prop_n(loc:m)) {
                    call ext:shim.send(prm:V0, loc:dst, loc:m);
                    call ext:global_view_instance.vote_normal(msg.src(loc:m), msg.prop_n(loc:m))
                }
            }
        }
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:local_view_instance.local_view.byzantine_send_qc(prm:V0:process_index_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    local loc:m {
        local loc:dst {
            assume global_view_instance.qc_valid(msg.qc(loc:m));
            if ~is_good(msg.src(loc:m)) & msg.kind(loc:m) = msg_kind.qc {
                call ext:shim.send(prm:V0, loc:dst, loc:m)
            }
        }
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:local_view_instance.local_view.proposeNormal(prm:V0:process_index_t,pB:block_t) = {
    assume block_t.round(pB,Rp) -> round_t.succ(Rp,local_view_instance.local_view.r_c(prm:V0));
    if leader(local_view_instance.local_view.r_c(prm:V0)) = prm:V0 & local_view_instance.local_view.r_pf(prm:V0) < local_view_instance.local_view.r_c(prm:V0) & ~block_t.parent(local_view_instance.local_view.last_prop_n(prm:V0),pB) {
        local loc:0 {
            call loc:0 := ext:block_t.block(local_view_instance.local_view.r_c(prm:V0), pB);
            local loc:b {
                loc:b := loc:0;
                local loc:0 {
                    call loc:0 := ext:proposal_n_t.proposal_n(loc:b);
                    local loc:p {
                        loc:p := loc:0;
                        call ext:local_view_instance.local_view.broadcast_proposal_n(prm:V0, loc:p)
                    }
                }
            }
        }
    }
}
action ext:local_view_instance.local_view.proposal_n_processing(prm:V0:process_index_t,p:proposal_n_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    {
        assume ~local_view_instance.local_view.timer(prm:V0);
        local loc:0 {
            call loc:0 := ext:round_t.prev(local_view_instance.local_view.r_c(prm:V0));
            assume local_view_instance.local_view.received_proposal_n(prm:V0,p,leader(loc:0))
        };
        call ext:global_view_instance.receive_normal_proposal(prm:V0, p);
        local loc:ok {
            loc:ok := true;
            loc:ok := loc:ok & (forall B. (forall R. proposal_n_t.block(p,B) & block_t.round(B,R) -> round_t.succ(R,local_view_instance.local_view.r_c(prm:V0))));
            loc:ok := loc:ok & (forall Bp,B. proposal_n_t.block(p,B) & block_t.parent(B,Bp) -> local_view_instance.local_view.commitQ(prm:V0,Bp));
            loc:ok := loc:ok & ~local_view_instance.local_view.timer(prm:V0);
            loc:ok := loc:ok & (forall R. block_t.round(local_view_instance.local_view.last_prop_n(prm:V0),R) -> R < local_view_instance.local_view.r_c(prm:V0));
            if loc:ok {
                local loc:0 {
                    call loc:0 := ext:proposal_n_t.get_block(p);
                    call ext:local_view_instance.local_view.proposeNormal(prm:V0, loc:0)
                }
            };
            loc:ok := loc:ok & (forall B. (forall R. proposal_n_t.block(p,B) & block_t.round(B,R) -> ~local_view_instance.local_view.expired_rounds(prm:V0,R)));
            loc:ok := loc:ok & (forall B. (forall R. proposal_n_t.block(p,B) & block_t.round(B,R) -> local_view_instance.local_view.r_vn(prm:V0) < R));
            loc:ok := loc:ok & (forall B1,B2. proposal_n_t.block(p,B1) & block_t.parent(B1,B2) -> qc_t.block(local_view_instance.local_view.locked(prm:V0),B2));
            if loc:ok {
                local loc:0,loc:1 {
                    call loc:0 := ext:proposal_n_t.get_block(p);
                    call loc:1 := ext:prepare_t.prepare(loc:0);
                    call ext:local_view_instance.local_view.broadcast_prepare(prm:V0, loc:1)
                };
                call ext:global_view_instance.vote_normal(prm:V0, p);
                local_view_instance.local_view.r_vn(prm:V0) := local_view_instance.local_view.r_c(prm:V0)
            }
        }
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:local_view_instance.local_view.advanceToRound(prm:V0:process_index_t,r:round_t,b:block_t,tc:tc_t,qc_observed:Boolean) = {
    if r > local_view_instance.local_view.r_c(prm:V0) {
        local_view_instance.local_view.r_c(prm:V0) := r;
        call ext:global_view_instance.enter_round(prm:V0, r, b, tc, qc_observed);
        call local_view_instance.local_view.r_c_m1(prm:V0) := ext:round_t.prev(local_view_instance.local_view.r_c(prm:V0));
        local_view_instance.local_view.timer(prm:V0) := false;
        local loc:0,loc:1 {
            call loc:0 := ext:round_t.prev(r);
            call loc:1 := ext:round_t.prev(loc:0);
            call ext:local_view_instance.local_view.cleanup(prm:V0, loc:1)
        }
    }
    else {
        call ext:global_view_instance.enter_round(prm:V0, local_view_instance.local_view.r_c(prm:V0), b, tc, qc_observed)
    }
}
action ext:shim.proposal_n_handler.handle(dst:process_index_t,m:msg) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    {
        assume shim.sent(m,dst) & msg.kind(m) = msg_kind.proposal_n;
        local_view_instance.local_view.received_proposal_n(dst,msg.prop_n(m),msg.src(m)) := true
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:shim.broadcast(src:process_index_t,m:msg) = {
    shim.sent(m,D) := true
}
action ext:prepare_t.get_block(p:prepare_t) returns(b:block_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    if some loc:p_b. prepare_t.block(p,loc:p_b) {
        b := loc:p_b
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:local_view_instance.local_view.timeout_sync(prm:V0:process_index_t,tc:tc_fplusone_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    {
        assume local_view_instance.local_view.received_tc_fplusone(prm:V0,tc);
        assume forall T. (forall QC. (forall B. tc_fplusone_t.timeout(tc,T) & timeout_t.qc(T,QC) & qc_t.block(QC,B) -> local_view_instance.local_view.observed_qc(prm:V0,B)));
        local loc:0 {
            call loc:0 := ext:local_view_instance.local_view.tc_fplusone_get_round(prm:V0, tc);
            local loc:r {
                loc:r := loc:0;
                local loc:0 {
                    call loc:0 := ext:round_t.prev(local_view_instance.local_view.r_c(prm:V0));
                    if loc:0 <= loc:r & 0:round_t < loc:r {
                        call ext:local_view_instance.local_view.timeout(prm:V0, loc:r)
                    }
                }
            }
        }
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:global_view_instance.vote_normal(n:process_index_t,p:proposal_n_t) = {
    global_view_instance.process_voted_normal(n,B) := global_view_instance.process_voted_normal(n,B) | proposal_n_t.block(p,B)
}
action ext:local_view_instance.local_view.broadcast_proposal_n(prm:V0:process_index_t,p:proposal_n_t) = {
    local loc:m {
        msg.kind(loc:m) := msg_kind.proposal_n;
        msg.prop_n(loc:m) := p;
        msg.src(loc:m) := prm:V0;
        call ext:shim.broadcast(prm:V0, loc:m)
    }
}
action ext:local_view_instance.local_view.broadcast_qc(prm:V0:process_index_t,q:qc_t) = {
    local loc:m {
        msg.kind(loc:m) := msg_kind.qc;
        msg.qc(loc:m) := q;
        msg.src(loc:m) := prm:V0;
        call ext:shim.broadcast(prm:V0, loc:m)
    }
}
action ext:round_t.next(x:round_t) returns(y:round_t) = {
    {
        assume x < y & (x < Y -> y <= Y);
        assume round_t.succ(x,y)
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis
}
action ext:local_view_instance.local_view.tc_get_round(prm:V0:process_index_t,tc:tc_t) returns(r:round_t) = {
    if some loc:tc_r. tc_t.round(tc,loc:tc_r) {
        r := loc:tc_r
    }
}
action ext:local_view_instance.local_view.broadcast_proposal_f(prm:V0:process_index_t,p:proposal_f_t) = {
    local loc:m {
        msg.kind(loc:m) := msg_kind.proposal_f;
        msg.prop_f(loc:m) := p;
        msg.src(loc:m) := prm:V0;
        call ext:shim.broadcast(prm:V0, loc:m)
    }
}
action ext:proposal_f_t.proposal_f(b:block_t,t:tc_t) returns(p:proposal_f_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    {
        assume ~proposal_f_t.was_constructed(p);
        if some loc:p_old. proposal_f_t.block(loc:p_old,b) & proposal_f_t.tc(loc:p_old,t) {
            p := loc:p_old
        }
        else {
            proposal_f_t.block(P,B) := proposal_f_t.block(P,B) | P = p & B = b;
            proposal_f_t.tc(P,TC) := proposal_f_t.tc(P,TC) | P = p & TC = t
        };
        proposal_f_t.was_constructed(P) := proposal_f_t.was_constructed(P) | P = p
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:local_view_instance.local_view.cleanup(prm:V0:process_index_t,r:round_t) = {
    local_view_instance.local_view.expired_rounds(prm:V0,R) := local_view_instance.local_view.expired_rounds(prm:V0,R) & r < R
}
action ext:local_view_instance.local_view.qc_processing(prm:V0:process_index_t,qc:qc_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    {
        assume local_view_instance.local_view.received_qc(prm:V0,qc);
        local loc:0 {
            call loc:0 := ext:local_view_instance.local_view.qc_get_block(prm:V0, qc);
            local loc:b_qc {
                loc:b_qc := loc:0;
                if ~local_view_instance.local_view.observed_qc(prm:V0,loc:b_qc) {
                    if forall R. block_t.round(loc:b_qc,R) -> round_t.succ(R,local_view_instance.local_view.r_c(prm:V0)) {
                        call ext:local_view_instance.local_view.proposeNormal(prm:V0, loc:b_qc)
                    };
                    local_view_instance.local_view.commitQ(prm:V0,loc:b_qc) := true;
                    local_view_instance.local_view.observed_qc(prm:V0,loc:b_qc) := true;
                    local loc:0 {
                        call loc:0 := ext:local_view_instance.local_view.qc_get_block(prm:V0, qc);
                        call ext:global_view_instance.receive_qc(prm:V0, loc:0, qc)
                    };
                    local_view_instance.local_view.qc_for_block(prm:V0,loc:b_qc) := qc;
                    call ext:local_view_instance.local_view.tryLock(prm:V0, qc);
                    call ext:local_view_instance.local_view.tryCommit(prm:V0, loc:b_qc);
                    call ext:local_view_instance.local_view.broadcast_qc(prm:V0, qc);
                    local loc:tc_temp {
                        local loc:0,loc:1,loc:2 {
                            call loc:0 := ext:block_t.get_round(loc:b_qc);
                            call loc:1 := ext:round_t.next(loc:0);
                            call loc:2 := ext:round_t.next(loc:1);
                            call ext:local_view_instance.local_view.advanceToRound(prm:V0, loc:2, loc:b_qc, loc:tc_temp, true)
                        }
                    }
                }
            }
        }
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:block_t.get_round(b:block_t) returns(r:round_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    if some loc:b_r. block_t.round(b,loc:b_r) {
        r := loc:b_r
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:local_view_instance.local_view.timer_expire(prm:V0:process_index_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    {
        assume ~local_view_instance.local_view.timer(prm:V0);
        assume round_t.succ(0,R1) -> R1 < local_view_instance.local_view.r_c(prm:V0);
        local_view_instance.local_view.timer(prm:V0) := true;
        local loc:0 {
            call loc:0 := ext:round_t.prev(local_view_instance.local_view.r_c(prm:V0));
            if 0:round_t < loc:0 {
                local loc:0 {
                    call loc:0 := ext:round_t.prev(local_view_instance.local_view.r_c(prm:V0));
                    call ext:local_view_instance.local_view.timeout(prm:V0, loc:0)
                }
            }
        }
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:local_view_instance.local_view.prop_f_getMaxQC(prm:V0:process_index_t,p:proposal_f_t) returns(qc:qc_t) = {
    local loc:tcp {
        local loc:to {
            assume proposal_f_t.tc(p,loc:tcp);
            assume tc_t.timeout(loc:tcp,loc:to);
            assume timeout_t.qc(loc:to,qc);
            assume forall T. (forall QCt. (forall Bt,Br. (forall Rt,Rr. tc_t.timeout(loc:tcp,T) & timeout_t.qc(T,QCt) & qc_t.block(QCt,Bt) & block_t.round(Bt,Rt) & qc_t.block(qc,Br) & block_t.round(Br,Rr) -> Rt <= Rr)))
        }
    }
}
action ext:local_view_instance.local_view.proposal_f_get_tc(prm:V0:process_index_t,p:proposal_f_t) returns(tc:tc_t) = {
    assume global_view_instance.proposal_f_valid(p);
    if some loc:p_tc. proposal_f_t.tc(p,loc:p_tc) {
        tc := loc:p_tc
    }
}
action ext:shim.qc_handler.handle(dst:process_index_t,m:msg) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    {
        assume shim.sent(m,dst) & msg.kind(m) = msg_kind.qc;
        local_view_instance.local_view.received_qc(dst,msg.qc(m)) := true
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:local_view_instance.local_view.proposeFR(prm:V0:process_index_t,tc:tc_t,r:round_t) = {
    local loc:ok {
        loc:ok := true;
        loc:ok := loc:ok & round_t.succ(r,local_view_instance.local_view.r_c(prm:V0));
        loc:ok := loc:ok & leader(r) = prm:V0;
        if loc:ok {
            local loc:0 {
                call loc:0 := ext:local_view_instance.local_view.tc_getMaxQC(prm:V0, tc);
                local loc:qcp {
                    loc:qcp := loc:0;
                    local loc:0,loc:1 {
                        call loc:0 := ext:local_view_instance.local_view.qc_get_block(prm:V0, loc:qcp);
                        call loc:1 := ext:block_t.block(r, loc:0);
                        local loc:b {
                            loc:b := loc:1;
                            local loc:0 {
                                call loc:0 := ext:proposal_f_t.proposal_f(loc:b, tc);
                                local loc:p {
                                    loc:p := loc:0;
                                    call ext:local_view_instance.local_view.broadcast_proposal_f(prm:V0, loc:p);
                                    local_view_instance.local_view.r_pf(prm:V0) := r
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
action ext:local_view_instance.local_view.tc_get_quorum(prm:V0:process_index_t,tc:tc_t) returns(q:quorum_t) = {
    assume global_view_instance.tc_valid(tc);
    if some loc:tc_q. tc_t.quorum(tc,loc:tc_q) {
        q := loc:tc_q
    }
}
action ext:local_view_instance.local_view.proposal_f_processing(prm:V0:process_index_t,p:proposal_f_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    {
        assume ~local_view_instance.local_view.timer(prm:V0);
        local loc:0 {
            call loc:0 := round_t.prev(local_view_instance.local_view.r_c(prm:V0));
            assume local_view_instance.local_view.received_proposal_f(prm:V0,p,leader(loc:0))
        };
        assume proposal_f_t.tc(p,TC) -> local_view_instance.local_view.received_tc(prm:V0,TC) & local_view_instance.local_view.qcs_in_tc_processed(prm:V0,TC);
        call ext:global_view_instance.receive_fallback_proposal(prm:V0, p);
        local loc:0 {
            call loc:0 := ext:local_view_instance.local_view.proposal_f_get_tc(prm:V0, p);
            local loc:tcp {
                loc:tcp := loc:0;
                local loc:0 {
                    call loc:0 := ext:local_view_instance.local_view.prop_f_getMaxQC(prm:V0, p);
                    local loc:qcp {
                        loc:qcp := loc:0;
                        local loc:ok {
                            loc:ok := true;
                            loc:ok := loc:ok & ~local_view_instance.local_view.timer(prm:V0);
                            loc:ok := loc:ok & (forall B. (forall R. proposal_f_t.block(p,B) & block_t.round(B,R) -> round_t.succ(R,local_view_instance.local_view.r_c(prm:V0))));
                            loc:ok := loc:ok & (forall TC. (forall B. (forall R1,R2. proposal_f_t.tc(p,TC) & tc_t.round(TC,R1) & proposal_f_t.block(p,B) & block_t.round(B,R2) -> round_t.succ(R1,R2))));
                            loc:ok := loc:ok & (forall B1,B2. proposal_f_t.block(p,B1) & block_t.parent(B1,B2) -> qc_t.block(loc:qcp,B2));
                            if loc:ok {
                                local loc:0 {
                                    call loc:0 := ext:local_view_instance.local_view.proposal_f_get_tc(prm:V0, p);
                                    call ext:local_view_instance.local_view.tc_processing(prm:V0, loc:0)
                                };
                                local loc:0 {
                                    call loc:0 := ext:proposal_f_t.get_block(p);
                                    call ext:local_view_instance.local_view.proposeNormal(prm:V0, loc:0)
                                }
                            };
                            loc:ok := loc:ok & (forall B. (forall Rb. proposal_f_t.block(p,B) & block_t.round(B,Rb) -> ~local_view_instance.local_view.expired_rounds(prm:V0,Rb) & Rb > local_view_instance.local_view.r_vf(prm:V0)));
                            if loc:ok {
                                local loc:0,loc:1 {
                                    call loc:0 := ext:proposal_f_t.get_block(p);
                                    call loc:1 := ext:prepare_t.prepare(loc:0);
                                    call ext:local_view_instance.local_view.broadcast_prepare(prm:V0, loc:1)
                                };
                                local loc:0 {
                                    call loc:0 := ext:local_view_instance.local_view.tc_get_quorum(prm:V0, loc:tcp);
                                    call ext:global_view_instance.vote_fallback(prm:V0, p, loc:0)
                                };
                                if some loc:bpr. proposal_f_t.block(p,loc:bpr) {
                                    if some loc:r. block_t.round(loc:bpr,loc:r) {
                                        local_view_instance.local_view.r_vf(prm:V0) := loc:r
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:shim.prepare_handler.handle(dst:process_index_t,m:msg) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    {
        assume shim.sent(m,dst) & msg.kind(m) = msg_kind.prepare;
        {
            
        }
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:local_view_instance.local_view.byzantine_send_proposal_n(prm:V0:process_index_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    local loc:m {
        local loc:dst {
            assume global_view_instance.proposal_n_valid(msg.prop_n(loc:m));
            if ~is_good(msg.src(loc:m)) & msg.kind(loc:m) = msg_kind.proposal_n {
                call ext:shim.send(prm:V0, loc:dst, loc:m)
            }
        }
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:local_view_instance.local_view.tc_getMaxQC(prm:V0:process_index_t,tc:tc_t) returns(qc:qc_t) = {
    assume global_view_instance.tc_valid(tc);
    assume exists T. global_view_instance.timeout_valid(T) & tc_t.timeout(tc,T) & timeout_t.qc(T,qc);
    assume forall T. (forall QC. (forall B1,B2. (forall R1,R2. global_view_instance.timeout_valid(T) & tc_t.timeout(tc,T) & timeout_t.qc(T,QC) & qc_t.block(QC,B1) & block_t.round(B1,R1) & qc_t.block(qc,B2) & block_t.round(B2,R2) -> R2 >= R1)))
}
action ext:local_view_instance.local_view.byzantine_send_proposal_f(prm:V0:process_index_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    local loc:m {
        local loc:dst {
            assume global_view_instance.proposal_f_valid(msg.prop_f(loc:m));
            if ~is_good(msg.src(loc:m)) & msg.kind(loc:m) = msg_kind.proposal_f {
                call ext:shim.send(prm:V0, loc:dst, loc:m)
            }
        }
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:local_view_instance.local_view.tc_fplusone_get_round(prm:V0:process_index_t,tc:tc_fplusone_t) returns(r:round_t) = {
    assume global_view_instance.tc_fplusone_valid(tc);
    if some loc:tc_r. tc_fplusone_t.round(tc,loc:tc_r) {
        r := loc:tc_r
    }
}
action ext:shim.send(src:process_index_t,dst:process_index_t,m:msg) = {
    shim.sent(m,dst) := true
}
action ext:block_t.block(r_c:round_t,pB:block_t) returns(b:block_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    {
        assume ~block_t.cstd(b);
        block_t.round(b,R) := R:round_t = r_c;
        local loc:0,loc:1 {
            call loc:0 := ext:block_t.get_height(pB);
            call loc:1 := ext:height_t.next(loc:0);
            block_t.height(B,H) := block_t.height(B,H) | B = b & H = loc:1
        };
        block_t.cstd(b) := true;
        block_t.parent(b,B) := B:block_t = pB;
        block_t.ancestor(b,pB) := true;
        block_t.ancestor(b,B) := block_t.ancestor(pB,B) | B = pB
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:global_view_instance.receive_fallback_proposal(n:process_index_t,p:proposal_f_t) = {
    
}
action ext:local_view_instance.local_view.tryLock(prm:V0:process_index_t,qc:qc_t) = {
    local loc:0 {
        call loc:0 := ext:local_view_instance.local_view.qc_get_round(prm:V0, qc);
        local loc:r {
            loc:r := loc:0;
            local loc:0 {
                call loc:0 := ext:round_t.next(loc:r);
                if (forall Bl. (forall Rl. qc_t.block(local_view_instance.local_view.locked(prm:V0),Bl) & block_t.round(Bl,Rl) -> loc:r > Rl)) & ~local_view_instance.local_view.expired_rounds(prm:V0,loc:r) & local_view_instance.local_view.r_c(prm:V0) <= loc:0 {
                    local_view_instance.local_view.locked(prm:V0) := qc;
                    local loc:0 {
                        call loc:0 := ext:local_view_instance.local_view.qc_get_block(prm:V0, qc);
                        call ext:global_view_instance.lock(prm:V0, loc:0, qc)
                    }
                }
            }
        }
    }
}
action ext:height_t.next(x:height_t) returns(y:height_t) = {
    
}
action ext:shim.timeout_handler.handle(dst:process_index_t,m:msg) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    {
        assume shim.sent(m,dst) & msg.kind(m) = msg_kind.timeout;
        {
            
        };
        local loc:0 {
            call loc:0 := ext:local_view_instance.local_view.timeout_get_qc(dst, msg.t(m));
            local_view_instance.local_view.received_qc(dst,loc:0) := true
        }
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:local_view_instance.local_view.broadcast_prepare(prm:V0:process_index_t,p:prepare_t) = {
    local loc:m {
        msg.kind(loc:m) := msg_kind.prepare;
        msg.prep(loc:m) := p;
        msg.src(loc:m) := prm:V0;
        call ext:shim.broadcast(prm:V0, loc:m)
    }
}
action ext:global_view_instance.vote_fallback(n:process_index_t,p:proposal_f_t,q:quorum_t) = {
    global_view_instance.process_voted_fallback(n,B,q) := global_view_instance.process_voted_fallback(n,B,q) | proposal_f_t.block(p,B)
}
action ext:proposal_n_t.proposal_n(b:block_t) returns(p:proposal_n_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    {
        assume ~proposal_n_t.cstd(p);
        if some loc:p_old. proposal_n_t.block(loc:p_old,b) {
            p := loc:p_old
        }
        else {
            proposal_n_t.block(P,B) := proposal_n_t.block(P,B) | P = p & B = b
        };
        proposal_n_t.cstd(P) := proposal_n_t.cstd(P) | P = p
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:local_view_instance.local_view.byzantine_send_timeout(prm:V0:process_index_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    local loc:m {
        local loc:dst {
            assume global_view_instance.timeout_valid(msg.t(loc:m));
            if ~is_good(msg.src(loc:m)) & msg.kind(loc:m) = msg_kind.timeout {
                call ext:shim.send(prm:V0, loc:dst, loc:m);
                local loc:0,loc:1 {
                    call loc:0 := ext:timeout_t.get_round(msg.t(loc:m));
                    call loc:1 := ext:local_view_instance.local_view.timeout_get_qc(prm:V0, msg.t(loc:m));
                    call ext:global_view_instance.timeout(msg.src(loc:m), loc:0, loc:1)
                }
            }
        }
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:timeout_t.get_round(t:timeout_t) returns(r:round_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    if some loc:t_r. timeout_t.round(t,loc:t_r) {
        r := loc:t_r
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:global_view_instance.received_tc(n:process_index_t,tc:tc_t) = {
    
}
action ext:proposal_f_t.get_block(p:proposal_f_t) returns(b:block_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    if some loc:p_b. proposal_f_t.block(p,loc:p_b) {
        b := loc:p_b
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:local_view_instance.local_view.broadcast_timeout(prm:V0:process_index_t,t:timeout_t) = {
    local loc:m {
        msg.kind(loc:m) := msg_kind.timeout;
        msg.t(loc:m) := t;
        msg.src(loc:m) := prm:V0;
        call ext:shim.broadcast(prm:V0, loc:m)
    }
}
action ext:shim.tc_handler.handle(dst:process_index_t,m:msg) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    {
        assume shim.sent(m,dst) & msg.kind(m) = msg_kind.tc;
        local_view_instance.local_view.received_tc(dst,msg.tc(m)) := true;
        local_view_instance.local_view.received_qc(dst,QC) := local_view_instance.local_view.received_qc(dst,QC) | local_view_instance.local_view.qc_in_tc(dst,msg.tc(m),QC)
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:local_view_instance.local_view.tryCommit(prm:V0:process_index_t,b_qc:block_t) = {
    if some loc:bp. local_view_instance.local_view.commit_candidate(prm:V0,loc:bp) {
        call ext:global_view_instance.commit(prm:V0, loc:bp, local_view_instance.local_view.last_committed(prm:V0));
        local_view_instance.local_view.last_committed(prm:V0) := loc:bp;
        local_view_instance.local_view.commitQ(prm:V0,B) := local_view_instance.local_view.commitQ(prm:V0,B) & block_t.ancestor(B,local_view_instance.local_view.last_committed(prm:V0))
    }
}
action ext:local_view_instance.local_view.qc_get_round(prm:V0:process_index_t,qc:qc_t) returns(r:round_t) = {
    assume global_view_instance.qc_valid(qc);
    if some loc:qc_b. qc_t.block(qc,loc:qc_b) {
        call r := ext:block_t.get_round(loc:qc_b)
    }
}
action ext:local_view_instance.local_view.timeout_get_qc(prm:V0:process_index_t,t:timeout_t) returns(qc:qc_t) = {
    assume global_view_instance.timeout_valid(t);
    if some loc:t_qc. timeout_t.qc(t,loc:t_qc) {
        qc := loc:t_qc
    }
}
action ext:local_view_instance.local_view.byzantine_send_tc(prm:V0:process_index_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    local loc:m {
        local loc:dst {
            assume global_view_instance.tc_valid(msg.tc(loc:m));
            if ~is_good(msg.src(loc:m)) & msg.kind(loc:m) = msg_kind.tc {
                call ext:shim.send(prm:V0, loc:dst, loc:m)
            }
        }
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:shim.proposal_f_handler.handle(dst:process_index_t,m:msg) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    {
        assume shim.sent(m,dst) & msg.kind(m) = msg_kind.proposal_f;
        local_view_instance.local_view.received_proposal_f(dst,msg.prop_f(m),msg.src(m)) := true;
        local loc:0 {
            call loc:0 := ext:local_view_instance.local_view.proposal_f_get_tc(dst, msg.prop_f(m));
            local loc:temp_tc {
                loc:temp_tc := loc:0;
                local_view_instance.local_view.received_tc(dst,loc:temp_tc) := true;
                local_view_instance.local_view.received_qc(dst,QC) := local_view_instance.local_view.received_qc(dst,QC) | local_view_instance.local_view.qc_in_tc(dst,loc:temp_tc,QC)
            }
        }
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:timeout_t.timeout(r:round_t,q:qc_t) returns(t:timeout_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    {
        assume ~timeout_t.was_constructed(t);
        if some loc:t_old. timeout_t.round(loc:t_old,r) & timeout_t.qc(loc:t_old,q) {
            t := loc:t_old
        }
        else {
            timeout_t.round(T,R) := timeout_t.round(T,R) | T = t & R = r;
            timeout_t.qc(T,QC) := timeout_t.qc(T,QC) | T = t & QC = q
        };
        timeout_t.was_constructed(T) := timeout_t.was_constructed(T) | T = t
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:global_view_instance.commit(n:process_index_t,commit_candidate:block_t,last_committed:block_t) = {
    global_view_instance.process_committed(n,B) := global_view_instance.process_committed(n,B) | B = commit_candidate | block_t.ancestor(commit_candidate,B) & block_t.ancestor(B,last_committed);
    {
        
    }
}
action ext:round_t.prev(x:round_t) returns(y:round_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    {
        assume 0:round_t < x;
        assume y < x & (Y:round_t < x -> Y <= y);
        assume round_t.succ(y,x)
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:local_view_instance.local_view.byzantine_send_prepare_f(prm:V0:process_index_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    local loc:m {
        local loc:dst {
            assume prepare_t.cstd(msg.prep(loc:m));
            assume proposal_f_t.was_constructed(msg.prop_f(loc:m));
            local loc:0,loc:1 {
                call loc:0 := ext:prepare_t.get_block(msg.prep(loc:m));
                call loc:1 := ext:proposal_f_t.get_block(msg.prop_f(loc:m));
                if ~is_good(msg.src(loc:m)) & msg.kind(loc:m) = msg_kind.prepare & loc:0 = loc:1 & global_view_instance.proposal_f_valid(msg.prop_f(loc:m)) {
                    local loc:q {
                        assume proposal_f_t.tc(msg.prop_f(loc:m),TC) -> tc_t.quorum(TC,loc:q);
                        call ext:shim.send(prm:V0, loc:dst, loc:m);
                        call ext:global_view_instance.vote_fallback(msg.src(loc:m), msg.prop_f(loc:m), loc:q)
                    }
                }
            }
        }
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:local_view_instance.local_view.qc_get_block(prm:V0:process_index_t,qc:qc_t) returns(b:block_t) = {
    assume global_view_instance.qc_valid(qc);
    if some loc:qc_b. qc_t.block(qc,loc:qc_b) {
        b := loc:qc_b
    }
}
action ext:global_view_instance.lock(n:process_index_t,b:block_t,qc:qc_t) = {
    global_view_instance.process_locked(n) := b
}
action round_t.prev(x:round_t) returns(y:round_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    {
        assume 0:round_t < x;
        assume y < x & (Y:round_t < x -> Y <= y);
        assume round_t.succ(y,x)
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
action ext:prepare_t.prepare(b:block_t) returns(p:prepare_t) = {
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis;
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked(Id));
    assume global_view_instance.process_in_round(Id) = local_view_instance.local_view.r_c(Id);
    assume qc_t.block(local_view_instance.local_view.locked(Id),global_view_instance.process_locked_completely(Id));
    assume local_view_instance.local_view.locked(Id) ~= qc_t.genesis & qc_t.block(local_view_instance.local_view.locked(Id),B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> R < Rp;
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.qc_valid(local_view_instance.local_view.qc_for_block(Id,B)) & qc_t.block(local_view_instance.local_view.qc_for_block(Id,B),B);
    assume forall Rp,R. (forall QC. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) & Rp <= R -> local_view_instance.local_view.expired_rounds(Id,R));
    assume local_view_instance.local_view.timer(Id) & round_t.succ(Rp,local_view_instance.local_view.r_c(Id)) -> (exists QC. global_view_instance.process_sent_timeout(Id,Rp,QC));
    assume round_t.succ(R1,R2) | ~round_t.succ(R1,R2);
    assume is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view.r_vn(Id);
    assume forall R. local_view_instance.local_view.expired_rounds(Id,R) -> (exists QC. global_view_instance.process_sent_timeout(Id,R,QC));
    assume local_view_instance.local_view.observed_qc(Id,B) -> global_view_instance.process_received_qc(Id,B) & block_t.cstd(B);
    {
        assume ~prepare_t.cstd(p);
        if some loc:p_old. prepare_t.block(loc:p_old,b) {
            p := loc:p_old
        }
        else {
            prepare_t.block(P,B) := prepare_t.block(P,B) | P = p & B = b
        };
        prepare_t.cstd(P) := prepare_t.cstd(P) | P = p
    };
    assume block_t.cstd(B) -> (exists H. block_t.height(B,H));
    assume block_t.cstd(B) -> block_t.parent_exists(B);
    assume block_t.cstd(B) -> block_t.round_exists(B);
    assume block_t.ancestor(B,A) -> block_t.cstd(B) & block_t.cstd(A);
    assume block_t.height(B,H) -> block_t.cstd(B);
    assume block_t.round(B,R) -> block_t.cstd(B);
    assume block_t.parent(B,P) -> block_t.cstd(B) & block_t.cstd(P);
    assume block_t.parent(B,B) <-> B = block_t.genesis;
    assume block_t.ancestor(B,B) <-> B = block_t.genesis;
    assume block_t.height(B,H1) & block_t.height(B,H2) -> H1 = H2;
    assume block_t.parent(B,P1) & block_t.parent(B,P2) -> P1 = P2;
    assume block_t.round(B,R1) & block_t.round(B,R2) -> R1 = R2;
    assume block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis -> height_t.succ(Hp,Hb);
    assume block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis -> Rp < Rb;
    assume block_t.cstd(block_t.genesis);
    assume block_t.parent(block_t.genesis,P) <-> P = block_t.genesis;
    assume block_t.round(B,0) <-> B = block_t.genesis;
    assume block_t.height(B,0) <-> B = block_t.genesis;
    assume block_t.ancestor(block_t.genesis,A) <-> A = block_t.genesis;
    assume proposal_n_t.cstd(P) -> (exists B. proposal_n_t.block(P,B));
    assume proposal_n_t.block(P,B) -> proposal_n_t.cstd(P) & block_t.cstd(B);
    assume proposal_n_t.block(P1,B) & proposal_n_t.block(P2,B) -> P1 = P2;
    assume proposal_n_t.block(proposal_n_t.genesis,B) <-> B = block_t.genesis;
    assume proposal_n_t.cstd(proposal_n_t.genesis);
    assume proposal_n_t.block(P,B1) & proposal_n_t.block(P,B2) -> B1 = B2;
    assume prepare_t.cstd(P) -> (exists B. prepare_t.block(P,B));
    assume prepare_t.block(P,B1) & prepare_t.block(P,B2) -> B1 = B2;
    assume prepare_t.block(prepare_t.genesis,B) <-> B = block_t.genesis;
    assume prepare_t.block(P,B) -> prepare_t.cstd(P) & block_t.cstd(B);
    assume prepare_t.block(P1,B) & prepare_t.block(P2,B) -> P1 = P2;
    assume prepare_t.cstd(prepare_t.genesis);
    assume timeout_t.qc(T,QC1) & timeout_t.qc(T,QC2) -> QC1 = QC2;
    assume timeout_t.round(T,R1) & timeout_t.round(T,R2) -> R1 = R2;
    assume timeout_t.was_constructed(T) -> (exists R. timeout_t.round(T,R));
    assume timeout_t.qc(T,QC) -> timeout_t.was_constructed(T);
    assume timeout_t.round(T,R) -> timeout_t.was_constructed(T);
    assume timeout_t.was_constructed(T) -> (exists QC. timeout_t.qc(T,QC));
    assume proposal_f_t.block(P,B1) & proposal_f_t.block(P,B2) -> B1 = B2;
    assume proposal_f_t.tc(P,TC1) & proposal_f_t.tc(P,TC2) -> TC1 = TC2;
    assume proposal_f_t.block(P,B) -> proposal_f_t.was_constructed(P) & block_t.cstd(B);
    assume proposal_f_t.tc(P,TC) -> proposal_f_t.was_constructed(P);
    assume proposal_f_t.was_constructed(P) -> (exists B. proposal_f_t.block(P,B));
    assume proposal_f_t.was_constructed(P) -> (exists TC. proposal_f_t.tc(P,TC));
    assume qc_t.quorum(qc_t.genesis,Q) <-> Q = quorum_t.genesis;
    assume qc_t.block(qc_t.genesis,B) <-> B = block_t.genesis
}
export ext:block_t.block
export ext:block_t.get_height
export ext:block_t.get_parent
export ext:block_t.get_round
export ext:local_view_instance.local_view.byzantine_send_prepare_f
export ext:local_view_instance.local_view.byzantine_send_prepare_n
export ext:local_view_instance.local_view.byzantine_send_proposal_f
export ext:local_view_instance.local_view.byzantine_send_proposal_n
export ext:local_view_instance.local_view.byzantine_send_qc
export ext:local_view_instance.local_view.byzantine_send_tc
export ext:local_view_instance.local_view.byzantine_send_timeout
export ext:local_view_instance.local_view.proposal_f_processing
export ext:local_view_instance.local_view.proposal_n_processing
export ext:local_view_instance.local_view.qc_processing
export ext:local_view_instance.local_view.tc_processing
export ext:local_view_instance.local_view.timeout_sync
export ext:local_view_instance.local_view.timer_expire
export ext:prepare_t.get_block
export ext:prepare_t.prepare
export ext:proposal_f_t.get_block
export ext:proposal_f_t.proposal_f
export ext:proposal_n_t.get_block
export ext:proposal_n_t.proposal_n
export ext:shim.prepare_handler.handle
export ext:shim.proposal_f_handler.handle
export ext:shim.proposal_n_handler.handle
export ext:shim.qc_handler.handle
export ext:shim.tc_handler.handle
export ext:shim.timeout_handler.handle
export ext:timeout_t.get_round
export ext:timeout_t.timeout

    The following properties are assumed as axioms:
        safety.ivy: line 9: global_view_instance.axiom228

    The following definitions are used:
        ubd_seq.ivy: line 18: round_t.successor_definition
        types.ivy: line 101: block_t.def76
        types.ivy: line 104: block_t.def78
        global_view.ivy: line 46: global_view_instance.def189
        global_view.ivy: line 55: global_view_instance.def190
        global_view.ivy: line 63: global_view_instance.def191
        global_view.ivy: line 65: global_view_instance.def192
        global_view.ivy: line 67: global_view_instance.def193
        global_view.ivy: line 72: global_view_instance.def194
        global_view.ivy: line 75: global_view_instance.def195
        global_view.ivy: line 87: global_view_instance.def196
        global_view.ivy: line 90: global_view_instance.def197
        global_view.ivy: line 93: global_view_instance.def198
        global_view.ivy: line 105: global_view_instance.def199
        global_view.ivy: line 110: global_view_instance.def200
        global_view.ivy: line 126: global_view_instance.def205
        local_view.ivy: line 36: local_view_instance.local_view.def210(V0:process_index_t)
        local_view.ivy: line 40: local_view_instance.local_view.def211(V0:process_index_t)
        local_view.ivy: line 43: local_view_instance.local_view.def212(V0:process_index_t)
        local_view.ivy: line 46: local_view_instance.local_view.def213(V0:process_index_t)
        local_view.ivy: line 49: local_view_instance.local_view.def214(V0:process_index_t)
        local_view.ivy: line 52: local_view_instance.local_view.def215(V0:process_index_t)
        local_view.ivy: line 58: local_view_instance.local_view.def217(V0:process_index_t)
        local_view.ivy: line 61: local_view_instance.local_view.def218(V0:process_index_t)

    The following properties are to be checked:
        /Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 33: index.spec.prop4  [assumed]
        /Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 4: index.spec.transitivity  [assumed]
        /Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 5: index.spec.antisymmetry  [assumed]
        /Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 6: index.spec.totality  [assumed]
        /Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 11: index.spec.prop1  [assumed]
        /Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 4: round_t.spec.transitivity  [assumed]
        /Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 5: round_t.spec.antisymmetry  [assumed]
        /Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 6: round_t.spec.totality  [assumed]
        /Users/praveenm/Documents/Praveen/Installations/ivy/ivy/include/1.8/order.ivy: line 11: round_t.spec.prop1  [assumed]
        safety.ivy: line 15: global_view_instance.prop229  [assumed]
        safety.ivy: line 16: global_view_instance.prop230  [assumed]
        safety.ivy: line 17: global_view_instance.prop231  [assumed]
        safety.ivy: line 659: local_view_instance.prop352  [assumed]
        safety.ivy: line 660: local_view_instance.prop353  [assumed]
        safety.ivy: line 850: lv_basic_invariants.prop393  [assumed]
        safety.ivy: line 851: lv_basic_invariants.prop394  [assumed]

    The inductive invariant consists of the following conjectures:
        safety.ivy: line 806: iso_valid_received_proposal_f.valid_received_proposal_f
        safety.ivy: line 807: iso_valid_received_proposal_f.invar380

    The following action implementations are present:
        types.ivy: line 70: implementation of block_t.block
        types.ivy: line 65: implementation of block_t.get_height
        types.ivy: line 58: implementation of block_t.get_parent
        types.ivy: line 51: implementation of block_t.get_round
        global_view.ivy: line 198: implementation of global_view_instance.commit
        global_view.ivy: line 153: implementation of global_view_instance.enter_round
        global_view.ivy: line 195: implementation of global_view_instance.lock
        global_view.ivy: line 172: implementation of global_view_instance.receive_fallback_proposal
        global_view.ivy: line 166: implementation of global_view_instance.receive_normal_proposal
        global_view.ivy: line 190: implementation of global_view_instance.receive_qc
        global_view.ivy: line 213: implementation of global_view_instance.received_tc
        global_view.ivy: line 207: implementation of global_view_instance.timeout
        global_view.ivy: line 184: implementation of global_view_instance.vote_fallback
        global_view.ivy: line 178: implementation of global_view_instance.vote_normal
        local_view.ivy: line 212: implementation of local_view_instance.local_view.advanceToRound
        local_view.ivy: line 164: implementation of local_view_instance.local_view.broadcast_prepare
        local_view.ivy: line 155: implementation of local_view_instance.local_view.broadcast_proposal_f
        local_view.ivy: line 146: implementation of local_view_instance.local_view.broadcast_proposal_n
        local_view.ivy: line 173: implementation of local_view_instance.local_view.broadcast_qc
        local_view.ivy: line 182: implementation of local_view_instance.local_view.broadcast_timeout
        local_view.ivy: line 461: implementation of local_view_instance.local_view.byzantine_send_prepare_f
        local_view.ivy: line 447: implementation of local_view_instance.local_view.byzantine_send_prepare_n
        local_view.ivy: line 425: implementation of local_view_instance.local_view.byzantine_send_proposal_f
        local_view.ivy: line 436: implementation of local_view_instance.local_view.byzantine_send_proposal_n
        local_view.ivy: line 477: implementation of local_view_instance.local_view.byzantine_send_qc
        local_view.ivy: line 500: implementation of local_view_instance.local_view.byzantine_send_tc
        local_view.ivy: line 488: implementation of local_view_instance.local_view.byzantine_send_timeout
        local_view.ivy: line 200: implementation of local_view_instance.local_view.cleanup
        local_view.ivy: line 390: implementation of local_view_instance.local_view.prop_f_getMaxQC
        local_view.ivy: line 128: implementation of local_view_instance.local_view.proposal_f_get_tc
        local_view.ivy: line 353: implementation of local_view_instance.local_view.proposal_f_processing
        local_view.ivy: line 262: implementation of local_view_instance.local_view.proposal_n_processing
        local_view.ivy: line 289: implementation of local_view_instance.local_view.proposeFR
        local_view.ivy: line 204: implementation of local_view_instance.local_view.proposeNormal
        local_view.ivy: line 140: implementation of local_view_instance.local_view.qc_get_block
        local_view.ivy: line 413: implementation of local_view_instance.local_view.qc_get_round
        local_view.ivy: line 241: implementation of local_view_instance.local_view.qc_processing
        local_view.ivy: line 106: implementation of shim.prepare_handler.handle
        local_view.ivy: line 98: implementation of shim.proposal_f_handler.handle
        local_view.ivy: line 95: implementation of shim.proposal_n_handler.handle
        local_view.ivy: line 110: implementation of shim.qc_handler.handle
        local_view.ivy: line 118: implementation of shim.tc_handler.handle
        local_view.ivy: line 113: implementation of shim.timeout_handler.handle
        local_view.ivy: line 419: implementation of local_view_instance.local_view.tc_fplusone_get_round
        local_view.ivy: line 383: implementation of local_view_instance.local_view.tc_getMaxQC
        local_view.ivy: line 407: implementation of local_view_instance.local_view.tc_get_quorum
        local_view.ivy: line 401: implementation of local_view_instance.local_view.tc_get_round
        local_view.ivy: line 337: implementation of local_view_instance.local_view.tc_processing
        local_view.ivy: line 307: implementation of local_view_instance.local_view.timeout
        local_view.ivy: line 134: implementation of local_view_instance.local_view.timeout_get_qc
        local_view.ivy: line 327: implementation of local_view_instance.local_view.timeout_sync
        local_view.ivy: line 318: implementation of local_view_instance.local_view.timer_expire
        local_view.ivy: line 234: implementation of local_view_instance.local_view.tryCommit
        local_view.ivy: line 225: implementation of local_view_instance.local_view.tryLock
        types.ivy: line 237: implementation of prepare_t.get_block
        types.ivy: line 242: implementation of prepare_t.prepare
        types.ivy: line 390: implementation of proposal_f_t.get_block
        types.ivy: line 395: implementation of proposal_f_t.proposal_f
        types.ivy: line 192: implementation of proposal_n_t.get_block
        types.ivy: line 197: implementation of proposal_n_t.proposal_n
        types.ivy: line 329: implementation of timeout_t.get_round
        types.ivy: line 334: implementation of timeout_t.timeout

    The following action monitors are present:
        safety.ivy: line 710: monitor of local_view_instance.local_view.proposal_f_get_tc
        safety.ivy: line 742: monitor of local_view_instance.local_view.proposal_f_processing
        safety.ivy: line 722: monitor of local_view_instance.local_view.proposeNormal
        safety.ivy: line 718: monitor of local_view_instance.local_view.qc_get_block
        safety.ivy: line 759: monitor of local_view_instance.local_view.qc_get_round
        safety.ivy: line 763: monitor of local_view_instance.local_view.tc_fplusone_get_round
        safety.ivy: line 751: monitor of local_view_instance.local_view.tc_getMaxQC
        safety.ivy: line 755: monitor of local_view_instance.local_view.tc_get_quorum
        safety.ivy: line 725: monitor of local_view_instance.local_view.timeout
        safety.ivy: line 714: monitor of local_view_instance.local_view.timeout_get_qc
        safety.ivy: line 735: monitor of local_view_instance.local_view.timeout_sync
        safety.ivy: line 730: monitor of local_view_instance.local_view.timer_expire
        ubd_seq.ivy: line 33: monitor of round_t.next
        ubd_seq.ivy: line 40: monitor of round_t.prev
        ubd_seq.ivy: line 38: monitor of round_t.prev
        network.ivy: line 58: monitor of shim.broadcast
        network.ivy: line 35: monitor of shim.prepare_handler.handle
        network.ivy: line 35: monitor of shim.proposal_f_handler.handle
        network.ivy: line 35: monitor of shim.proposal_n_handler.handle
        network.ivy: line 35: monitor of shim.qc_handler.handle
        network.ivy: line 61: monitor of shim.send
        network.ivy: line 35: monitor of shim.tc_handler.handle
        network.ivy: line 35: monitor of shim.timeout_handler.handle

    The following initializers are present:
        types.ivy: line 41: block_t.init[after64]
        global_view.ivy: line 137: global_view_instance.init[after209]
        local_view.ivy: line 66: local_view_instance.local_view.init[after220]
        types.ivy: line 229: prepare_t.init[after108]
        types.ivy: line 381: proposal_f_t.init[after129]
        types.ivy: line 184: proposal_n_t.init[after101]
        types.ivy: line 303: qc_t.init[after119]
        network.ivy: line 55: shim.init[after182]
        types.ivy: line 320: timeout_t.init[after122]

    Initialization must establish the invariant
        safety.ivy: line 806: iso_valid_received_proposal_f.valid_received_proposal_f ... PASS
        safety.ivy: line 807: iso_valid_received_proposal_f.invar380 ... PASS

    Any assertions in initializers must be checked ... PASS

    The following set of external actions must preserve the invariant:
        (internal) ext:block_t.block
            safety.ivy: line 806: iso_valid_received_proposal_f.valid_received_proposal_f ... PASS
            safety.ivy: line 807: iso_valid_received_proposal_f.invar380 ... PASS
        (internal) ext:block_t.get_height
            safety.ivy: line 806: iso_valid_received_proposal_f.valid_received_proposal_f ... PASS
            safety.ivy: line 807: iso_valid_received_proposal_f.invar380 ... PASS
        (internal) ext:block_t.get_parent
            safety.ivy: line 806: iso_valid_received_proposal_f.valid_received_proposal_f ... PASS
            safety.ivy: line 807: iso_valid_received_proposal_f.invar380 ... PASS
        (internal) ext:block_t.get_round
            safety.ivy: line 806: iso_valid_received_proposal_f.valid_received_proposal_f ... PASS
            safety.ivy: line 807: iso_valid_received_proposal_f.invar380 ... PASS
        (internal) ext:local_view_instance.local_view.byzantine_send_prepare_f
            safety.ivy: line 806: iso_valid_received_proposal_f.valid_received_proposal_f ...