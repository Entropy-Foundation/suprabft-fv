#lang ivy1.8

# definition succ(X,Y) = (Y = X + 1)

include domain_model
include network_model

module supraBFT(global_view) = {
object validator(id:node_t) = {
    individual locked : cert_t
    individual voted : voted_t
    individual r_c : round_t

    individual timed_out : bool

    function blockchain (H:height_t) : block_t
    individual chain_size : height_t

    relation rcvd_proposal(P:proposal_t, Src:node_t)
    relation rcvd_prepare(B:block_t, Src:node_t)
    relation rcvd_qc(Qc:cert_t)
    relation rcvd_timeout(T:timeout_t, Src:node_t)
    relation rcvd_tc(Tc:timeout_cert_t)

    relation store_forest(Qc:cert_t,H:height_t)
    relation forest_ancestor(Qd:cert_t,Hd:height_t,Qa:cert_t,Ha:height_t) #Qa is an ancestor of Qd
    relation forest_strictAncestor(Qd:cert_t,Hd:height_t,Qa:cert_t,Ha:height_t)
    relation forest_root(Q:cert_t,H:height_t)
    relation forest_leaf(Q:cert_t,H:height_t)
    relation forest_succ(Qd:cert_t,Hd:height_t,Qa:cert_t,Ha:height_t)

    definition forest_strictAncestor(Qd, Hd, Qa, Ha) = store_forest(Qd, Hd) & store_forest(Qa, Ha) & forest_ancestor(Qd, Hd, Qa, Ha) & Qd ~= Qa
    definition forest_root(Q, H) = store_forest(Q, H) & forall Qa:cert_t. forall Ha:height_t. ~forest_strictAncestor(Q, H, Qa, Ha)
    definition forest_leaf(Q, H) = store_forest(Q, H) & forall Qd:cert_t. forall Hd:height_t. ~forest_strictAncestor(Qd, Hd, Q, H)
    definition forest_succ(Qd, Hd, Qa, Ha) = forest_strictAncestor(Qd, Hd, Qa, Ha) & forall Qaa:cert_t. forall Haa:height_t. (forest_strictAncestor(Qd, Hd, Qaa, Haa) -> forest_ancestor(Qa, Ha, Qaa, Haa))

    function valid_qc(Q:quorum_t, B:block_t) : bool
    #definition valid_qc(Q:quorum_t, B:block_t) = forall N:node_t . quorum_t.member(N, Qc.cert) -> rcvd_prepare(Qc.block, N)
    # this function checks that all members in Qc have voted for the block contained in Qc. It is done here by directly checking the node_has_voted relation. In actual implementation, this should be done by examining the contents of Qc.
    definition valid_qc(Q:quorum_t, B:block_t) = forall N:node_t. quorum_t.member(N,Q) -> global_view.node_has_voted(N, B)

    function valid_tc(Tc:timeout_cert_t) : bool
    function tc_members(Tc:timeout_cert_t) : bool
    # the following function verifies that members in the quorum of Tc
    # have actually sent timeout messages, by checking the network
    # sent relation. In implementation, this is done by verifying that
    # the Tc itself has been received from the network, or that we
    # have received timeout messages individually from members of the
    # quorum. This implementation detail is not modeled here for the
    # sake of simplicity.
    #definition tc_members(Tc:timeout_cert_t) = (Tc = timeout_cert_t.nil) | rcvd_tc(Tc) | forall N:node_t . quorum_t.member(N, Tc.cert) -> (exists M:msg. exists T:timeout_t. M.kind = msg_kind.timeout & M.t = T & T.round = Tc.round & shim.sent(M, N))

    function tc_highqc(Tc:timeout_cert_t) : bool
    # This verifies that the highestQC field contained in Tc is
    # actually sent by one of the members of the quorum in Tc. Again,
    # here we do it by directly checking the network sent relation,
    # but in implementation, this should be done by examining the
    # contents of Tc.
    #definition tc_highqc(Tc:timeout_cert_t) = (Tc ~= timeout_cert_t.nil) -> (exists M:msg. exists T:timeout_t. exists N:node_t. M.kind=msg_kind.timeout & M.t = T & T.round = Tc.round & quorum_t.member(N,Tc.cert) & shim.sent(M,N) & Tc.highestQC=T.m_locked)
    function tc_highestqc(Tc:timeout_cert_t) : bool
    # This function verifies that the round contained in highestQC is
    # the greatest among all rounds in all the QCs sent by members of
    # the quorum in Tc. Again,
    # here we do it by directly checking the network sent relation,
    # but in implementation, this should be done by examining the
    # contents of Tc.
    #definition tc_highestqc(Tc:timeout_cert_t) = (Tc ~= timeout_cert_t.nil) -> (forall M:msg. forall T:timeout_t. forall N:node_t. (M.kind=msg_kind.timeout & M.t=T & T.round=Tc.round & quorum_t.member(N,Tc.cert) & shim.sent(M,N) ) -> Tc.highestQC.round >= T.m_locked.round )
    definition valid_tc(Tc:timeout_cert_t) = Tc ~= timeout_cert_t.nil -> (tc_members(Tc) & tc_highqc(Tc) & tc_highestqc(Tc))


    after init {
        locked := cert_t.nil;
        locked.block := block_t.nil;
        voted := voted_t.nil;
        voted.block := block_t.nil;
        r_c := 0;

        timed_out := false;

        blockchain(H) := block_t.nil;
        chain_size := 0;

        rcvd_proposal(P, Src) := false;
        rcvd_prepare(B, Src) := false;
        rcvd_qc(Qc) := false;
        rcvd_timeout(T, Src) := false;
        rcvd_tc(Tc) := false;

        store_forest(Q, H) := false;
        forest_ancestor(Q1, H1, Q2, H2) := false;
    }

    implement shim.proposal_handler.handle(m:msg) {
        rcvd_proposal(m.prop, m.src) := true;
        if m.prop.qc ~= cert_t.nil & valid_qc(m.prop.qc.cert, m.prop.qc.block) {
            rcvd_qc(m.prop.qc) := true;
        }
        if m.prop.tc ~= timeout_cert_t.nil & valid_tc(m.prop.tc) {
            rcvd_tc(m.prop.tc) := true;
        }
    }
    implement shim.prepare_handler.handle(m:msg) {
        rcvd_prepare(m.block, m.src) := true;
    }
    implement shim.qc_handler.handle(m:msg) {
        if valid_qc(m.qc.cert, m.qc.block) {
            rcvd_qc(m.qc) := true;
        }
    }
    implement shim.timeout_handler.handle(m:msg) {
        rcvd_timeout(m.t, m.src) := true;
    }
    implement shim.tc_handler.handle(m:msg) {
        if valid_tc(m.tc) {
            rcvd_tc(m.tc) := true;
        }
    }

    action broadcast_proposal(b:block_t, qc:cert_t, tc:timeout_cert_t) = {
        var m : msg;
        m.kind := msg_kind.proposal;
        m.prop.block := b;
        m.prop.qc := qc;
        m.prop.tc := tc;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_prepare(b:block_t) = {
        var m : msg;
        m.kind := msg_kind.prepare;
        m.block := b;
    	m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_qc(qc:cert_t) = {
        var m : msg;
        m.kind := msg_kind.qc;
        m.qc := qc;

        call shim.broadcast(id, m);
    }

    action broadcast_timeout(r:round_t, locked:cert_t) = {
        var m : msg;
        m.kind := msg_kind.timeout;
        m.t.round := r;
        m.t.locked := locked;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_tc(tc:timeout_cert_t) = {
        var m : msg;
        m.kind := msg_kind.tc;
        m.tc := tc;

        call shim.broadcast(id, m);
    }

    export action aggregate_prepares(qc:cert_t) = {
        require forall N:node_t. quorum_t.member(N, qc.cert) -> rcvd_prepare(qc.block, N);
        rcvd_qc(qc) := true;
    }

    export action aggregate_timeout(tc:timeout_cert_t) = {
        require forall N:node_t. quorum_t.member(N, tc.cert) -> exists T:timeout_t. (T.round = tc.round & rcvd_timeout(T, N));
        rcvd_tc(tc) := true;
    }

    # We simulate the action of timer getting expired by having the
    # environment call this action, in which we set the Boolean
    # timed_out to true
    export action timer_expiry = {
        require ~timed_out;

        timed_out := true;
    }

    export action byzantine_send = {
        require ~is_good(id);

        var m : msg;
        if ~is_good(m.src) & m.kind ~= msg_kind.qc & m.kind ~= msg_kind.tc {
            call shim.broadcast(id,m);
        }
    }

    # Algorithm 1: SupraBFT Round Transition
    action advanceToRound(r:round_t, b_r_1:block_t, qc:cert_t, tc_r_2:timeout_cert_t) = {
        require qc = cert_t.nil | rcvd_qc(qc);
        require tc_r_2 = timeout_cert_t.nil | rcvd_tc(tc_r_2);

        r_c := r;
        timed_out := false;

        if b_r_1 ~= block_t.nil {
            call broadcast_prepare(b_r_1);
	        call global_view.node_voted(id, b_r_1);

            voted.block := b_r_1;
        }

        if id = leader(r_c) & (qc ~= cert_t.nil | tc_r_2 ~= timeout_cert_t.nil) {
            var lb : block_t;
            var pb : block_t;
            var b : block_t;

            lb := block_t.nil if locked = cert_t.nil else locked.block;
            pb := b_r_1 if voted ~= voted_t.nil & b_r_1 ~= block_t.nil & voted.block = b_r_1 else lb;
            if tc_r_2 ~= timeout_cert_t.nil {
                pb := tc_r_2.highestQC.block;
            }
            b := block_t.consBlock(block_t.hash(pb), r_c);
            call broadcast_proposal(b, qc, tc_r_2);
        }
    }

    # Algorithm 2: DP-PBFT Genesis
    export action proposal_b0_correct(p:proposal_t) = {
        require p ~= proposal_t.nil;
        require p.block ~= block_t.nil;
        require p.qc = cert_t.nil;
        require p.tc = timeout_cert_t.nil;

        require rcvd_proposal(p, leader(r_c));

        var ok := true;
        ok := ok & p.block.round = r_c;
        ok := ok & ~timed_out;
        ok := ok & p.block.parent = block_t.hash(block_t.nil);
        ok := ok & locked = cert_t.nil;
        ok := ok & voted = voted_t.nil;

        if ok {
            call advanceToRound(round_t.next(r_c), p, cert_t.nil, timeout_cert_t.nil);
        }
    }

    export action proposal_b0_late(p:proposal_t) = {
        require p ~= proposal_t.nil;
        require p.block ~= block_t.nil;
        require p.qc = cert_t.nil;
        require p.tc ~= timeout_cert_t.nil;
	    require valid_tc(p.tc);
	    require p.block.round > 0;
	    require round_t.prev(p.block.round) > 0;

        require rcvd_proposal(p, leader(r_c));

        var ok := true;
        ok := ok & p.block.round = r_c;
        ok := ok & ~timed_out;
        ok := ok & p.block.parent = block_t.hash(block_t.nil);
        ok := ok & locked = cert_t.nil;
        ok := ok & p.tc.round = round_t.prev(round_t.prev(p.block.round));

        if ok {
            call advanceToRound(round_t.next(r_c), p, cert_t.nil, p.tc);
        }
    }

    export action proposal_b1_correct(p:proposal_t) = {
        require p ~= proposal_t.nil;
        require p.block ~= block_t.nil;
        require p.qc = cert_t.nil;
        require p.tc = timeout_cert_t.nil;

        require rcvd_proposal(p, leader(r_c));

        var ok := true;
        ok := ok & p.block.round = r_c;
        ok := ok & ~timed_out;
        ok := ok & p.block.parent = block_t.hash(locked.block);

        if ok {
            call advanceToRound(round_t.next(r_c), p, cert_t.nil, timeout_cert_t.nil);
        }
    }

    export action b0_qc(qc:cert_t) = {
        require valid_qc(qc.cert, qc.block);

        var ok := true;
        ok := ok & qc.block.parent = block_t.hash(block_t.nil);
        ok := ok & qc.block ~= block_t.nil;
        ok := ok & (locked = cert_t.nil | (locked.block.parent = block_t.hash(block_t.nil) & qc.block.round > locked.block.round));
        ok := ok & forall H:height_t. forall Q:cert_t. store_forest(Q,H) -> Q.block ~= qc.block;

        if ok {
            assert chain_size = 0;
            assert forall Q:cert_t. forall H:height_t. forest_root(Q,H) -> (H = 0 & Q.block.parent = block_t.hash(block_t.nil));
            call broadcast_qc(qc);
            var block_new : block_t;
            var locked_new : cert_t;
            block_new.round := qc.block.round;
            block_new.parent := qc.block.parent;
            block_new := qc.block;
            locked_new.block := block_new;
            locked_new.round := qc.round;
            locked_new.cert := qc.cert;
            locked := locked_new;
            store_forest(locked,0) := true;
            forest_ancestor(locked,0,locked,0) := true;
            call global_view.node_locked(id,qc.block,qc.cert);
        }
    }

    # Algorithm 3: DP-PBFT PrepareQC Processing
   # Algorithm 2: SupraBFT PrepareQC Processing
    action tryLockAndCommit(qc:cert_t) = {
        require rcvd_qc(qc);

        var ok := true;
        ok := ok & (round_t.succ(locked.block.round, qc.block.round));
        ok := ok & (qc.block.parent = block_t.hash(locked.block));
        if ok {
            # 2-chain commit. Commit all uncommitted ancestors of locked
            if some hl:height_t. store_forest(locked, hl) {
                if some qr:cert_t. exists Hr:height_t. forest_root(qr, Hr) & forest_ancestor(locked, hl, qr, Hr) {
                    if some hr:height_t. forest_root(qr, hr) & forest_ancestor(locked, hl, qr, hr) {
                        # commit everything in the path from (qr, hr) to (locked, hl)
                        var h : height_t;
                        h := height_t.next(hl);
                        chain_size := h;
                        while (h > hr) {
                            h := height_t.prev(h);
                            if some q:cert_t. forest_ancestor(locked, hl, q, h) & forest_ancestor(q, h, qr, hr) {
                                blockchain(h) := q.block;
                            }
                        }
                    }
                }
            }
            # delete everything except the recently added qc from store_forest
            if some hc:height_t. store_forest(qc, hc) {
                store_forest(Q, H) := Q = qc & H = hc;
                forest_ancestor(Q1, H1, Q2, H2) := Q1 = qc & H1 = hc & Q2 = qc & H2 = hc;
            }
        }

        if qc.block.round > locked.block.round {
            locked := qc;
            call global_view.node_locked(id, qc.block, qc.cert)
        }
    }

    export action process_prepareQC(qc:cert_t) = {
        require rcvd_qc(qc);

        var ok := true;
        ok := ok & qc.block.parent ~= block_t.hash(block_t.nil);
        ok := ok & forall H:height_t. blockchain(H) ~= qc.block;
        ok := ok & forall H:height_t. ~store_forest(qc, H);
        if ok {
            if some h:height_t. height_t.succ(h, chain_size) & qc.block.parent = block_t.hash(blockchain(h)) {
                # this qc is a candidate for the child of the last committed block on the chain. start a new tree in the forest
                store_forest(qc, height_t.next(h)) := true;
                forest_ancestor(qc, height_t.next(h), qc, height_t.next(h)) := true;
                call broadcast_qc(qc);
                call tryLockAndCommit(qc);
                call finished_prepareQC_processing(qc);
            } else {
                # QUESTION: why not "if some" on this line itself?
                if exists Ql:cert_t. exists Hl:height_t. forest_leaf(Ql,Hl) & qc.block.parent = block_t.hash(Ql.block) & Ql.block ~= block_t.nil {
                    # this qc is a candidate for the child of Ql, which is a leaf in the forest at height Hl
                    if some ql:cert_t. exists Hl:height_t. forest_leaf(ql, Hl) & qc.block.parent = block_t.hash(ql.block) & ql.block ~= block_t.nil {
                        if some hl:height_t. forest_leaf(ql, hl) & qc.block.parent = block_t.hash(ql.block) {
                            store_forest(qc, height_t.next(hl)) := true;
                            forest_ancestor(qc, height_t.next(hl), qc, height_t.next(hl)) := true;
                            forest_ancestor(qc, height_t.next(hl), ql, hl) := true;
                            forest_ancestor(qc, height_t.next(hl), Q, H) := forest_ancestor(ql, hl, Q, H);

                            assert ~forest_root(qc, height_t.next(hl));

                            call broadcast_qc(qc);
                            call tryLockAndCommit(qc);
                            call finished_prepareQC_processing(qc);
                        }
                    }
                } else {
                    #wait for ancestor QCs
                }
            }
        }
    }

    # Algorithm 3: SupraBFT Fast Path
    export action process_proposal(p:proposal_t) = {
        require p ~= proposal_t.nil;
        require rcvd_proposal(p, leader(r_c));
        require p.tc = timeout_cert_t.nil;

        var ok := true;
        ok := ok & p.block.round = r_c;
        ok := ok & ~timed_out;
        ok := ok & block_t.hash(p.qc.block) = locked.block.parent;
        ok := ok & round_t.succ(locked.block.round, r_c);
        ok := ok & p.block.parent = block_t.hash(locked.block);
        if ok {
            call advanceToRound(round_t.next(r_c), p.block, locked, timeout_cert_t.nil);
        }
    }

    # Algorithm 4: SupraBFT Fallback
    action timeout(r:round_t) = {
        call broadcast_timeout(r, locked);
    }

    export action fallback = {
        require r_c > 0;

        var ok := true;
        ok := ok & timed_out;
        ok := ok & ~round_t.succ(locked.block.round, r_c);
        if ok {
            call timeout(round_t.prev(r_c));
        }
    }

    export action process_timeoutQC(tc:timeout_cert_t) = {
        require rcvd_tc(tc);
        require r_c > 0;
        require round_t.prev(r_c) > 0;

        var ok := true;
        ok := ok & tc.round > round_t.prev(round_t.prev(r_c));
        if (ok) {
            call advanceToRound(round_t.next(round_t.next(tc.round)), block_t.nil, cert_t.nil, tc);
        }
    }


    export action fallback_recovery(p:proposal_t) = {
        require p ~= proposal_t.nil;
        require rcvd_proposal(p, leader(r_c));
        require p.tc ~= timeout_cert_t.nil;

        var ok := true;
        ok := ok & p.block.round = r_c;
        ok := ok & ~timed_out;
        ok := ok & p.tc.round = round_t.prev(round_t.prev(p.block.round));
        ok := ok & p.block.parent = block_t.hash(p.tc.highestQC.block);

        if ok {
            call advanceToRound(round_t.next(r_c), p.block, p.tc.highestQC, timeout_cert_t.nil)
        }

    }

    # Algorithm 5: SupraBFT Round Synchronisation
    action finished_prepareQC_processing(qc:cert_t) = {
        require rcvd_qc(qc);

        var ok := true;
        ok := ok & round_t.next(qc.block.round) > r_c;

        if ok {
            # QUESTION: What to put here to check for "processed qc'"?
            if some qc2. rcvd_qc(qc2) & block_t.hash(qc2.block) = qc.block.parent {
                call advanceToRound(round_t.next(qc.block.round), qc.block, qc2, timeout_cert_t.nil);
            } else {
                call advanceToRound(round_t.next(qc.block.round), block_t.nil, cert_t.nil, timeout_cert_t.nil);
            }
        }
    }

    export action no_proposal = {
        var ok := true;
        ok := ok & timed_out;
        ok := ok & round_t.succ(locked.block.round, r_c);

        if ok {
            call advanceToRound(round_t.next(locked.block.round), block_t.nil, cert_t.nil, timeout_cert_t.nil);
        }
    }

    # Algorithm 6: SupraBFT Genesis
    export action proposal_b0_correct(p:proposal_t) = {
        require p ~= proposal_t.nil;
        require p.qc = cert_t.nil;
        require p.tc = timeout_cert_t.nil;
        require rcvd_proposal(p, leader(r_c));

        var ok := true;
        ok := ok & p.block.round = r_c;
        ok := ok & ~timed_out;
        ok := ok & p.block.parent = block_t.hash(block_t.nil);
        ok := ok & locked = cert_t.nil;
        ok := ok & voted = voted_t.nil;
        if ok {
            call advanceToRound(round_t.next(r_c), p.block, cert_t.nil, timeout_cert_t.nil);
        }
    }

    export action proposal_b0_late(p:proposal_t) = {
        require p ~= proposal_t.nil;
        require p.qc = cert_t.nil;
        require p.tc ~= timeout_cert_t.nil;
        require rcvd_proposal(p, leader(r_c));
	    require rcvd_tc(p.tc);
	    require p.block.round > 0;
	    require round_t.prev(p.block.round) > 0;

        var ok := true;
        ok := ok & p.block.round = r_c;
        ok := ok & ~timed_out;
        ok := ok & p.block.parent = block_t.hash(block_t.nil);
        ok := ok & locked = cert_t.nil;
        ok := ok & p.tc.round = round_t.prev(round_t.prev(p.block.round));
        if ok {
            call advanceToRound(round_t.next(r_c), p.block, cert_t.nil, p.tc);
        }
    }

    export action proposal_b1_correct(p:proposal_t) = {
        require p ~= proposal_t.nil;
        require p.qc = cert_t.nil;
        require p.tc = timeout_cert_t.nil;
        require rcvd_proposal(p, leader(r_c));

        var ok := true;
        ok := ok & p.block.round = r_c;
        ok := ok & ~timed_out;
        ok := ok & p.block.parent = block_t.hash(locked.block);
        if ok {
            call advanceToRound(round_t.next(r_c), p.block, cert_t.nil, timeout_cert_t.nil);
        }
    }

    export action b0_qc(qc:cert_t) = {
        require rcvd_qc(qc);

        var ok := true;
        ok := ok & qc.block.parent = block_t.hash(block_t.nil);
        ok := ok & qc.block ~= block_t.nil;
        ok := ok & (locked = cert_t.nil | (locked.block.parent = block_t.hash(block_t.nil) & qc.block.round > locked.block.round));
        if ok {
            call broadcast_qc(qc);
            var block_new : block_t;
            var locked_new : cert_t;
            block_new.round := qc.block.round;
            block_new.parent := qc.block.parent;
            block_new := qc.block;
            locked_new.block := block_new;
            locked_new.round := qc.round;
            locked_new.cert := qc.cert;
            locked := locked_new;
            store_forest(locked,0) := true;
            forest_ancestor(locked,0,locked,0) := true;
            call global_view.node_locked(id,qc.block,qc.cert);
        }
    }

    invariant forall Qc:cert_t. rcvd_qc(Qc) -> valid_qc(qc.cert, qc.block)

    invariant forall Tc:timeout_cert_t. rcvd_tc(Tc) -> valid_tc(tc)

    invariant (locked = cert_t.nil | locked.block.parent = block_t.hash(block_t.nil)) -> chain_size=0

    invariant forall Hc:height_t. forall Hf:height_t. forall Qf:cert_t. (height_t.succ(Hc, chain_size) & forest_root(Qf,Hf)) -> (Qf.block.parent = block_t.hash(blockchain(Hc)) & height_t.succ(Hc,Hf))

    invariant forall Hf:height_t. forall Qf:cert_t. (chain_size = 0 & forest_root(Qf,Hf)) -> (Hf = 0 & Qf.block.parent = block_t.hash(block_t.nil))

    invariant forall Q:cert_t. forall H:height_t. (store_forest(Q,H) &  ~forest_root(Q,H)) -> exists Qs:cert_t. exists Hs:height_t. forest_succ(Q,H,Qs,Hs)
    
    invariant forall Q:cert_t. forall H:height_t. (store_forest(Q,H) &  ~forest_root(Q,H)) -> exists Qr:cert_t. exists Hr:height_t. forest_ancestor(Q,H,Qr,Hr) & forest_root(Qr,Hr)

    invariant forall Hf:height_t. forall Qf:cert_t. (forest_root(Qf, Hf) & chain_size = 0) -> (Hf = 0 & Qf.block.parent = block_t.hash(block_t.nil))

	invariant forall B:block_t. global_view.node_has_voted(id, B) -> r_c > B.round

	invariant locked.block ~= block_t.nil -> rcvd_qc(locked)

	invariant locked.block ~= block_t.nil -> global_view.node_has_locked(id, locked.block)

	invariant forall H:height_t. H < chain_size -> blockchain(H) ~= block_t.nil

    invariant forall H:height_t. H >= chain_size -> blockchain(H) = block_t.nil

    invariant forall H1:height_t. forall H2:height_t. (height_t.succ(H1, H2) & H2 < chain_size) -> blockchain(H2).parent = block_t.hash(blockchain(H1))
    
    invariant forall Q:cert_t. forall H:height_t. store_forest(Q,H)  -> valid_qc(Q.cert,Q.block)

    invariant forall Q:cert_t. forall H:height_t. (store_forest(Q,H) & Q.block.parent = block_t.hash(block_t.nil)) -> H = 0

    invariant forall Q:cert_t. forall H:height_t. store_forest(Q,H) -> rcvd_qc(Q)

    invariant forall Q1,Q2:cert_t. forall H1,H2:height_t. forest_ancestor(Q1,H1,Q2,H2) -> store_forest(Q1,H1) & store_forest(Q2,H2)

    invariant forall Q1:cert_t. forall Q2:cert_t. forall H1:height_t. forall H2:height_t. (store_forest(Q1,H1) & store_forest(Q2,H2) & Q1.block = Q2.block) -> (Q1 = Q2 & H1=H2)

    invariant forall Q:cert_t. forall H:height_t. store_forest(Q,H) -> Q.block ~= block_t.nil

    invariant forall H:height_t. forall Hf:height_t. forall Qf:cert_t. store_forest(Qf,Hf) -> Qf.block ~= blockchain(H)

    invariant forall Q:cert_t. forall H:height_t. (forest_root(Q,H) & Q.block.parent ~= block_t.hash(block_t.nil)) -> (exists Hc:height_t. height_t.succ(Hc,chain_size) & Q.block.parent = block_t.hash(blockchain(Hc)) & H = chain_size)

    invariant forall Q:cert_t. forall H:height_t. (forest_root(Q,H) & Q.block.parent = block_t.hash(block_t.nil)) -> (H = 0 & chain_size = 0)

    invariant forall Qd:cert_t. forall Qa:cert_t. forall Hd:height_t. forall Ha:height_t. (store_forest(Qd,Hd) & store_forest(Qa,Ha)) -> (Qd.block.parent = block_t.hash(Qa.block) <-> forest_succ(Qd,Hd,Qa,Ha))

    invariant forall Qd:cert_t. forall Qa:cert_t. forall Hd:height_t. forall Ha:height_t. forest_succ(Qd,Hd,Qa,Ha) -> height_t.succ(Ha,Hd)

    invariant forall Q1,Q2:cert_t. forall H1,H2:height_t. (forest_ancestor(Q1,H1,Q2,H2) & forest_ancestor(Q2,H2,Q1,H1)) <-> (Q1 = Q2 & H1 = H2 & store_forest(Q1,H1) & store_forest(Q2,H2))

    invariant forall Q1,Q2,Q3: cert_t. forall H1,H2,H3:height_t. (forest_ancestor(Q1,H1,Q2,H2) & forest_ancestor(Q2,H2,Q3,H3)) -> forest_ancestor(Q1,H1,Q3,H3)

    invariant forall Q1,Q2,Q3: cert_t. forall H1,H2,H3:height_t. (forest_ancestor(Q1,H1,Q2,H2) & forest_ancestor(Q1,H1,Q3,H3)) -> (forest_ancestor(Q2,H2,Q3,H3) | forest_ancestor(Q3,H3,Q2,H2))

    invariant locked ~= cert_t.nil -> exists H:height_t. store_forest(locked,H)
} #object validator
} #global view
