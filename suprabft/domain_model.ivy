#lang ivy1.8

include ubd_seq

instance round_t : ubd_seq
instance height_t : ubd_seq

instance node_t : iterable
relation is_good(N:node_t)

function leader(R:round_t) : node_t
definition leader(r:round_t) = <<< r % `node_t.max` >>>

isolate block_t = {
    type this

    relation round(B:block_t, R:round_t)
    relation parent(B:block_t, P:block_t)

    relation ancestor(B:block_t, A:block_t)
    relation height(B:block_t, H:height_t)

    individual genesis : block_t

    action get_round(b:block_t) returns (r:round_t)
    action get_parent(b:block_t) returns (pB:block_t)
    action get_height(b:block_t) returns (h:height_t)

    action block(r_c:round_t, pB:block_t) returns (b:block_t)

    specification {
        relation valid(B:block_t)

        after init {
            valid(B) := B = genesis;
        }

        before get_round {
            require valid(b);
        }

        after get_round {
            ensure round(b, r);
        }

        before get_parent {
            require valid(b);
        }

        after get_parent {
            ensure parent(b, pB);
        }

        before get_height {
            require valid(b);
        }

        after get_height {
            ensure height(b, h);
        }

        before block {
            require valid(pB);
            assume ~valid(b);
        }

        after block {
            valid(B) := valid(B) | B = b;
        }

        invariant round(genesis, 0)
        invariant parent(genesis, P) <-> P = genesis

        invariant ancestor(genesis, A) <-> A = genesis
        invariant height(genesis, 0)

        invariant valid(genesis)
        invariant round(B, R) -> valid(B)
        invariant parent(B, P) -> (valid(B) & valid(P))

        invariant ancestor(B, A) -> (valid(B) & valid(A))
        invariant height(B, H) -> valid(B)

        invariant valid(B) -> exists R:round_t. round(B, R)
        relation parent_exists(B:block_t)
        definition parent_exists(B) = exists P:block_t. parent(B, P)
        invariant valid(B) -> parent_exists(B)

        invariant valid(B) -> exists H:height_t. height(B, H)

        invariant round(B, R1) & round(B, R2) -> R1 = R2
        invariant parent(B, P1) & parent(B, P2) -> P1 = P2

        invariant height(B, H1) & height(B, H2) -> H1 = H2

        invariant parent(B, P) -> ancestor(B, P)
        invariant ancestor(A1, A2) & ancestor(A2, A3) -> ancestor(A1, A3)
        invariant ancestor(B, A1) & ancestor(B, A2) -> (A1 = A2 | ancestor(A1, A2) | ancestor(A2, A1))
        relation inbetween(D:block_t, A:block_t)
        definition inbetween(D, A) = exists M:block_t. ancestor(D, M) & ancestor(M, A)
        invariant (ancestor(D, A) & ~inbetween(D, A)) -> ((D = genesis & A = genesis) | parent(D, A))
        invariant parent(B, P) -> ((B = genesis & P = genesis) | (exists B_h, P_h:height_t. height(B, B_h) & height(P, P_h) & height_t.succ(P_h, B_h)))
    }

    implementation {
        after init {
            round(B, R) := B = genesis & R = 0;
            parent(B, P) := B = genesis & P = genesis;
            ancestor(B, A) := B = genesis & A = genesis;
            height(B, H) := B = genesis & H = 0;
        }

        implement get_round(b:block_t) returns (r:round_t) {
            if some b_r:round_t. round(b, b_r) {
                r := b_r;
            } else {
            }
        }

        implement get_parent(b:block_t) returns (pB:block_t) {
            if some b_pB:block_t. parent(b, b_pB) {
                pB := b_pB;
            } else {
            }
        }

        implement get_height(b:block_t) returns (h:height_t) {
            if some b_h:height_t. height(b, b_h) {
                h := b_h;
            } else {
            }
        }

        implement block(r_c:round_t, pB:block_t) returns (b:block_t) {
            round(B, R) := round(B, R) | (B = b & R = r_c);
            parent(B, P) := parent(B, P) | (B = b & P = pB);
            ancestor(B, A) := ancestor(B, A) | (B = b & A = pB) | (B = b & ancestor(pB, A));
            height(B, H) := height(B, H) | B = b & H = height_t.next(get_height(pB));
        }
    }
} with height_t
export block_t.get_round
export block_t.get_parent
export block_t.get_height

isolate proposal_n_t = {
    type this

    relation block(P:proposal_n_t, B:block_t)

    action get_block(p:proposal_n_t) returns (b:block_t)

    action proposal_n(b:block_t) returns (p:proposal_n_t)

    specification {
        relation valid(P:proposal_n_t)

        after init {
            valid(P) := false;
        }

        before get_block {
            require valid(p);
        }

        after get_block {
            ensure block_t.valid(b);
        }

        before proposal_n {
            require block_t.valid(b);
            assume ~valid(p);
        }

        after proposal_n {
            valid(P) := valid(P) | P = p;
        }

        invariant block(P, B) -> valid(P) & block_t.valid(B)
        invariant valid(P) -> exists B:block_t. block(P, B)
        invariant block(P, B1) & block(P, B2) -> B1 = B2
        invariant block(P1, B) & block(P2, B) -> P1 = P2
    }

    implementation {
        after init {
            block(P, B) := false;
        }

        implement get_block(p:proposal_n_t) returns (b:block_t) {
            if some p_b:block_t. block(p, p_b) {
                b := p_b;
            } else {
            }
        }

        implement proposal_n(b:block_t) returns (p:proposal_n_t) {
            block(P, B) := block(P, B) | (P = p & B = b);
        }
    }
}
export proposal_n_t.get_block

isolate prepare_t = {
    type this

    relation block(P:prepare_t, B:block_t)

    individual genesis : prepare_t

    action get_block(p:prepare_t) returns (b:block_t)

    action prepare(b:block_t) returns (p:prepare_t)

    specification {
        relation valid(P:prepare_t)

        after init {
            valid(P) := P = genesis;
        }

        before get_block {
            require valid(p);
        }

        after get_block {
            ensure block_t.valid(b);
        }

        before prepare {
            require block_t.valid(b);
            assume ~valid(p);
        }

        after prepare {
            valid(P) := valid(P) | P = p;
        }

        invariant block(genesis, B) <-> B = block_t.genesis
        invariant valid(genesis)

        invariant valid(P) -> exists B:block_t. block(P, B)
        invariant block(P, B) -> valid(P) & block_t.valid(B)
        invariant block(P, B1) & block(P, B2) -> B1 = B2
    }

    implementation {
        after init {
            block(P, B) := P = genesis & B = block_t.genesis;
        }

        implement get_block(p:prepare_t) returns (b:block_t) {
            if some p_b:block_t. block(p, p_b) {
                b := p_b;
            } else {
            }
        }

        implement prepare(b:block_t) returns (p:prepare_t) {
            block(P, B) := block(P, B) | (P = p & B = b);
        }
    }
} with block_t
export prepare_t.get_block

object quorum_t = {
    type this

    relation member(Q:quorum_t, N:node_t)

    individual genesis : quorum_t
}

trusted isolate genesis_quorum = {
    private {
        axiom [genesis_quorum] quorum_t.member(quorum_t.genesis, N)
    }
}

trusted isolate every_quorum_good = {
    private {
        axiom [every_quorum_good] exists N:node_t. is_good(N) & quorum_t.member(Q, N)
    }
}

trusted isolate quorum_intersection_axiom = {
    private {
        axiom [quorum_intersection_axiom] exists N:node_t. is_good(N) & quorum_t.member(Q1, N) & quorum_t.member(Q2, N)
    }
}

# isolate qc_t = {
    # type this

    # relation block(QC:qc_t, B:block_t)
    # relation prepare(QC:qc_t, P:prepare_t)
    # relation quorum(QC:qc_t, Q:quorum_t)

    # individual genesis : qc_t

    # action get_block(qc:qc_t) returns (b:block_t)
    # action get_quorum(qc:qc_t) returns (q:quorum_t)

    # specification {
        # relation valid(QC:qc_t)
        # definition valid(QC) = (block(QC, B) -> block_t.valid(B)) & (prepare(QC, P) -> prepare_t.valid(P))

        # before get_block {
            # require valid(qc);
        # }

        # after get_block {
            # ensure block_t.valid(b);
        # }

        # before get_quorum {
            # require valid(qc);
        # }

        # invariant valid(genesis)
        # invariant block(genesis, B) <-> B = block_t.genesis
    # }

    # implementation {
        # after init {
            # block(QC, B) := QC = genesis & B = block_t.genesis;
            # prepare(QC, P) := QC = genesis & P = prepare_t.genesis;
            # quorum(QC, Q) := QC = genesis & Q = quorum_t.genesis;
        # }

        # implement get_block(qc:qc_t) returns (b:block_t) {
            # if some qc_b:block_t. block(qc, qc_b) {
                # b := qc_b;
            # } else {
            # }
        # }

        # implement get_quorum(qc:qc_t) returns (q:quorum_t) {
            # if some qc_q:quorum_t. quorum(qc, qc_q) {
                # q := qc_q;
            # } else {
            # }
        # }

        # implement qc() returns (qc:qc_t) {

        # }
    # }
# } with genesis_quorum.genesis_quorum
# export qc_t.get_block
# export qc_t.get_quorum
# export qc_t.qc


        #block : block_t,
        ## every member of cert should have made rcvd_prepare() true for this round
        #round : round_t,
        #cert : quorum_t
    #}
    #individual nil : cert_t

    #specification {
        #axiom forall Qc:cert_t. Qc = nil <-> Qc.block = block_t.nil
        #axiom forall Qc:cert_t. Qc ~= nil <-> Qc.round ~= nil.round
        #axiom forall N:node_t. quorum_t.member(N, nil.cert)
    #}
#}

#isolate timeout_t = {
    #type this = struct {
        #round : round_t,
        #qc : cert_t
    #}
    #individual nil : timeout_t

    #specification {
        #axiom forall T:timeout_t. T ~= nil <-> T.round ~= nil.round
        #axiom forall T:timeout_t. T = nil <-> T.qc = cert_t.nil
    #}
#}

#isolate timeout_cert_t = {
    #type this = struct {
        #round : round_t,
        #cert : quorum_t,
        #highestQC : cert_t
    #}
    #individual nil : timeout_cert_t

    #specification {
        #axiom forall Tc:timeout_cert_t. Tc ~= nil <-> Tc.round ~= nil.round
        #axiom forall N:node_t. quorum_t.member(N, nil.cert)
        #axiom forall Tc:timeout_cert_t. Tc = nil <-> Tc.highestQC = cert_t.nil
    #}
#}

#isolate proposal_t = {
    #type this = struct {
        #block : block_t,
        #qc : cert_t,
        #tc : timeout_cert_t
    #}
    #individual nil : proposal_t

    #specification {
        #axiom forall P:proposal_t. P = nil <-> P.block = block_t.nil
        #axiom nil.qc = cert_t.nil
        #axiom nil.tc = timeout_cert_t.nil
    #}
#}
