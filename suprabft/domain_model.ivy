#lang ivy1.8

include ubd_seq

instance round_t : ubd_seq
instance height_t : ubd_seq

instance process_index_t : iterable
relation is_good(N:process_index_t)

function leader(R:round_t) : process_index_t
definition leader(r:round_t) = <<< r % `process_index_t.max` >>>

isolate block_t = {
    type this

    relation round(B:block_t, R:round_t)
    relation parent(B:block_t, P:block_t)

    relation ancestor(B:block_t, A:block_t)
    relation height(B:block_t, H:height_t)

    individual genesis : block_t

    action get_round(b:block_t) returns (r:round_t)
    action get_parent(b:block_t) returns (pB:block_t)
    action get_height(b:block_t) returns (h:height_t)

    action block(r_c:round_t, pB:block_t) returns (b:block_t)

    specification {
        relation valid(B:block_t)

        after init {
            valid(B) := B = genesis;
        }

        before get_round {
            require valid(b);
        }

        after get_round {
            ensure round(b, r);
        }

        before get_parent {
            require valid(b);
        }

        after get_parent {
            ensure parent(b, pB);
        }

        before get_height {
            require valid(b);
        }

        after get_height {
            ensure height(b, h);
        }

        before block {
            require valid(pB);
            assume ~valid(b);
        }

        after block {
            valid(B) := valid(B) | B = b;
        }

        invariant round(genesis, 0)
        invariant parent(genesis, P) <-> P = genesis

        invariant ancestor(genesis, A) <-> A = genesis
        invariant height(genesis, 0)

        invariant valid(genesis)
        invariant round(B, R) -> valid(B)
        invariant parent(B, P) -> (valid(B) & valid(P))

        invariant ancestor(B, A) -> (valid(B) & valid(A))
        invariant height(B, H) -> valid(B)

        invariant valid(B) -> exists R:round_t. round(B, R)
        relation parent_exists(B:block_t)
        definition parent_exists(B) = exists P:block_t. parent(B, P)
        invariant valid(B) -> parent_exists(B)

        invariant valid(B) -> exists H:height_t. height(B, H)

        invariant round(B, R1) & round(B, R2) -> R1 = R2
        invariant parent(B, P1) & parent(B, P2) -> P1 = P2

        invariant height(B, H1) & height(B, H2) -> H1 = H2

        invariant parent(B, P) -> ancestor(B, P)
        invariant ancestor(A1, A2) & ancestor(A2, A3) -> ancestor(A1, A3)
        invariant ancestor(B, A1) & ancestor(B, A2) -> (A1 = A2 | ancestor(A1, A2) | ancestor(A2, A1))
        relation inbetween(D:block_t, A:block_t)
        definition inbetween(D, A) = exists M:block_t. ancestor(D, M) & ancestor(M, A)
        invariant (ancestor(D, A) & ~inbetween(D, A)) -> ((D = genesis & A = genesis) | parent(D, A))
        invariant parent(B, P) -> ((B = genesis & P = genesis) | (exists B_h, P_h:height_t. height(B, B_h) & height(P, P_h) & height_t.succ(P_h, B_h)))
    }

    implementation {
        after init {
            round(B, R) := B = genesis & R = 0;
            parent(B, P) := B = genesis & P = genesis;
            ancestor(B, A) := B = genesis & A = genesis;
            height(B, H) := B = genesis & H = 0;
        }

        implement get_round(b:block_t) returns (r:round_t) {
            if some b_r:round_t. round(b, b_r) {
                r := b_r;
            } else {
            }
        }

        implement get_parent(b:block_t) returns (pB:block_t) {
            if some b_pB:block_t. parent(b, b_pB) {
                pB := b_pB;
            } else {
            }
        }

        implement get_height(b:block_t) returns (h:height_t) {
            if some b_h:height_t. height(b, b_h) {
                h := b_h;
            } else {
            }
        }

        implement block(r_c:round_t, pB:block_t) returns (b:block_t) {
            round(B, R) := round(B, R) | (B = b & R = r_c);
            parent(B, P) := parent(B, P) | (B = b & P = pB);
            ancestor(B, A) := ancestor(B, A) | (B = b & A = pB) | (B = b & ancestor(pB, A));
            height(B, H) := height(B, H) | B = b & H = height_t.next(get_height(pB));
        }
    }
} with height_t
export block_t.get_round
export block_t.get_parent
export block_t.get_height

isolate proposal_n_t = {
    type this

    relation block(P:proposal_n_t, B:block_t)

    action get_block(p:proposal_n_t) returns (b:block_t)

    action proposal_n(b:block_t) returns (p:proposal_n_t)

    specification {
        relation valid(P:proposal_n_t)

        after init {
            valid(P) := false;
        }

        before get_block {
            require valid(p);
        }

        after get_block {
            ensure block_t.valid(b);
        }

        before proposal_n {
            require block_t.valid(b);
            assume ~valid(p);
        }

        after proposal_n {
            valid(P) := valid(P) | P = p;
        }

        invariant block(P, B) -> valid(P) & block_t.valid(B)
        invariant valid(P) -> exists B:block_t. block(P, B)
        invariant block(P, B1) & block(P, B2) -> B1 = B2
        invariant block(P1, B) & block(P2, B) -> P1 = P2
    }

    implementation {
        after init {
            block(P, B) := false;
        }

        implement get_block(p:proposal_n_t) returns (b:block_t) {
            if some p_b:block_t. block(p, p_b) {
                b := p_b;
            } else {
            }
        }

        implement proposal_n(b:block_t) returns (p:proposal_n_t) {
            if some p_old:proposal_n_t. block(p_old, b) {
                p := p_old;
            } else {
                block(P, B) := block(P, B) | (P = p & B = b);
            }
        }
    }
}
export proposal_n_t.get_block

isolate prepare_t = {
    type this

    relation block(P:prepare_t, B:block_t)

    individual genesis : prepare_t

    action get_block(p:prepare_t) returns (b:block_t)

    action prepare(b:block_t) returns (p:prepare_t)

    specification {
        relation valid(P:prepare_t)

        after init {
            valid(P) := P = genesis;
        }

        before get_block {
            require valid(p);
        }

        after get_block {
            ensure block_t.valid(b);
        }

        before prepare {
            require block_t.valid(b);
            assume ~valid(p);
        }

        after prepare {
            valid(P) := valid(P) | P = p;
        }

        invariant block(genesis, B) <-> B = block_t.genesis
        invariant valid(genesis)

        invariant valid(P) -> exists B:block_t. block(P, B)
        invariant block(P, B) -> valid(P) & block_t.valid(B)
        invariant block(P, B1) & block(P, B2) -> B1 = B2
    }

    implementation {
        after init {
            block(P, B) := P = genesis & B = block_t.genesis;
        }

        implement get_block(p:prepare_t) returns (b:block_t) {
            if some p_b:block_t. block(p, p_b) {
                b := p_b;
            } else {
            }
        }

        implement prepare(b:block_t) returns (p:prepare_t) {
            if some p_old:prepare_t. block(p_old, b) {
                p := p_old;
            } else {
                block(P, B) := block(P, B) | (P = p & B = b);
            }
        }
    }
} with block_t
export prepare_t.get_block

object quorum_t = {
    type this

    relation member(Q:quorum_t, N:process_index_t)

    individual genesis : quorum_t
}

object quorum_fplusone_t = {
    type this

    relation member(Q:quorum_fplusone_t, N:process_index_t)
}

isolate every_quorum_fplusone_good = {
    axiom exists N:process_index_t. is_good(N) & quorum_fplusone_t.member(Q, N)
}

isolate genesis_member = {
    axiom quorum_t.member(quorum_t.genesis, N)
}

isolate every_quorum_good = {
    axiom exists N:process_index_t. is_good(N) & quorum_t.member(Q, N)
}

isolate quorum_intersection_axiom = {
    axiom exists N:process_index_t. is_good(N) & quorum_t.member(Q1, N) & quorum_t.member(Q2, N)
}

isolate qc_t = {
    type this

    relation block(QC:qc_t, B:block_t)
    relation prepare(QC:qc_t, P:prepare_t)
    relation quorum(QC:qc_t, Q:quorum_t)

    individual genesis : qc_t

    specification {
        invariant block(genesis, B) <-> B = block_t.genesis
        invariant prepare(genesis, P) <-> P = prepare_t.genesis
        invariant quorum(genesis, Q) <-> Q = quorum_t.genesis
    }

    implementation {
        after init {
            block(genesis, B) := B = block_t.genesis;
            prepare(genesis, P) := P = prepare_t.genesis;
            quorum(genesis, Q) := Q = quorum_t.genesis;
        }
    }
}

isolate timeout_t = {
    type this

    relation round(T:timeout_t, R:round_t)
    relation qc(T:timeout_t, QC:qc_t)

    action get_round(t:timeout_t) returns (r:round_t)
    action get_qc(t:timeout_t) returns (q:qc_t)

    action timeout(r:round_t, q:qc_t) returns (t:timeout_t)

    implementation {
        after init {
            round(T, R) := false;
            qc(T, QC) := false;
        }

        implement get_round(t:timeout_t) returns (r:round_t) {
            if some t_r:round_t. round(t, t_r) {
                r := t_r;
            } else {
            }
        }

        implement get_qc(t:timeout_t) returns (q:qc_t) {
            if some t_q:qc_t. qc(t, t_q) {
                q := t_q;
            } else {
            }
        }

        implement timeout(r:round_t, q:qc_t) returns (t:timeout_t) {
            if some t_old:timeout_t. round(t_old, r) & qc(t_old, q) {
                t := t_old;
            } else {
                round(T, R) := round(T, R) | (T = t & R = r);
                qc(T, QC) := qc(T, QC) | (T = t & QC = q);
            }
        }
    }
}
export timeout_t.get_round
export timeout_t.get_qc

isolate tc_fplusone_t = {
    type this

    relation round(TC_FPLUSONE:tc_fplusone_t, B:block_t)
    relation timeout(TC_FPLUSONE:tc_fplusone_t, T:timeout_t)
    relation quorum_fplusone(TC_FPLUSONE:tc_fplusone_t, Q_FPLUSONE:quorum_fplusone_t)
}

isolate tc_t = {
    type this

    relation round(TC:tc_t, B:block_t)
    relation timeout(TC:tc_t, T:timeout_t)
    relation quorum(TC:tc_t, Q:quorum_t)
}

isolate proposal_f_t = {
    type this

    relation block(P:proposal_f_t, B:block_t)
    relation qc(P:proposal_f_t, QC:qc_t)
    relation tc(P:proposal_f_t, TC:tc_t)

    action get_block(p:proposal_f_t) returns (b:block_t)
    action get_qc(p:proposal_f_t) returns (qc:qc_t)
    action get_tc(p:proposal_f_t) returns (qc:tc_t)

    action proposal_f(b:block_t, qc:qc_t, tc:tc_t) returns (p:proposal_f_t)

    specification {
        relation valid(P:proposal_f_t)

        after init {
            valid(P) := false;
        }

        before get_block {
            require valid(p);
        }

        after get_block {
            ensure block_t.valid(b);
        }

        before proposal_f {
            require block_t.valid(b);
            assume ~valid(p);
        }

        after proposal_f {
            valid(P) := valid(P) | P = p;
        }

        invariant block(P, B) -> valid(P) & block_t.valid(B)
        invariant valid(P) -> exists B:block_t. block(P, B)
        invariant block(P, B1) & block(P, B2) -> B1 = B2
        invariant block(P1, B) & block(P2, B) -> P1 = P2
    }

    implementation {
        after init {
            block(P, B) := false;
            qc(P, QC) := false;
            tc(P, TC) := false;
        }

        implement get_block(p:proposal_f_t) returns (b:block_t) {
            if some p_b:block_t. block(p, p_b) {
                b := p_b;
            } else {
            }
        }

        implement get_qc(p:proposal_f_t) returns (q:qc_t) {
            if some p_q:qc_t. qc(p, p_q) {
                q := p_q;
            } else {
            }
        }

        implement get_tc(p:proposal_f_t) returns (t:tc_t) {
            if some p_t:tc_t. tc(p, p_t) {
                t := p_t;
            } else {
            }
        }

        implement proposal_f(b:block_t, q:qc_t, t:tc_t) returns (p:proposal_f_t) {
            if some p_old:proposal_f_t. block(p_old, b) & qc(p_old, q) & tc(p_old, t) {
                p := p_old;
            } else {
                block(P, B) := block(P, B) | (P = p & B = b);
                qc(P, QC) := qc(P, QC) | (P = p & QC = q);
                tc(P, TC) := tc(P, TC) | (P = p & TC = t);
            }
        }
    }
}
export proposal_f_t.get_block
export proposal_f_t.get_qc
export proposal_f_t.get_tc
