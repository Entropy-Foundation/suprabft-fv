#lang ivy1.8

include ubd_seq

instance round_t : ubd_seq
instance height_t : ubd_seq

instance node_t : iterable
function leader(R:round_t) : node_t
relation is_good(N:node_t)

isolate hash_t = {
    type this

    individual nil: hash_t
}

isolate block_t = {
    type this = struct {
        round : round_t,
        parent : hash_t
    }
    individual nil : block_t
    function hash(B:block_t) : hash_t
    action consBlock(p:hash_t, r:round_t, n:node_t) returns (b:block_t)

    specification {
        axiom forall B:block_t. B = nil <-> B.parent = hash_t.nil

        axiom hash(X) = hash(Y) -> X = Y
        axiom hash(X) ~= hash_t.nil

        before consBlock(p:hash_t, r:round_t, n:node_t) returns (b:block_t) {
            require ~is_good(n) | p ~= hash_t.nil;
        }

        after consBlock(p:hash_t, r:round_t) returns (b:block_t) {
            ensure b ~= block_t.nil
        }
    }

    implementation {
        implement consBlock(p:hash_t, r:round_t) returns (b:block_t) {
            b.round := r;
            b.parent := p;
        }
    }
}

isolate quorum_t = {
    type this
    relation member(N:node_t, Q:quorum_t)

    specification {
        # only use in proofs
        axiom forall Q:quorum_t. exists N:node_t. is_good(N) & member(N, Q)

        axiom forall Q1:quorum_t. forall Q2:quorum_t. exists N:node_t. is_good(N) & member(N, Q1) & member(N, Q2)
    }
}

isolate voted_t = {
    type this = struct {
        block : block_t
    }
    individual nil : voted_t

    specification {
        axiom forall V:voted_t. V = nil <-> V.block = block_t.nil
    }
}

isolate cert_t = {
    type this = struct {
        block : block_t,
        # every member of cert should have made rcvd_prepare() true for this round
        round : round_t,
        cert : quorum_t
    }
    individual nil : cert_t

    specification {
        axiom forall Qc:cert_t. Qc = nil <-> Qc.block = block_t.nil
        axiom forall Qc:cert_t. Qc ~= nil <-> Qc.round ~= nil.round
        axiom forall N:node_t. quorum_t.member(N, nil.cert)
    }
}

isolate timeout_t = {
    type this = struct {
        round : round_t,
        qc : cert_t
    }
    individual nil : timeout_t

    specification {
        axiom forall T:timeout_t. T ~= nil <-> T.round ~= nil.round
        axiom forall T:timeout_t. T = nil <-> T.qc = cert_t.nil
    }
}

isolate timeout_cert_t = {
    type this = struct {
        round : round_t,
        cert : quorum_t,
        highestQC : cert_t
    }
    individual nil : timeout_cert_t

    specification {
        axiom forall Tc:timeout_cert_t. Tc ~= nil <-> Tc.round ~= nil.round
        axiom forall N:node_t. quorum_t.member(N, nil.cert)
        axiom forall Tc:timeout_cert_t. Tc = nil <-> Tc.highestQC = cert_t.nil
    }
}

isolate proposal_t = {
    type this = struct {
        block : block_t,
        qc : cert_t,
        tc : timeout_cert_t
    }
    individual nil : proposal_t

    specification {
        axiom forall P:proposal_t. P = nil <-> P.block = block_t.nil
        axiom nil.qc = cert_t.nil
        axiom nil.tc = timeout_cert_t.nil
    }
}
