#lang ivy1.8

include ubd_seq

instance round_t : ubd_seq
instance height_t : ubd_seq

instance process_index_t : iterable
relation is_good(N:process_index_t)

function leader(R:round_t) : process_index_t

isolate round_t_conv = {
    relation round_pred_pred(Rp:round_t, Rl:round_t)
    definition  round_pred_pred(Rp, Rl) = forall Rm:round_t. round_t.succ(Rm,Rl) -> round_t.succ(Rp,Rm)
}

# There are two ways to access a type's member. Example
# [block_t.parent(b, p)] is a relation that is set to true when [p] is the parent of [b].
# [block_t.get_parent(b)] is an action that gives us the parent of a valid block [b]. It
# uses the [if some] syntax to get a parent from the [parent] relation.
#
# These are used as per convenience in [algorithm.ivy] and other files. We have some
# invariants set up here that relate the two.
#
# Note that actions where validity can only be determined with global view information are
# placed there. For example, [global_view.qc_get_block] instead of [qc_t.get_block].
isolate block_t = {
    type this

    relation cstd(B:block_t)

    relation round(B:block_t, R:round_t)
    relation parent(B:block_t, P:block_t)
    relation ancestor(B:block_t, A:block_t)
    relation height(B:block_t, H:height_t)

    individual genesis : block_t

    after init {
        cstd(B) := B = genesis;

        round(B, R) := B = genesis & R = 0;
        parent(B, P) := B = genesis & P = genesis;
        ancestor(B, A) := B = genesis & A = genesis;
        height(B, H) := B = genesis & H = 0;
    }

    # action get_round(b:block_t) returns (r:round_t) = {
    #     if some b_r:round_t. round(b, b_r) {
    #         r := b_r;
    #     }
    # }

    # action get_parent(b:block_t) returns (pB:block_t) = {

    #     if some b_pB:block_t. parent(b, b_pB) {
    #         pB := b_pB;
    #     }
    # }

    action get_height(b:block_t) returns (h:height_t) = {

        if some b_h:height_t. height(b, b_h) {
            h := b_h;
        }
    }

    export action block(r_c:round_t, pB:block_t) returns (b:block_t) = {
        assume ~cstd(b);

        round(b, R) := R = r_c;
        #parent(B, P) := parent(B, P) | (B = b & P = pB);
        #ancestor(B, A) := ancestor(B, A) | (B = b & A = pB) | (B = b & ancestor(pB, A));
        height(b, H) := H = height_t.next(get_height(pB));

        cstd(b) := true;
        
        #round(b,r_c) := true;
        parent(b,B) := B = pB;
        ancestor(b,pB) := true;
        ancestor(b,B) := ancestor(pB,B) | B = pB;

        ensure ~ancestor(pB,b);
        ensure ancestor(b,B) -> ((B = pB | ancestor(pB,B)) & ~ ancestor(B,b));
    }

    invariant cstd(genesis)
    invariant round(B, 0) <-> B = genesis
    invariant parent(genesis, P) <-> P = genesis
    invariant ancestor(genesis, A) <-> A = genesis
    invariant height(B, 0) <-> B = genesis

    invariant parent(B, B) <-> B = genesis
    invariant ancestor(B, B) <-> B = genesis

    invariant round(B, R) -> cstd(B)
    invariant parent(B, P) -> cstd(B) & cstd(P)
    invariant ancestor(B, A) -> cstd(B) & cstd(A)
    invariant height(B, H) -> cstd(B)

    relation round_exists(B:block_t)
    definition round_exists(B) = exists R:round_t. round(B, R)
    invariant cstd(B) -> round_exists(B)
    relation parent_exists(B:block_t)
    definition parent_exists(B) = exists P:block_t. parent(B, P)
    invariant cstd(B) -> parent_exists(B)
    invariant cstd(B) -> exists H:height_t. height(B, H)

    invariant round(B, R1) & round(B, R2) -> R1 = R2
    invariant parent(B, P1) & parent(B, P2) -> P1 = P2
    invariant height(B, H1) & height(B, H2) -> H1 = H2

    invariant (parent(B,P) & round(B,Rb) & round(P,Rp) & B ~= genesis) -> Rp < Rb
    invariant (parent(B,P) & height(B,Hb) & height(P,Hp) & B ~= genesis) -> height_t.succ(Hp,Hb)
} with height_t, round_t, types_block_t_requires, types_block_t_ensures

isolate ancestor_transitive_closure_block = {

    property block_t.round_exists(B) | ~ block_t.round_exists(B)
    invariant [i1] block_t.parent(B, P) -> block_t.ancestor(B, P)
    invariant [i2] block_t.ancestor(A1, A2) & block_t.ancestor(A2, A3) -> block_t.ancestor(A1, A3)
    invariant [i4] block_t.ancestor(B, A1) & block_t.ancestor(B, A2) -> A1 = A2 | block_t.ancestor(A1, A2) | block_t.ancestor(A2, A1)
    relation inbetween(D:block_t, A:block_t)
    definition inbetween(D, A) = exists M:block_t. block_t.ancestor(D, M) & block_t.ancestor(M, A)
    invariant [i5] block_t.ancestor(D, A) & ~inbetween(D, A) -> (D = block_t.genesis & A = block_t.genesis) | block_t.parent(D, A)
    invariant [i3] block_t.parent(B,P) & P ~= block_t.genesis -> ~inbetween(B,P)
    invariant [i6] block_t.parent(B, P) -> (B = block_t.genesis & P = block_t.genesis) | (forall B_h,P_h:height_t. block_t.height(B, B_h) & block_t.height(P, P_h) -> height_t.succ(P_h, B_h))
    invariant block_t.parent(B,P) -> (B = block_t.genesis & P = block_t.genesis) | (forall B_r,P_r:round_t. block_t.round(B,B_r) & block_t.round(P,P_r) -> P_r < B_r)
    invariant block_t.parent(B,Bp) & block_t.parent(Bp,Ba) & block_t.round(B,R) & block_t.round(Ba,Ra) & B ~= block_t.genesis -> Ra < R
    invariant block_t.ancestor(D,A) & block_t.round(D,Rd) & block_t.round(A,Ra) & D ~= block_t.genesis -> Ra < Rd
} with block_t, height_t, round_t, types_block_t_requires, types_block_t_ensures

isolate parent_same_implications = {
    invariant ancestor_transitive_closure_block.inbetween(B1,B2) | ~ ancestor_transitive_closure_block.inbetween(B1,B2)

    invariant block_t.parent(B1, P) & block_t.parent(B2, P) & block_t.ancestor(B1, A) -> block_t.ancestor(B2, A)

    attribute macro_finder=false
} with block_t, ancestor_transitive_closure_block.i1, ancestor_transitive_closure_block.i2, ancestor_transitive_closure_block.i3, ancestor_transitive_closure_block.i4, ancestor_transitive_closure_block.inbetween, height_t, types_block_t_requires, types_block_t_ensures

isolate parent_same_implications_height = {
    invariant ancestor_transitive_closure_block.inbetween(B1,B2) | ~ ancestor_transitive_closure_block.inbetween(B1,B2)
    invariant block_t.parent(B1, P) & block_t.parent(B2, P) & block_t.height(B1, H) & B1 ~= block_t.genesis & B2 ~= block_t.genesis -> block_t.height(B2, H)
} with block_t, ancestor_transitive_closure_block, height_t, types_block_t_requires, types_block_t_ensures

isolate round_predecessor = {
    axiom [round_induction] {
        relation rel1(R:round_t)
        #-------------------------
        property rel1(0) & (forall R1,R2:round_t. rel1(R1) & round_t.succ(R1,R2) -> rel1(R2)) -> forall R:round_t. rel1(R2)
    }

    relation pred_exists(R:round_t)
    definition pred_exists(R) = 0 < R -> exists Rp:round_t. round_t.succ(Rp,R)

    property pred_exists(0)
    property pred_exists(R1) & round_t.succ(R1,R2) -> pred_exists(R2)

    property pred_exists(0) & (forall R1,R2:round_t. pred_exists(R1) & round_t.succ(R1,R2) -> pred_exists(R2)) -> forall R:round_t. pred_exists(R2)
    proof {
        apply round_induction
    }
} with block_t, round_t

isolate block_t_conv = {

    property block_t.round_exists(B) | ~ block_t.round_exists(B)

    relation round_lte(Bl:block_t, Bg:block_t)
    definition round_lte(Bl,Bg) = block_t.cstd(Bl) & block_t.cstd(Bg) & (forall Rl,Rg:round_t. block_t.round(Bl,Rl) & block_t.round(Bg,Rg) -> Rl <= Rg)

    relation round_lt(Bl:block_t, Bg:block_t)
    definition round_lt(Bl,Bg) = block_t.cstd(Bl) & block_t.cstd(Bg) & (forall Rl,Rg:round_t. block_t.round(Bl,Rl) & block_t.round(Bg,Rg) -> Rl < Rg)

    relation round_same(B1:block_t,B2:block_t)
    definition round_same(B1,B2) = block_t.cstd(B1) & block_t.cstd(B2) & (forall R1,R2:round_t. block_t.round(B1,R1) & block_t.round(B2,R2) -> R1 = R2)

    relation block_lt_predecessor(B:block_t, R:round_t)
    definition block_lt_predecessor(B,R) = 0 < R & forall Rb,Rp:round_t. block_t.round(B,Rb) & round_t.succ(Rp,R) -> Rb < Rp

    relation block_pred_pred(B:block_t, R:round_t)
    definition block_pred_pred(B,R) = 0 < R & ~ round_t.succ(0,R) & forall Rb:round_t. block_t.round(B,Rb) -> round_t_conv.round_pred_pred(Rb,R)

    invariant round_lte(B1,B2) & round_lte(B2,B3) -> (forall R1,R2,R3:round_t. block_t.round(B1,R1) & block_t.round(B2,R2) & block_t.round(B2,R3) -> R1 <= R2 & R2 <= R3 & R1 <= R3)
    invariant round_lte(B1,B2) & round_lte(B2,B3) -> round_lte(B1,B3)
    invariant block_t.cstd(B) -> round_lte(B,B)
    invariant block_t.cstd(B1) & block_t.cstd(B2) -> round_lte(B1,B2) | round_lte(B2,B1)
    invariant round_lte(B1,B2) & round_lte(B2,B1) & block_t.round(B1,R1) & block_t.round(B2,R2) -> R1 = R2

    #attribute macro_finder=false
} with block_t, round_t, round_predecessor

isolate block_t_conv_p1 = {

    property block_t.round_exists(B) | ~ block_t.round_exists(B)
    

    invariant block_t_conv.round_lt(B1,B2) -> block_t_conv.round_lte(B1,B2)
    invariant block_t_conv.round_lt(B1,B2) & block_t_conv.round_lt(B2,B3) -> (forall R1,R2,R3:round_t. block_t.round(B1,R1) & block_t.round(B2,R2) & block_t.round(B3,R3) -> R1 < R2 & R2 < R3 & R1 < R3)
    invariant block_t_conv.round_lt(B1,B2) & block_t_conv.round_lt(B2,B3) -> block_t_conv.round_lt(B1,B3)
    invariant block_t.cstd(B1) & block_t.cstd(B2) -> block_t_conv.round_lt(B1,B2) | block_t_conv.round_lt(B2,B1) | block_t_conv.round_same(B1,B2)
    #invariant block_t_conv.round_lt(B1,B2) -> ~ block_t_conv.round_lt(B2,B1)

    invariant block_t_conv.round_lte(B1,B2) -> block_t_conv.round_lt(B1,B2) | block_t_conv.round_same(B1,B2)

    invariant block_t_conv.block_lt_predecessor(B,R1) & R1 <= R2 -> block_t_conv.block_lt_predecessor(B,R2)

    invariant block_t_conv.round_lt(B1,B2) & block_t_conv.round_lte(B2,B3) -> block_t_conv.round_lt(B1,B3)

    property round_t.succ(R1,R2) -> R1 < R2

    invariant block_t.cstd(B1) & block_t.cstd(B2) & ~block_t_conv.round_lt(B1,B2) -> block_t_conv.round_lte(B2,B1)

    # invariant round_t_conv.round_pred_pred(Rb,R) & round_t.succ(Rp,R) -> Rb < Rp

    invariant block_t_conv.block_pred_pred(B,R) -> block_t_conv.block_lt_predecessor(B,R)

    attribute macro_finder=false

} with block_t, round_t, round_predecessor, block_t_conv, round_t_conv

isolate proposal_n_t = {
    type this

    relation cstd(P:proposal_n_t)

    relation block(P:proposal_n_t, B:block_t)

    individual genesis : proposal_n_t

    after init {
        cstd(P) := P = genesis;

        block(P, B) := P = genesis & B = block_t.genesis;
    }

    export action get_block(p:proposal_n_t) returns (b:block_t) = {

        if some p_b:block_t. block(p, p_b) {
            b := p_b;
        }
    }

    export action proposal_n(b:block_t) returns (p:proposal_n_t) = {
        assume ~cstd(p);

        if some p_old:proposal_n_t. block(p_old, b) {
            p := p_old;
        } else {
            block(P, B) := block(P, B) | (P = p & B = b);
        }

        cstd(P) := cstd(P) | P = p;
    }

    invariant cstd(genesis)
    invariant block(genesis, B) <-> B = block_t.genesis

    invariant block(P, B) -> cstd(P) & block_t.cstd(B)

    invariant cstd(P) -> exists B:block_t. block(P, B)

    invariant block(P, B1) & block(P, B2) -> B1 = B2
    invariant block(P1, B) & block(P2, B) -> P1 = P2
} with block_t, types_proposal_n_t_ensures, types_proposal_n_t_requires

isolate prepare_t = {
    type this

    relation cstd(P:prepare_t)

    relation block(P:prepare_t, B:block_t)

    individual genesis : prepare_t

    after init {
        cstd(P) := P = genesis;

        block(P, B) := P = genesis & B = block_t.genesis;
    }

    export action get_block(p:prepare_t) returns (b:block_t) = {

        if some p_b:block_t. block(p, p_b) {
            b := p_b;
        }
    }

    export action prepare(b:block_t) returns (p:prepare_t) = {
        assume ~cstd(p);

        if some p_old:prepare_t. block(p_old, b) {
            p := p_old;
        } else {
            block(P, B) := block(P, B) | (P = p & B = b);
        }

        cstd(P) := cstd(P) | P = p;
    }

    invariant cstd(genesis)
    invariant block(genesis, B) <-> B = block_t.genesis

    invariant block(P, B) -> cstd(P) & block_t.cstd(B)

    invariant cstd(P) -> exists B:block_t. block(P, B)

    invariant block(P, B1) & block(P, B2) -> B1 = B2
    invariant block(P1, B) & block(P2, B) -> P1 = P2
} with block_t, types_prepare_t_ensures, types_prepare_t_requires

isolate quorum_fplusone_t = {
    type this

    relation member(Q:quorum_fplusone_t, N:process_index_t)
}

isolate every_quorum_fplusone_good = {
    axiom exists N:process_index_t. is_good(N) & quorum_fplusone_t.member(Q, N)
}

isolate quorum_t = {
    type this

    relation member(Q:quorum_t, N:process_index_t)

    individual genesis : quorum_t
}

isolate genesis_member = {
    axiom quorum_t.member(quorum_t.genesis, N)
}

isolate every_quorum_good = {
    axiom exists N:process_index_t. is_good(N) & quorum_t.member(Q, N)
}

isolate quorum_intersection_axiom = {
    axiom exists N:process_index_t. is_good(N) & quorum_t.member(Q1, N) & quorum_t.member(Q2, N)
}

isolate qc_t = {
    type this

    relation block(QC:qc_t, B:block_t)
    relation quorum(QC:qc_t, Q:quorum_t)

    individual genesis : qc_t

    after init {
        block(genesis, B) := B = block_t.genesis;
        quorum(genesis, Q) := Q = quorum_t.genesis;
    }

    invariant block(genesis, B) <-> B = block_t.genesis
    invariant quorum(genesis, Q) <-> Q = quorum_t.genesis
}

isolate timeout_t = {
    type this

    relation was_constructed(T:timeout_t)

    relation round(T:timeout_t, R:round_t)
    relation qc(T:timeout_t, QC:qc_t)
    relation node(T:timeout_t, N:process_index_t)

    after init {
        was_constructed(T) := false;

        round(T, R) := false;
        qc(T, QC) := false;
        node(T,N) := false;
    }

    export action get_round(t:timeout_t) returns (r:round_t) = {

        if some t_r:round_t. round(t, t_r) {
            r := t_r;
        }
    }

    export action timeout(n:process_index_t, r:round_t, q:qc_t) returns (t:timeout_t) = {
        assume ~was_constructed(t);

        if some t_old:timeout_t. round(t_old, r) & qc(t_old, q) & node(t_old,n) {
            t := t_old;
        } else {
            round(T, R) := round(T, R) | (T = t & R = r);
            qc(T, QC) := qc(T, QC) | (T = t & QC = q);
            node(T,N) := node(T,N) | (T = t) & (N = n)
        }

        was_constructed(T) := was_constructed(T) | T = t;
    }

    invariant round(T, R) -> was_constructed(T)
    invariant qc(T, QC) -> was_constructed(T)
    invariant node(T,N) -> was_constructed(T)

    invariant was_constructed(T) -> exists R:round_t. round(T, R)
    invariant was_constructed(T) -> exists QC:qc_t. qc(T, QC)
    invariant was_constructed(T) -> exists N:process_index_t. node(T,N)

    invariant round(T, R1) & round(T, R2) -> R1 = R2
    invariant qc(T, QC1) & qc(T, QC2) -> QC1 = QC2
    invariant node(T,N1) & node(T,N2) -> N1 = N2
} with types_timeout_t_ensures, types_timeout_t_requires, block_t

isolate tc_fplusone_t = {
    type this

    relation round(TC:tc_fplusone_t, R:round_t)
    relation timeout(TC:tc_fplusone_t, T:timeout_t)
    relation quorum(TC:tc_fplusone_t, Q:quorum_fplusone_t)
}

isolate tc_t = {
    type this

    relation round(TC:tc_t, R:round_t)
    relation timeout(TC:tc_t, T:timeout_t)
    relation quorum(TC:tc_t, Q:quorum_t)
}

isolate tc_t_conv = {
    relation tc_pred_pred(TC:tc_t, R:round_t)
    definition tc_pred_pred(TC,R) = 0 < R & ~ round_t.succ(0,R) & forall Rt:round_t. tc_t.round(TC,Rt) -> round_t_conv.round_pred_pred(Rt,R)

    relation tc_block_same_round(TC:tc_t, B:block_t)
    definition tc_block_same_round(TC,B) = forall Rt,Rb:round_t. tc_t.round(TC,Rt) & block_t.round(B,Rb) -> Rt = Rb
} with tc_t, block_t#, block_t_conv, round_t, round_predecessor

isolate proposal_f_t = {
    type this

    relation was_constructed(P:proposal_f_t)

    relation block(P:proposal_f_t, B:block_t)
    relation tc(P:proposal_f_t, TC:tc_t)

    after init {
        was_constructed(P) := false;

        block(P, B) := false;
        tc(P, TC) := false;
    }

    export action get_block(p:proposal_f_t) returns (b:block_t) = {

        if some p_b:block_t. block(p, p_b) {
            b := p_b;
        }
    }

    export action proposal_f(b:block_t, t:tc_t) returns (p:proposal_f_t) = {
        assume ~was_constructed(p);

        if some p_old:proposal_f_t. block(p_old, b) & tc(p_old, t) {
            p := p_old;
        } else {
            block(P, B) := block(P, B) | (P = p & B = b);
            tc(P, TC) := tc(P, TC) | (P = p & TC = t);
        }

        was_constructed(P) := was_constructed(P) | P = p;
    }

    invariant block(P, B) -> was_constructed(P) & block_t.cstd(B)
    invariant tc(P, TC) -> was_constructed(P)

    invariant was_constructed(P) -> exists B:block_t. block(P, B)
    invariant was_constructed(P) -> exists TC:tc_t. tc(P, TC)

    invariant block(P, B1) & block(P, B2) -> B1 = B2
    invariant tc(P, TC1) & tc(P, TC2) -> TC1 = TC2
} with block_t, types_proposal_f_t_ensures, types_proposal_f_t_requires

isolate types_block_t_requires = {
    # before block_t.get_round(b:block_t) returns (r:round_t) {
    #     require block_t.cstd(b);#_#
    # }

    # before block_t.get_parent(b:block_t) returns (pB:block_t) {
    #     require block_t.cstd(b);
    # }

    before block_t.get_height(b:block_t) returns (h:height_t) {
        require block_t.cstd(b);
    }

    before block_t.block(r_c:round_t, pB:block_t) returns (b:block_t) {
        require r_c > 0;#_#
        require block_t.cstd(pB);#_#
        require block_t.round(pB,R) -> R < r_c;#_#
    }
} with block_t

isolate types_proposal_n_t_requires = {

    before proposal_n_t.get_block(p:proposal_n_t) returns (b:block_t) {
        require proposal_n_t.cstd(p);#_#
    }

    before proposal_n_t.proposal_n(b:block_t) returns (p:proposal_n_t) {
        require block_t.cstd(b);#_#
    }
} with proposal_n_t, block_t

isolate types_prepare_t_requires = {
    before prepare_t.get_block(p:prepare_t) returns (b:block_t) {
        require prepare_t.cstd(p);#_#
    }

    before prepare_t.prepare(b:block_t) returns (p:prepare_t) {
        require block_t.cstd(b);#_#
    }
} with prepare_t, block_t

isolate types_timeout_t_requires = {

    before timeout_t.get_round(t:timeout_t) returns (r:round_t) {
        require timeout_t.was_constructed(t);#_#
    }

} with timeout_t

isolate types_proposal_f_t_requires = {
    before proposal_f_t.get_block(p:proposal_f_t) returns (b:block_t) {
        require proposal_f_t.was_constructed(p);#_#
    }

    before proposal_f_t.proposal_f(b:block_t, t:tc_t) returns (p:proposal_f_t) {
        require block_t.cstd(b);#_#
    }
} with proposal_f_t, block_t

isolate types_block_t_ensures = {
    # after block_t.get_round(b:block_t) returns (r:round_t) {

    #     ensure block_t.round(b, r);

    # }

    # after block_t.get_parent(b:block_t) returns (pB:block_t) {

    #     ensure block_t.parent(b, pB);

    # }

    after block_t.get_height(b:block_t) returns (h:height_t) {

        ensure block_t.height(b, h);

    }

    after block_t.block(r_c:round_t, pB:block_t) returns (b:block_t) {
        ensure block_t.height(pB,Hp) & block_t.height(b,Hb) -> height_t.succ(Hp,Hb);

        ensure block_t.cstd(b);
    }
} with block_t, ancestor_transitive_closure_block

isolate types_proposal_n_t_ensures = {

    after proposal_n_t.get_block(p:proposal_n_t) returns (b:block_t) {

        ensure proposal_n_t.block(p, b);

    }
} with proposal_n_t

isolate types_prepare_t_ensures = {

    after prepare_t.get_block(p:prepare_t) returns (b:block_t) {

        ensure prepare_t.block(p, b);

    }

} with prepare_t

isolate types_timeout_t_ensures = {

    after timeout_t.get_round(t:timeout_t) returns (r:round_t) {

        ensure timeout_t.round(t, r);

    }

} with timeout_t

isolate types_proposal_f_t_ensures = {

    after proposal_f_t.get_block(p:proposal_f_t) returns (b:block_t) {

        ensure proposal_f_t.block(p, b);

    }
} with proposal_f_t