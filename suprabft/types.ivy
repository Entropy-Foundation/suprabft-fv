#lang ivy1.8

include ubd_seq

instance round_t : ubd_seq
instance height_t : ubd_seq

instance process_index_t : iterable
relation is_good(N:process_index_t)

function leader(R:round_t) : process_index_t

isolate round_t_conv = {
    relation round_pred_pred(Rp:round_t, Rl:round_t)
    definition  round_pred_pred(Rp, Rl) = forall Rm:round_t. round_t.succ(Rm,Rl) -> round_t.succ(Rp,Rm)
}

# There are two ways to access a type's member. Example
# [block_t.parent(b, p)] is a relation that is set to true when [p] is the parent of [b].
# [block_t.get_parent(b)] is an action that gives us the parent of a valid block [b]. It
# uses the [if some] syntax to get a parent from the [parent] relation.
#
# These are used as per convenience in [algorithm.ivy] and other files. We have some
# invariants set up here that relate the two.
#
# Note that actions where validity can only be determined with global view information are
# placed there. For example, [global_view.qc_get_block] instead of [qc_t.get_block].
isolate block_t = {
    type this

    relation cstd(B:block_t)

    relation round(B:block_t, R:round_t)
    relation parent(B:block_t, P:block_t)
    relation ancestor(B:block_t, A:block_t)
    relation height(B:block_t, H:height_t)

    individual genesis : block_t

    individual unused : block_t

    after init {
        cstd(B) := B = genesis;

        assume genesis ~= unused;

        round(B, R) := B = genesis & R = 0;
        parent(B, P) := B = genesis & P = genesis;
        ancestor(B, A) := B = genesis & A = genesis;
        height(B, H) := B = genesis & H = 0;
    }

    # action get_round(b:block_t) returns (r:round_t) = {
    #     if some b_r:round_t. round(b, b_r) {
    #         r := b_r;
    #     }
    # }

    # action get_parent(b:block_t) returns (pB:block_t) = {

    #     if some b_pB:block_t. parent(b, b_pB) {
    #         pB := b_pB;
    #     }
    # }

    action get_height(b:block_t) returns (h:height_t) = {

        if some b_h:height_t. height(b, b_h) {
            h := b_h;
        }
    }

    action block(r_c:round_t, pB:block_t) returns (b:block_t) = {
        assume ~cstd(b);
        assume b ~= block_t.unused;

        round(b, R) := R = r_c;
        height(b, H) := H = height_t.next(get_height(pB));

        cstd(b) := true;
        parent(b,B) := B = pB;
        ancestor(b,pB) := true;
        ancestor(b,B) := ancestor(pB,B) | B = pB;

        # ensure ~ancestor(pB,b);
        # ensure ancestor(b,B) -> ((B = pB | ancestor(pB,B)) & ~ ancestor(B,b));
    }
} with height_t, round_t, types_block_t_requires, types_block_t_ensures, block_t_properties

isolate block_t_properties = {

    invariant [genesis_cstd] block_t.cstd(block_t.genesis)
    invariant [unused_not_cstd] ~block_t.cstd(block_t.unused)
    invariant [genesis_round_0] block_t.round(B, 0) <-> B = block_t.genesis
    invariant block_t.parent(block_t.genesis, P) <-> P = block_t.genesis
    invariant block_t.height(B, 0) <-> B = block_t.genesis

    invariant block_t.parent(B, B) <-> B = block_t.genesis

    invariant [round_only_for_cstd] block_t.round(B, R) -> block_t.cstd(B)
    invariant [parent_only_for_cstd] block_t.parent(B, P) -> block_t.cstd(B) & block_t.cstd(P)
    invariant block_t.height(B, H) -> block_t.cstd(B)

    relation round_exists(B:block_t)
    definition round_exists(B) = exists R:round_t. block_t.round(B, R)
    invariant [block_t_inv_round_exists] block_t.cstd(B) -> round_exists(B)
    relation parent_exists(B:block_t)
    definition parent_exists(B) = exists P:block_t. block_t.parent(B, P)
    invariant block_t.cstd(B) -> parent_exists(B)
    relation height_exists(B:block_t)
    definition height_exists(B) = exists H:height_t. block_t.height(B, H)
    invariant [cstd_block_height_exists] block_t.cstd(B) -> height_exists(B)

    invariant [block_t_inv_round_unique] block_t.round(B, R1) & block_t.round(B, R2) -> R1 = R2
    invariant [parent_unique] block_t.parent(B, P1) & block_t.parent(B, P2) -> P1 = P2
    invariant block_t.height(B, H1) & block_t.height(B, H2) -> H1 = H2
    invariant (block_t.parent(B,P) & block_t.height(B,Hb) & block_t.height(P,Hp) & B ~= block_t.genesis) -> height_t.succ(Hp,Hb)

} with block_t, round_t, height_t, types_block_t_requires, types_block_t_ensures

isolate ancestor_transitive_closure_block = {
    invariant [block_genesis_ancestor] block_t.ancestor(block_t.genesis, A) <-> A = block_t.genesis
    invariant block_t.ancestor(B, A) -> block_t.cstd(B) & block_t.cstd(A)
    invariant block_t.ancestor(B, B) <-> B = block_t.genesis

    invariant [block_parent_round_lesser] (block_t.parent(B,P) & block_t.round(B,Rb) & block_t.round(P,Rp) & B ~= block_t.genesis) -> Rp < Rb

    property block_t_properties.round_exists(B) | ~ block_t_properties.round_exists(B)
    invariant [i1] block_t.parent(B, P) -> block_t.ancestor(B, P)
    invariant [i2] block_t.ancestor(A1, A2) & block_t.ancestor(A2, A3) -> block_t.ancestor(A1, A3)
    invariant [i4] block_t.ancestor(B, A1) & block_t.ancestor(B, A2) -> A1 = A2 | block_t.ancestor(A1, A2) | block_t.ancestor(A2, A1)
    relation inbetween(D:block_t, A:block_t)
    definition inbetween(D, A) = exists M:block_t. block_t.ancestor(D, M) & block_t.ancestor(M, A)
    invariant [i5] block_t.ancestor(D, A) & ~inbetween(D, A) -> (D = block_t.genesis & A = block_t.genesis) | block_t.parent(D, A)
    invariant [i3] block_t.parent(B,P) & P ~= block_t.genesis -> ~inbetween(B,P)
    invariant [i6] block_t.parent(B, P) -> (B = block_t.genesis & P = block_t.genesis) | (forall B_h,P_h:height_t. block_t.height(B, B_h) & block_t.height(P, P_h) -> height_t.succ(P_h, B_h))
    invariant block_t.parent(B,P) -> (B = block_t.genesis & P = block_t.genesis) | (forall B_r,P_r:round_t. block_t.round(B,B_r) & block_t.round(P,P_r) -> P_r < B_r)
    invariant block_t.parent(B,Bp) & block_t.parent(Bp,Ba) & block_t.round(B,R) & block_t.round(Ba,Ra) & B ~= block_t.genesis -> Ra < R
    invariant [block_ancestor_lesser_round] block_t.ancestor(D,A) & block_t.round(D,Rd) & block_t.round(A,Ra) & D ~= block_t.genesis -> Ra < Rd
} with block_t, height_t, round_t, block_t_properties, types_block_t_requires, types_block_t_ensures

isolate parent_same_implications = {
    invariant ancestor_transitive_closure_block.inbetween(B1,B2) | ~ ancestor_transitive_closure_block.inbetween(B1,B2)

    invariant block_t.parent(B1, P) & block_t.parent(B2, P) & block_t.ancestor(B1, A) -> block_t.ancestor(B2, A)

    attribute macro_finder=false
} with block_t, ancestor_transitive_closure_block.i1, ancestor_transitive_closure_block.i2, ancestor_transitive_closure_block.i3, ancestor_transitive_closure_block.i4, ancestor_transitive_closure_block.inbetween, height_t, types_block_t_requires, types_block_t_ensures, block_t_properties

isolate parent_same_implications_height = {
    invariant ancestor_transitive_closure_block.inbetween(B1,B2) | ~ ancestor_transitive_closure_block.inbetween(B1,B2)
    invariant block_t.parent(B1, P) & block_t.parent(B2, P) & block_t.height(B1, H) & B1 ~= block_t.genesis & B2 ~= block_t.genesis -> block_t.height(B2, H)
} with block_t, ancestor_transitive_closure_block, height_t, types_block_t_requires, types_block_t_ensures, block_t_properties

isolate round_predecessor = {
    axiom [round_induction] {
        relation rel1(R:round_t)
        #-------------------------
        property rel1(0) & (forall R1,R2:round_t. rel1(R1) & round_t.succ(R1,R2) -> rel1(R2)) -> forall R:round_t. rel1(R2)
    }

    relation pred_exists(R:round_t)
    definition pred_exists(R) = 0 < R -> exists Rp:round_t. round_t.succ(Rp,R)

    property pred_exists(0)
    property pred_exists(R1) & round_t.succ(R1,R2) -> pred_exists(R2)

    property pred_exists(0) & (forall R1,R2:round_t. pred_exists(R1) & round_t.succ(R1,R2) -> pred_exists(R2)) -> forall R:round_t. pred_exists(R2)
    proof {
        apply round_induction
    }
} with block_t, round_t

isolate block_t_conv = {

    property block_t_properties.round_exists(B) | ~ block_t_properties.round_exists(B)

    relation successive_blocks(Bp:block_t, Bc:block_t)
    definition successive_blocks(Bp,Bc) = forall Rp,Rc:round_t. block_t.round(Bp,Rp) & block_t.round(Bc,Rc) -> round_t.succ(Rp,Rc)

    # relation round_lte(Bl:block_t, Bg:block_t)
    # definition round_lte(Bl,Bg) = block_t.cstd(Bl) & block_t.cstd(Bg) & (forall Rl,Rg:round_t. block_t.round(Bl,Rl) & block_t.round(Bg,Rg) -> Rl <= Rg)

    # relation round_lt(Bl:block_t, Bg:block_t)
    # definition round_lt(Bl,Bg) = block_t.cstd(Bl) & block_t.cstd(Bg) & (forall Rl,Rg:round_t. block_t.round(Bl,Rl) & block_t.round(Bg,Rg) -> Rl < Rg)

    # relation round_same(B1:block_t,B2:block_t)
    # definition round_same(B1,B2) = block_t.cstd(B1) & block_t.cstd(B2) & (forall R1,R2:round_t. block_t.round(B1,R1) & block_t.round(B2,R2) -> R1 = R2)

    # relation block_lt_predecessor(B:block_t, R:round_t)
    # definition block_lt_predecessor(B,R) = 0 < R & forall Rb,Rp:round_t. block_t.round(B,Rb) & round_t.succ(Rp,R) -> Rb < Rp

    # relation block_lt_round(B:block_t, R:round_t)
    # definition block_lt_round(B,R) = 0 < R & forall Rb:round_t. block_t.round(B,Rb) -> Rb < R

    # relation block_lte_round(B:block_t, R:round_t)
    # definition block_lte_round(B,R) = forall Rb:round_t. block_t.round(B,Rb) -> Rb <= R

    # relation block_pred_pred(B:block_t, R:round_t)
    # definition [def_block_pred_pred] block_pred_pred(B,R) = 0 < R & ~ round_t.succ(0,R) & forall Rb:round_t. block_t.round(B,Rb) -> round_t_conv.round_pred_pred(Rb,R)

    # relation block_pred(B:block_t, R:round_t)
    # definition [def_block_pred] block_pred(B,R) = forall Rb:round_t. block_t.round(B,Rb) -> round_t.succ(Rb,R)

    # invariant round_lte(B1,B2) & round_lte(B2,B3) -> (forall R1,R2,R3:round_t. block_t.round(B1,R1) & block_t.round(B2,R2) & block_t.round(B2,R3) -> R1 <= R2 & R2 <= R3 & R1 <= R3)
    # invariant round_lte(B1,B2) & round_lte(B2,B3) -> round_lte(B1,B3)
    # invariant block_t.cstd(B) -> round_lte(B,B)
    # invariant block_t.cstd(B1) & block_t.cstd(B2) -> round_lte(B1,B2) | round_lte(B2,B1)
    # invariant round_lte(B1,B2) & round_lte(B2,B1) & block_t.round(B1,R1) & block_t.round(B2,R2) -> R1 = R2

    #attribute macro_finder=false
} with block_t, round_t, round_predecessor, block_t_properties

# isolate block_t_conv_p1 = {

#     property block_t_properties.round_exists(B) | ~ block_t_properties.round_exists(B)
    

#     invariant block_t_conv.round_lt(B1,B2) -> block_t_conv.round_lte(B1,B2)
#     invariant block_t_conv.round_lt(B1,B2) & block_t_conv.round_lt(B2,B3) -> (forall R1,R2,R3:round_t. block_t.round(B1,R1) & block_t.round(B2,R2) & block_t.round(B3,R3) -> R1 < R2 & R2 < R3 & R1 < R3)
#     invariant block_t_conv.round_lt(B1,B2) & block_t_conv.round_lt(B2,B3) -> block_t_conv.round_lt(B1,B3)
#     invariant block_t.cstd(B1) & block_t.cstd(B2) -> block_t_conv.round_lt(B1,B2) | block_t_conv.round_lt(B2,B1) | block_t_conv.round_same(B1,B2)
#     #invariant block_t_conv.round_lt(B1,B2) -> ~ block_t_conv.round_lt(B2,B1)

#     invariant block_t_conv.round_lte(B1,B2) -> block_t_conv.round_lt(B1,B2) | block_t_conv.round_same(B1,B2)

#     invariant block_t_conv.block_lt_predecessor(B,R1) & R1 <= R2 -> block_t_conv.block_lt_predecessor(B,R2)

#     invariant block_t_conv.round_lt(B1,B2) & block_t_conv.round_lte(B2,B3) -> block_t_conv.round_lt(B1,B3)

#     property round_t.succ(R1,R2) -> R1 < R2

#     invariant block_t.cstd(B1) & block_t.cstd(B2) & ~block_t_conv.round_lt(B1,B2) -> block_t_conv.round_lte(B2,B1)

#     # invariant round_t_conv.round_pred_pred(Rb,R) & round_t.succ(Rp,R) -> Rb < Rp

#     invariant block_t_conv.block_pred_pred(B,R) -> block_t_conv.block_lt_predecessor(B,R)

#     attribute macro_finder=false

# } with block_t, round_t, round_predecessor, block_t_conv, round_t_conv, block_t_properties



isolate quorum_fplusone_t = {
    type this

    relation member(Q:quorum_fplusone_t, N:process_index_t)
}

isolate every_quorum_fplusone_good = {
    axiom exists N:process_index_t. is_good(N) & quorum_fplusone_t.member(Q, N)
}

isolate quorum_t = {
    type this

    relation member(Q:quorum_t, N:process_index_t)

    individual genesis : quorum_t
}

isolate genesis_member = {
    axiom quorum_t.member(quorum_t.genesis, N)
}

isolate every_quorum_good = {
    axiom exists N:process_index_t. is_good(N) & quorum_t.member(Q, N)
}

isolate quorum_intersection_axiom = {
    axiom exists N:process_index_t. is_good(N) & quorum_t.member(Q1, N) & quorum_t.member(Q2, N)
}

isolate qc_t = {
    type this

    relation block(QC:qc_t, B:block_t)
    relation quorum(QC:qc_t, Q:quorum_t)

    individual genesis : qc_t

    after init {
        block(genesis, B) := B = block_t.genesis;
        quorum(genesis, Q) := Q = quorum_t.genesis;
    }
}

isolate qc_t_properties = {

    invariant qc_t.block(qc_t.genesis, B) <-> B = block_t.genesis
    invariant qc_t.quorum(qc_t.genesis, Q) <-> Q = quorum_t.genesis
    
} with qc_t

# isolate qc_t_conv = {
#     relation qc_gte_block(QC:qc_t, B:block_t)
#     definition qc_gte_block(QC,B) = forall Bqc:block_t. qc_t.block(QC,Bqc) -> block_t_conv.round_lte(B,Bqc)
# }

object to_kind = {
    type this = {timer_expire, timeout_sync, tc_received}
}

isolate tc_fplusone_t = {
    type this

    relation round(TC:tc_fplusone_t, R:round_t)
    relation quorum(TC:tc_fplusone_t, Q:quorum_fplusone_t)
    relation to_messages(TC:tc_fplusone_t, N:process_index_t, QC:qc_t)
}

isolate tc_t = {
    type this

    relation round(TC:tc_t, R:round_t)
    relation quorum(TC:tc_t, Q:quorum_t)
    relation maxQC(TC:tc_t, QC:qc_t)
    relation to_messages(TC:tc_t, N:process_index_t, QC:qc_t)
}

isolate tc_t_conv = {
    relation tc_pred_pred(TC:tc_t, R:round_t)
    definition tc_pred_pred(TC,R) = 0 < R & ~ round_t.succ(0,R) & forall Rt:round_t. tc_t.round(TC,Rt) -> round_t_conv.round_pred_pred(Rt,R)

    relation tc_pred(TC:tc_t, R:round_t)
    definition tc_pred(TC,R) = 0 < R & forall Rt:round_t. tc_t.round(TC,Rt) -> round_t.succ(Rt,R)

    relation tc_block_same_round(TC:tc_t, B:block_t)
    definition tc_block_same_round(TC,B) = forall Rt,Rb:round_t. tc_t.round(TC,Rt) & block_t.round(B,Rb) -> Rt = Rb
} with tc_t, block_t#, block_t_conv, round_t, round_predecessor

isolate types_block_t_requires = {
    # before block_t.get_round(b:block_t) returns (r:round_t) {
    #     require block_t.cstd(b);#_#
    # }

    # before block_t.get_parent(b:block_t) returns (pB:block_t) {
    #     require block_t.cstd(b);
    # }

    before block_t.get_height(b:block_t) returns (h:height_t) {
        require block_t.cstd(b);
    }

    before block_t.block(r_c:round_t, pB:block_t) returns (b:block_t) {
        require r_c > 0;#_#
        require block_t.cstd(pB);#_#
        require block_t.round(pB,R) -> R < r_c;#_#
    }
} with block_t

isolate types_block_t_ensures = {
    property block_t_properties.height_exists(B) | ~ block_t_properties.height_exists(B)
    # after block_t.get_round(b:block_t) returns (r:round_t) {

    #     ensure block_t.round(b, r);

    # }

    # after block_t.get_parent(b:block_t) returns (pB:block_t) {

    #     ensure block_t.parent(b, pB);

    # }

    after block_t.get_height(b:block_t) returns (h:height_t) {

        ensure block_t.height(b, h);

    }

    after block_t.block(r_c:round_t, pB:block_t) returns (b:block_t) {
        ensure block_t.height(pB,Hp) & block_t.height(b,Hb) -> height_t.succ(Hp,Hb);

        ensure block_t.cstd(b);
    }
} with block_t, height_t, block_t_properties.cstd_block_height_exists, types_block_t_requires, ancestor_transitive_closure_block