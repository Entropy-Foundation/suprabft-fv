#lang ivy1.8

include types
include network
include moonshot

isolate verify_quorum = {
    relation processor_sent_prepare_o(N:process_index_t, B:block_t)
    relation processor_sent_prepare_n(N:process_index_t, B:block_t)
    relation processor_sent_prepare_f(N:process_index_t, B:block_t)

    relation processor_sent_timeout(N:process_index_t, R:round_t, QC:qc_t)

    after init {
        processor_sent_prepare_o(N,B) := B = block_t.unused;
        processor_sent_prepare_n(N,B) := is_good(N) & B = block_t.genesis;
        processor_sent_prepare_f(N,B) := false;
        processor_sent_timeout(N,R,QC) := false;
    }

    instantiate processors

    before processor.optimistic_proposal_processing(id:process_index_t, b_pr:block_t) {
            processor_sent_prepare_o(id,b_pr) := true;
    }

    relation qc_sanity_check(QC:qc_t)
    definition qc_sanity_check(QC) = (exists B:block_t. exists Q:quorum_t. qc_t.block(QC,B) & block_t.cstd(B) & qc_t.quorum(QC,Q)) & (forall B1,B2:block_t. qc_t.block(QC,B1) & qc_t.block(QC,B2) -> B1 = B2) & (forall Q1,Q2:quorum_t. qc_t.quorum(QC,Q1) & qc_t.quorum(QC,Q2) -> Q1 = Q2)

    relation qc_has_quorum_o(QC:qc_t)
    relation qc_has_quorum_n(QC:qc_t)
    relation qc_has_quorum_f(QC:qc_t)

    definition qc_has_quorum_o(QC) = forall B:block_t. forall Q:quorum_t. forall N:process_index_t. qc_t.block(QC,B) & qc_t.quorum(QC,Q) & quorum_t.member(Q,N) & is_good(N) -> processor_sent_prepare_o(N,B)

    definition qc_has_quorum_n(QC) = forall B:block_t. forall Q:quorum_t. forall N:process_index_t. qc_t.block(QC,B) & qc_t.quorum(QC,Q) & quorum_t.member(Q,N) & is_good(N) -> processor_sent_prepare_n(N,B)

    definition qc_has_quorum_f(QC) = forall B:block_t. forall Q:quorum_t. forall N:process_index_t. qc_t.block(QC,B) & qc_t.quorum(QC,Q) & quorum_t.member(Q,N) & is_good(N) -> processor_sent_prepare_f(N,B)

    relation qc_has_quorum(QC:qc_t)
    definition qc_has_quorum(QC) =  qc_has_quorum_o(QC) | qc_has_quorum_n(QC) | qc_has_quorum_f(QC)

    before processor.qc_processing(id:process_index_t, qc:qc_t) {
        require qc_sanity_check(qc) & qc_has_quorum(qc);
    }

    before processor.normal_proposal_processing(id:process_index_t, b_pr:block_t, qc:qc_t) {
            require qc_sanity_check(qc) & qc_has_quorum(qc);
            processor_sent_prepare_n(id,b_pr) := true;
    }

    before processor.timer_expire(id:process_index_t) {
        if processor(id).timeout_condition(processor(id).r_c) {
            processor_sent_timeout(id,processor(id).r_c,processor(id).qc_l) := true;
        }
    }

    before processor.byzantine_send(id:process_index_t, m:msg) {
        if m.kind = msg_kind.prepare_o {
            processor_sent_prepare_o(m.src, m.block) := true;
        }
        if m.kind = msg_kind.prepare_n {
            processor_sent_prepare_n(m.src, m.block) := true;
        }
        if m.kind = msg_kind.prepare_f {
            processor_sent_prepare_f(m.src, m.block) := true;
        }
        if m.kind = msg_kind.timeout {
            processor_sent_timeout(m.src, m.round, m.qc) := true;
        }
    }

    relation tc_sanity_check(TC:tc_t)
    definition tc_sanity_check(TC) = (exists R:round_t. exists Q:quorum_t. exists QC:qc_t. exists N:process_index_t. tc_t.round(TC,R) & tc_t.quorum(TC,Q) & tc_t.maxQC(TC,QC) & tc_t.to_messages(TC,N,QC))
    & (forall R1,R2:round_t. tc_t.round(TC,R1) & tc_t.round(TC,R2) -> R1 = R2)
    & (forall Q1,Q2:quorum_t. tc_t.quorum(TC,Q1) & tc_t.quorum(TC,Q2) -> Q1 = Q2)
    & (forall QC1,QC2:qc_t. tc_t.maxQC(TC,QC1) & tc_t.maxQC(TC,QC2) -> QC1 = QC2)
    & (forall N:process_index_t. forall QC1,QC2:qc_t. tc_t.to_messages(TC,N,QC1) & tc_t.to_messages(TC,N,QC2) -> QC1 = QC2 & qc_sanity_check(QC1) & qc_has_quorum(QC1))
    & (forall N:process_index_t. forall R:round_t. forall QC:qc_t. tc_t.to_messages(TC,N,QC) & is_good(N) & tc_t.round(TC,R) -> processor_sent_timeout(N,R,QC))

    relation tc_has_quorum(TC:tc_t)
    definition tc_has_quorum(TC) = forall Q:quorum_t. forall N:process_index_t. tc_t.quorum(TC,Q) & quorum_t.member(Q,N) & is_good(N) -> (exists QC:qc_t. tc_t.to_messages(TC,N,QC))

    relation tc_maxQC(TC:tc_t)
    definition tc_maxQC(TC) = forall Rq,Rm:round_t. forall Q:quorum_t. forall N:process_index_t. forall QCq,QCm:qc_t. forall Bq,Bm:block_t. tc_t.quorum(TC,Q) & quorum_t.member(Q,N) & tc_t.to_messages
    (TC,N,QCq) & tc_t.maxQC(TC,QCm) & qc_t.block(QCq,Bq) & qc_t.block(QCm,Bm) & block_t.round(Bq,Rq) & block_t.round(Bm,Rm) -> Rq <= Rm

    before processor.tc_processing(id:process_index_t, tc:tc_t) {
        require tc_sanity_check(tc) & tc_has_quorum(tc) & tc_maxQC(tc);
        if forall R:round_t. tc_t.round(tc,R) -> processor(id).timeout_condition(R) {
            if some tc_r:round_t. tc_t.round(tc,tc_r) {
                processor_sent_timeout(id,tc_r,processor(id).qc_l) := true;
            }
        }
    }

    before processor.fallback_proposal_processing(id:process_index_t, b_pr:block_t, tc:tc_t) {
        require tc_sanity_check(tc) & tc_has_quorum(tc) & tc_maxQC(tc);
            processor_sent_prepare_f(id,b_pr) := true;
    }

    relation tc_fpo_sanity_check(TC:tc_fplusone_t)
    definition tc_fpo_sanity_check(TC) = (exists R:round_t. exists Q:quorum_fplusone_t. tc_fplusone_t.round(TC,R) & tc_fplusone_t.quorum(TC,Q))
    & (forall R1,R2:round_t. tc_fplusone_t.round(TC,R1) & tc_fplusone_t.round(TC,R2) -> R1 = R2)
    & (forall Q1,Q2:quorum_fplusone_t. tc_fplusone_t.quorum(TC,Q1) & tc_fplusone_t.quorum(TC,Q2) -> Q1 = Q2)
    & (forall N:process_index_t. forall QC1,QC2:qc_t. tc_fplusone_t.to_messages(TC,N,QC1) & tc_fplusone_t.to_messages(TC,N,QC2) -> QC1 = QC2 & qc_sanity_check(QC1) & qc_has_quorum(QC1))
    & (forall N:process_index_t. forall R:round_t. forall QC:qc_t. tc_fplusone_t.to_messages(TC,N,QC) & is_good(N) & tc_fplusone_t.round(TC,R) -> processor_sent_timeout(N,R,QC))

    relation tc_fpo_has_quorum(TC:tc_fplusone_t)
    definition tc_fpo_has_quorum(TC) = forall Q:quorum_fplusone_t. forall N:process_index_t. tc_fplusone_t.quorum(TC,Q) & quorum_fplusone_t.member(Q,N) & is_good(N) -> (exists QC:qc_t. tc_fplusone_t.to_messages(TC,N,QC))

    before processor.timeout_sync(id:process_index_t, tc:tc_fplusone_t) {
        require tc_fpo_sanity_check(tc) & tc_fpo_has_quorum(tc);
        if forall R:round_t. tc_fplusone_t.round(tc,R) -> processor(id).timeout_condition(R) {
            if some tc_r:round_t. tc_fplusone_t.round(tc,tc_r) {
                processor_sent_timeout(id,tc_r,processor(id).qc_l) := true;
            }
        }
    }

} with block_t