#lang ivy1.8

include types
include network
include local_view

isolate verify_quorum = {
    relation processor_sent_prepare_o(N:process_index_t, B:block_t)
    relation processor_sent_prepare_n(N:process_index_t, B:block_t)
    relation processor_sent_prepare_f(N:process_index_t, B:block_t)

    relation processor_sent_timeout(N:process_index_t, R:round_t, QC:qc_t)

    after init {
        processor_sent_prepare_o(N,B) := false;
        processor_sent_prepare_n(N,B) := is_good(N) & B = block_t.genesis;
        processor_sent_prepare_f(N,B) := false;
        processor_sent_timeout(N,R,QC) := false;
    }

    instantiate processors

    after processor.optimistic_proposal_processing(id:process_index_t, b_pr:block_t) {
        if processor(id).send_prepapre_o_condition(b_pr) {
            processor_sent_prepare_o(id,b_pr) := true;
        }
    }

    after processor.normal_proposal_processing(id:process_index_t, b_pr:block_t, qc:qc_t) {
        if processor(id).send_prepare_n_condition(b_pr,qc) {
            processor_sent_prepare_n(id,b_pr) := true;
        }
    }

    after processor.fallback_proposal_processing(id:process_index_t, b_pr:block_t, tc:tc_t) {
        if processor(id).send_prepare_f_condition(b_pr,tc) {
            processor_sent_prepare_f(id,b_pr) := true;
        }
    }

    relation qc_sanity_check(QC:qc_t)
    definition qc_sanity_check(QC) = (exists B:block_t. exists Q:quorum_t. qc_t.block(QC,B) & block_t.cstd(B) & qc_t.quorum(QC,Q)) & (forall B1,B2:block_t. qc_t.block(QC,B1) & qc_t.block(QC,B2) -> B1 = B2) & (forall Q1,Q2:quorum_t. qc_t.quorum(QC,Q1) & qc_t.quorum(QC,Q2) -> Q1 = Q2)

    relation qc_has_quorum_o(QC:qc_t)
    relation qc_has_quorum_n(QC:qc_t)
    relation qc_has_quorum_f(QC:qc_t)

    definition qc_has_quorum_o(QC) = forall B:block_t. forall Q:quorum_t. forall N:process_index_t. qc_t.block(QC,B) & qc_t.quorum(QC,Q) & quorum_t.member(Q,N) & is_good(N) -> processor_sent_prepare_o(N,B)

    definition qc_has_quorum_n(QC) = forall B:block_t. forall Q:quorum_t. forall N:process_index_t. qc_t.block(QC,B) & qc_t.quorum(QC,Q) & quorum_t.member(Q,N) & is_good(N) -> processor_sent_prepare_n(N,B)

    definition qc_has_quorum_f(QC) = forall B:block_t. forall Q:quorum_t. forall N:process_index_t. qc_t.block(QC,B) & qc_t.quorum(QC,Q) & quorum_t.member(Q,N) & is_good(N) -> processor_sent_prepare_f(N,B)

    relation qc_has_quorum(QC:qc_t)
    definition qc_has_quorum(QC) =  qc_has_quorum_o(QC) | qc_has_quorum_n(QC) | qc_has_quorum_f(QC)

    before processor.qc_processing(id:process_index_t, qc:qc_t) {
        require qc_sanity_check(qc) & qc_has_quorum(qc);
    }

    before processor.normal_proposal_processing(id:process_index_t, b_pr:block_t, qc:qc_t) {
        require qc_sanity_check(qc) & qc_has_quorum(qc);
    }

    after processor.timer_expire(id:process_index_t) {
        if processor(id).timer_expire_to_condition {
            processor_sent_timeout(id,processor(id).r_c,processor(id).qc_l) := true;
        }
    }

    after processor.timeout_sync(id:process_index_t, tc:tc_fplusone_t) {
        if processor(id).timeout_sync_to_condition(tc) {
            if some tc_r:round_t. tc_fplusone_t.round(tc,tc_r) {
                processor_sent_timeout(id,tc_r,processor(id).qc_l) := true;
            }
        }
    }

    after processor.tc_processing(id:process_index_t, tc:tc_t) {
        if processor(id).tc_processing_to_condition(tc) {
            if some tc_r:round_t. tc_t.round(tc,tc_r) {
                processor_sent_timeout(id,tc_r,processor(id).qc_l) := true;
            }
        }
    }

    relation tc_sanity_check(TC:tc_t)
    definition tc_sanity_check(TC) = (exists R:round_t. exists Q:quorum_t. exists QC:qc_t. exists N:process_index_t. tc_t.round(TC,R) & tc_t.quorum(TC,Q) & tc_t.maxQC(TC,QC) & quorum_t.member(Q,N) & processor_sent_timeout(N,R,QC)) & (forall R1,R2:round_t. tc_t.round(TC,R1) & tc_t.round(TC,R2) -> R1 = R2) & (forall Q1,Q2:quorum_t. tc_t.quorum(TC,Q1) & tc_t.quorum(TC,Q2) -> Q1 = Q2) & (forall QC1,QC2:qc_t. tc_t.maxQC(TC,QC1) & tc_t.maxQC(TC,QC2) -> QC1 = QC2)

    relation tc_has_quorum(TC:tc_t)
    definition tc_has_quorum(TC) = forall R:round_t. forall Q:quorum_t. forall N:process_index_t. tc_t.round(TC,R) & tc_t.quorum(TC,Q) & quorum_t.member(Q,N) & is_good(N) -> (exists QC:qc_t. processor_sent_timeout(N,R,QC) & qc_sanity_check(QC) & qc_has_quorum(QC))

    relation tc_maxQC(TC:tc_t)
    definition tc_maxQC(TC) = forall R,Rq,Rm:round_t. forall Q:quorum_t. forall N:process_index_t. forall QCq,QCm:qc_t. forall Bq,Bm:block_t. tc_t.round(TC,R) & tc_t.quorum(TC,Q) & quorum_t.member(Q,N) & processor_sent_timeout(N,R,QCq) & tc_t.maxQC(TC,QCm) & qc_t.block(QCq,Bq) & qc_t.block(QCm,Bm) & block_t.round(Bq,Rq) & block_t.round(Bm,Rm) -> Rq <= Rm

    before processor.tc_processing(id:process_index_t, tc:tc_t) {
        require tc_sanity_check(tc) & tc_has_quorum(tc) & tc_maxQC(tc);
    }

    before processor.fallback_proposal_processing(id:process_index_t, b_pr:block_t, tc:tc_t) {
        require tc_sanity_check(tc) & tc_has_quorum(tc) & tc_maxQC(tc);
    }
} with block_t