#lang ivy1.8

include domain_model
include network_model

module supraBFT(global_view) = {
object process_algo(id:process_index_t) = {
    individual commit_mode : bool
    individual commit_mode_broadcasted_qc : bool
    individual commit_mode_advancedToRound : bool
    individual commit_mode_qc : qc_t
    individual last_committed : block_t

    individual locked : qc_t
    individual r_p : round_t
    individual r_c : round_t
    individual timer : bool
    relation uncommitted(QC:qc_t)
    individual r_v : round_t

    relation received_proposal_n(P:proposal_n_t, Src:process_index_t)
    relation received_proposal_f(P:proposal_f_t, Src:process_index_t)
    relation received_prepare(P:prepare_t, Src:process_index_t)
    relation received_qc(QC:qc_t)
    relation received_timeout(T:timeout_t, Src:process_index_t)
    relation received_tc(TC:tc_t)
    relation received_tc_fplusone(TC:tc_fplusone_t)

    after init {
        commit_mode := false;
        last_committed := block_t.genesis;

        locked := qc_t.genesis;
        r_p := 0;
        r_c := *;
        assume round_t.succ(0, r_c);
        timer := false;
        uncommitted(QC) := false;
        r_v := 0;

        received_proposal_n(P, Src) := P = proposal_n_t.genesis & Src = leader(0);
        received_proposal_f(P, Src) := false;
        received_prepare(P, Src) := P = prepare_t.genesis;
        received_qc(QC) := QC = qc_t.genesis;
        received_timeout(T, Src) := false;
        received_tc(TC) := false;
        received_tc_fplusone(TC) := false;
    }

    implement shim.proposal_n_handler.handle(m:msg) {
        if proposal_n_t.valid(m.prop_n) {
            received_proposal_n(m.prop_n, m.src) := true;
        }
    }

    implement shim.proposal_f_handler.handle(m:msg) {
        if global_view.proposal_f_valid(m.prop_f) {
            received_proposal_f(m.prop_f, m.src) := true;
            received_qc(global_view.proposal_f_get_qc(m.prop_f)) := true;
            received_tc(global_view.proposal_f_get_tc(m.prop_f)) := true;
        }
    }

    implement shim.prepare_handler.handle(m:msg) {
        if prepare_t.valid(m.prep) {
            received_prepare(m.prep, m.src) := true;
        }
    }

    implement shim.qc_handler.handle(m:msg) {
        if global_view.qc_valid(m.qc) {
            received_qc(m.qc) := true;
        }
    }

    implement shim.timeout_handler.handle(m:msg) {
        if global_view.timeout_valid(m.t) {
            received_timeout(m.t, m.src) := true;
            received_qc(global_view.timeout_get_qc(m.t)) := true;
        }
    }

    implement shim.tc_handler.handle(m:msg) {
        if global_view.tc_valid(m.tc) {
            received_tc(m.tc) := true;
        }
    }

    # the requirement for aggregation is strictly stronger than global_view.qc_valid, avoid rewriting all that here
    export action aggregate_prepares(qc:qc_t) = {
        require ~commit_mode;

        require global_view.qc_valid(qc);
        require qc_t.quorum(QC, Q) & qc_t.prepare(QC, P) & quorum_t.member(Q, N) -> received_prepare(P, N);

        received_qc(qc) := true;
    }

    export action aggregate_timeouts_fplusone(tc:tc_fplusone_t) = {
        require ~commit_mode;

        require global_view.tc_fplusone_valid(tc);
        require tc_fplusone_t.quorum(TC, Q) & tc_fplusone_t.timeout(TC, T) & quorum_fplusone_t.member(Q, N) -> received_timeout(T, N);

        received_tc_fplusone(tc) := true;
    }

    export action aggregate_timeouts(tc:tc_t) = {
        require ~commit_mode;

        require global_view.tc_valid(tc);
        require tc_t.quorum(TC, Q) & tc_t.timeout(TC, T) & quorum_t.member(Q, N) -> received_timeout(T, N);

        received_tc(tc) := true;
    }

    action broadcast_proposal_n(p:proposal_n_t) = {
        require ~commit_mode;

        var m : msg;
        m.kind := msg_kind.proposal_n;
        m.prop_n := p;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_proposal_f(p:proposal_f_t) = {
        require ~commit_mode;

        var m : msg;
        m.kind := msg_kind.proposal_f;
        m.prop_f := p;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_prepare(p:prepare_t) = {
        require ~commit_mode;

        var m : msg;
        m.kind := msg_kind.prepare;
        m.prep := p;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_qc(q:qc_t) = {
        require ~commit_mode | (commit_mode & ~commit_mode_broadcasted_qc & ~commit_mode_advancedToRound);

        var m : msg;
        m.kind := msg_kind.qc;
        m.qc := q;
        m.src := id;

        call shim.broadcast(id, m);

        if commit_mode & ~commit_mode_broadcasted_qc & ~commit_mode_advancedToRound {
            commit_mode_broadcasted_qc := true;
        }
    }

    action broadcast_timeout(t:timeout_t) = {
        require ~commit_mode;

        var m : msg;
        m.kind := msg_kind.timeout;
        m.t := t;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_tc(t:tc_t) = {
        require ~commit_mode;

        var m : msg;
        m.kind := msg_kind.tc;
        m.tc := t;
        m.src := id;

        call shim.broadcast(id, m);
    }

    # rewrite this
    # export action byzantine_send = {
        # require ~is_good(id);

        # var m : msg;
        # var dst : process_index_t;
        # if ~is_good(m.src) {
            # if m.kind = msg_kind.proposal & (m.prop.qc ~= cert_t.nil -> qc_valid(m.prop.qc)) & (m.prop.tc ~= timeout_cert_t.nil -> valid_tc(m.prop.tc)) {
                # call shim.send(id, dst, m);
            # }
            # if m.kind = msg_kind.prepare {
                # var r : round_t;
                # var bl: block_t;
                # call shim.send(id, dst, m);
                # call global_view.node_voted(m.src,m.prep,r,bl);
            # }
            # if m.kind = msg_kind.qc & qc_valid(m.qc) {
                # var ok : bool;
                # ok := true;
                # ok := ok & forall H:height_t. ~forest_store(m.qc,H);
                # if ok {
                    # call shim.send(id, dst, m);
                # }
            # }
            # if m.kind = msg_kind.timeout & qc_valid(m.t.qc) {
                # call shim.send(id, dst, m);
                # call global_view.process_index_timeout(m.src,m.t);
            # }
            # if m.kind = msg_kind.tc & valid_tc(m.tc) {
                # call shim.send(id, dst, m);
            # }
        # }
    # }

    export action commit = {
        require commit_mode & commit_mode_broadcasted_qc & commit_mode_advancedToRound;
        if some qc:qc_t. uncommitted(qc) &
                        forall B1,B2:block_t (qc_t.block(qc, B1) & qc_t.block(commit_mode_qc, B2)) ->
                                (block_t.ancestor(B2, B1) & block_t.parent(B1, last_committed)) {
            last_committed := qc_get_block(qc);
            uncommitted(QC) := uncommitted(QC) & (forall B:block_t. qc_t.block(QC, B) -> block_t.ancestor(B, last_committed));

            call global_view.commit(id, last_committed);
        }

        if qc_t.block(commit_mode_qc, last_committed) {
            commit_mode := false;
        }
    }

    action proposeNormal(pB:block_t) = {
        require ~commit_mode;

        var ok := true;
        ok := ok & block_t.get_round(pB) = round_t.prev(r_c);
        ok := ok & leader(r_c) = id;
        ok := ok & r_p < r_c;
        if ok {
            var b := block_t.block(r_c, pB);
            var p := proposal_n_t.proposal_n(b);
            call broadcast_proposal_n(p);
            r_p := r_c;

            call global_view.propose(id, b);
        }
    }

    action advanceToRound(r:round_t) = {
        require ~commit_mode | (commit_mode & commit_mode_broadcasted_qc & ~commit_mode_advancedToRound);

        if r > r_c {
            r_c := r;
            timer := false;
        }

        if commit_mode & commit_mode_broadcasted_qc & ~commit_mode_advancedToRound {
            commit_mode_advancedToRound := true;
        }
    }

    action vote(b:block_t) = {
        require ~commit_mode;

        if block_t.get_round(b) > r_v {
            var p := prepare_t.prepare(b);
            call broadcast_prepare(p);
            r_v := block_t.get_round(b);

            call global_view.vote(id, b);
        }
    }

    action tryLock(qc:qc_t) = {
        require ~commit_mode;

        if block_t.get_round(global_view.qc_get_block(qc)) > block_t.get_round(global_view.qc_get_block(locked)) {
            locked := qc;

            call global_view.lock(id, global_view.qc_get_block(qc));
        }
    }

    action tryCommit(qc:qc_t) = {
        require ~commit_mode;

        if some qcp:qc_t. uncommitted(qcp) & (forall B1,B2:block_t. (qc_t.block(qcp, B1) & qc_t.block(qc, B2)) -> ((exists R1,R2:round_t. round_t.succ(R1, R2) & block_t.round(B1, R1) & block_t.round(B2, R2)) & block_t.parent(B2, B1))) {
            commit_mode_qc := qcp;

            if forall B:block_t. forall QC:qc_t. (block_t.ancestor(global_view.qc_get_block(commit_mode_qc), B) & block_t.ancestor(B, last_committed) & qc_t.block(QC, B)) -> uncommitted(QC) {
                commit_mode := true;
                commit_mode_broadcasted_qc := false;
                commit_mode_advancedToRound := false;
            }
        } else {}
        if some qcp:qc_t. uncommitted(qcp) & (forall B1,B2:block_t. (qc_t.block(qc, B1) & qc_t.block(qcp, B2)) -> ((exists R1,R2:round_t. round_t.succ(R1, R2) & block_t.round(B1, R1) & block_t.round(B2, R2)) & block_t.parent(B2, B1))) {
            commit_mode_qc := qc;

            if forall B:block_t. forall QC:qc_t. (block_t.ancestor(global_view.qc_get_block(commit_mode_qc), B) & block_t.ancestor(B, last_committed) & qc_t.block(QC, B)) -> uncommitted(QC) {
                commit_mode := true;
                commit_mode_broadcasted_qc := false;
                commit_mode_advancedToRound := false;
            }
        } else {}
    }

    export action qc_processing(qc:qc_t) = {
        require ~commit_mode;

        require received_qc(qc);

        uncommitted(QC) := uncommitted(QC) | QC = qc;
        r_v := block_t.get_round(global_view.qc_get_block(qc)) if block_t.get_round(global_view.qc_get_block(qc)) > r_v else r_v;
        call proposeNormal(global_view.qc_get_block(qc));
        call tryLock(qc);
        call tryCommit(qc);
        call broadcast_qc(qc);
        call advanceToRound(round_t.next(round_t.next(block_t.get_round(global_view.qc_get_block(qc)))));
    }

    export action proposal_n_processing(p:proposal_n_t) = {
        require ~commit_mode;

        require received_proposal_n(p, leader(round_t.prev(r_c)));

        var ok := true;
        ok := ok & ~timer;
        ok := ok & block_t.get_round(proposal_n_t.get_block(p)) = round_t.prev(r_c);
        ok := ok & block_t.get_parent(proposal_n_t.get_block(p)) = global_view.qc_get_block(locked);

        if ok {
            call proposeNormal(proposal_n_t.get_block(p));
            call vote(proposal_n_t.get_block(p));
        }
    }

    action proposeFR(tc:tc_t) = {
        require ~commit_mode;
        # makes sure round_t.prev(round_t.prev(r_c)) makes sense
        assert r_c > 0;
        assert round_t.next(r_c) > 0;

        var ok := true;
        ok := ok & global_view.tc_get_round(tc) = round_t.prev(round_t.prev(r_c));
        ok := ok & leader(r_c) = id;
        ok := ok & r_p < r_c;

        if ok {
            var qcp := global_view.qc_maxQC(locked, global_view.tc_getMaxQC(tc));
            var b := block_t.block(r_c, global_view.qc_get_block(qcp));
            var p := proposal_f_t.proposal_f(b, qcp, tc);
            call broadcast_proposal_f(p);
            r_p := r_c;
        }
    }

    export action timeout = {
        require ~commit_mode;

        require ~timer;
        timer := true;

        var t := timeout_t.timeout(round_t.prev(r_c), locked);
        call broadcast_timeout(t);
    }

    export action timeout_sync(tc:tc_fplusone_t) = {
        require ~commit_mode;

        require received_tc_fplusone(tc);

        require global_view.tc_fplusone_get_round(tc) >= round_t.prev(round_t.prev(r_c));
        var t := timeout_t.timeout(global_view.tc_fplusone_get_round(tc), locked);
        call broadcast_timeout(t);
    }

    export action tc_processing(tc:tc_t) = {
        require ~commit_mode;

        require received_tc(tc);

        call advanceToRound(round_t.next(round_t.next(global_view.tc_get_round(tc))));
        if forall P:proposal_f_t. ~(received_proposal_f(P, leader(round_t.next(global_view.tc_get_round(tc))))) {
            call proposeFR(tc);
        }
    }

    export action proposal_f_processing(p:proposal_f_t) = {
        require ~commit_mode;

        require received_proposal_f(p, leader(round_t.prev(r_c)));

        require ~timer;
        require block_t.get_round(proposal_f_t.get_block(p)) = round_t.prev(r_c);
        require global_view.tc_get_round(global_view.proposal_f_get_tc(p)) = round_t.prev(round_t.prev(block_t.get_round(proposal_f_t.get_block(p))));
        require block_t.get_parent(proposal_f_t.get_block(p)) = global_view.qc_get_block(global_view.qc_maxQC(global_view.proposal_f_get_qc(p), global_view.tc_getMaxQC(global_view.proposal_f_get_tc(p))));

        call proposeNormal(proposal_f_t.get_block(p));
        call vote(proposal_f_t.get_block(p));
    }
} # object process_algo
} # module supraBFT
