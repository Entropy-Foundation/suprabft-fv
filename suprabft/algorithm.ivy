#lang ivy1.8

include domain_model

module supraBFT(global_view) = {
object process(id:process_index_t) = {
    individual locked : qc_t
    individual r_p : round_t
    individual r_c : round_t
    individual timer : bool
    relation uncommitted(QC:qc_t);
    individual r_v : round_t

    relation received_proposal_n(P:proposal_n_t, Src:process_index_t)
    relation received_proposal_f(P:proposal_f_t, Src:process_index_t)
    relation received_prepare(P:prepare_t, Src:process_index_t)
    relation received_qc(QC:qc_t)
    relation received_timeout(T:timeout_t, Src:process_index_t)
    relation received_tc(TC:tc_t)
    relation received_tc_fplusone(TC:tc_fplusone_t)

    function blockchain(H:height_t) : block_t
    individual chain_size : height_t

    after init {
        locked := qc_t.genesis;
        r_p := 0;
        r_c := *;
        assume round_t.succ(0, r_c);
        timer := false;
        uncommitted(QC) := false;
        r_v := 0;

        received_proposal_n(P, Src) := false;
        received_proposal_f(P, Src) := false;
        received_prepare(P, Src) := P = prepare_t.genesis;
        received_qc(QC) := QC = qc_t.genesis;
        received_timeout(T, Src) := false;
        received_tc(TC) := false;
        received_tc_fplusone(TC) := false;

        blockchain(0) := block_t.genesis;
        chain_size := 0;
    }

    implement shim.proposal_n_handler.handle(m:msg) {
        if proposal_n_t.valid(m.prop_n) {
            received_proposal_n(m.prop_n, m.src) := true;
        }
    }

    implement shim.proposal_f_handler.handle(m:msg) {
        if proposal_f_t.valid(m.prop_f) {
            if (global_view.valid_qc(proposal_f_t.get_qc(m.prop_f)) & global_view.valid_tc(proposal_f_t.get_tc(m.prop_f))) {
                received_proposal_f(m.prop_f, m.src) := true;
                received_qc(proposal_f_t.get_qc(m.prop_f)) := true;
                received_tc(proposal_f_t.get_tc(m.prop_f)) := true;
            }
        }
    }

    implement shim.prepare_handler.handle(m:msg) {
        if prepare_t.valid(m.prep) {
            received_prepare(m.prep, m.src) := true;
        }
    }

    # rewrite this
    export action aggregate_prepares(qc:qc_t) = {
        received_qc(qc) := true;
    }

    implement shim.qc_handler.handle(m:msg) {
        if global_view.valid_qc(m.qc) {
            received_qc(m.qc) := true;
        }
    }

    implement shim.timeout_handler.handle(m:msg) {
        if timeout_t.valid(m.t) {
            if global_view.valid_qc(timeout_t.get_qc(m.t)) {
                received_timeout(m.t, m.src) := true;
                received_qc(timeout_t.get_qc(m.t)) := true;
            }
        }
    }

    # rewrite this
    export action aggregate_timeouts_fplusone(tc:tc_fplusone_t) = {
        received_tc_fplusone(tc) := true;
    }

    # rewrite this
    export action aggregate_timeouts(tc:tc_t) = {
        received_tc(tc) := true;
    }

    implement shim.tc_handler.handle(m:msg) {
        if global_view.valid_tc(m.tc) {
            received_tc(m.tc) := true;
        }
    }

    action broadcast_proposal_n(p:proposal_n_t) = {
        var m : msg;
        m.kind := msg_kind.proposal_n;
        m.prop_n := p;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_proposal_f(p:proposal_f_t) = {
        var m : msg;
        m.kind := msg_kind.proposal_f;
        m.prop_f := p;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_prepare(p:prepare_t) = {
        var m : msg;
        m.kind := msg_kind.prepare;
        m.prep := p;
    	m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_qc(q:qc_t) = {
        var m : msg;
        m.kind := msg_kind.qc;
        m.qc := q;
    	m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_timeout(t:timeout_t) = {
        var m : msg;
        m.kind := msg_kind.timeout;
        m.t := t;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_tc(t:tc_t) = {
        var m : msg;
        m.kind := msg_kind.tc;
        m.tc := t;
    	m.src := id;

        call shim.broadcast(id, m);
    }

   # rewrite this
    export action byzantine_send = {
        require ~is_good(id);

        var m : msg;
        var dst : process_index_t;
        if ~is_good(m.src) {
            if m.kind = msg_kind.proposal & (m.prop.qc ~= cert_t.nil -> valid_qc(m.prop.qc)) & (m.prop.tc ~= timeout_cert_t.nil -> valid_tc(m.prop.tc)) {
                call shim.send(id, dst, m);
            }
            if m.kind = msg_kind.prepare {
                var r : round_t;
                var bl: block_t;
                call shim.send(id, dst, m);
                call global_view.node_voted(m.src,m.prep,r,bl);
            }
            if m.kind = msg_kind.qc & valid_qc(m.qc) {
                var ok : bool;
                ok := true;
                ok := ok & forall H:height_t. ~forest_store(m.qc,H);
                if ok {
                    call shim.send(id, dst, m);
                }
            }
            if m.kind = msg_kind.timeout & valid_qc(m.t.qc) {
                call shim.send(id, dst, m);
                call global_view.process_index_timeout(m.src,m.t);
            }
            if m.kind = msg_kind.tc & valid_tc(m.tc) {
                call shim.send(id, dst, m);
            }
        }
    }

    action commit(b:block_t) = {
        if forall B:block_t. (block_t.ancestor(b, B) & block_t.ancestor(B, blockchain(chain_size))) -> uncommitted(B) {
            blockchain(H) := blockchain(H) if H <= chain_size else *;
            assume H > chain_size & H < block_t.get_height(b) -> ancestor(b, blockchain(H)) & (block_t.get_height(blockchain(H)) = H);
            chain_size := block_t.get_height(b);
            blockchain(chain_size) := b;

            uncommitted(QC) := uncommitted(QC) if (block_t.get_height(qc_t.get_block(QC)) > chain_size) & block_t.ancestor(qc_t.get_block(QC), b) else false;
        }
    }

    action proposeNormal(pB:block_t) = {
        var ok := true;
        ok := ok & block_t.get_round(pB) = round_t.prev(r_c);
        ok := ok & leader(r_c) = id;
        ok := ok & r_p < r_c;
        if ok {
            var b := block_t.block(r_c, pB);
            var p := proposal_n_t.proposal_n(b);
            call broadcast_proposal_n(p);
            r_p := r_c;
        }
    }

    action advanceToRound(r:round_t) = {
        if r > r_c {
            r_c := r;
            timer := false;
        }
    }

    action vote(b:block_t) = {
        if block_t.get_round(b) > r_v {
            var p := prepare_t.prepare(b);
            call broadcast_prepare(p);
            r_v := block_t.get_round(b);
        }
    }

    action tryLock(qc:qc_t) = {
        if block_t.get_round(qc_t.get_block(qc)) > block_t.get_round(qc_t.get_block(locked)) {
            locked := qc;
        }
    }

    action tryCommit(qc:qc_t) = {
        if some qcp:qc_t. uncommitted(qcp) & round_t.next(block_t.get_round(qc_t.get_block(qcp))) = block_t.get_round(qc_t.get_block(qc)) & qc_t.get_block(qcp) = block_t.get_parent(qc_t.get_block(qc)) {
            call commit(qc_t.get_block(qcp));
        } else {}
        if some qcp:qc_t. uncommitted(qcp) & round_t.next(block_t.get_round(qc_t.get_block(qc))) = block_t.get_round(qc_t.get_block(qcp)) & qc_t.get_block(qc) = block_t.get_parent(qc_t.get_block(qcp)) {
            call commit(qc_t.get_block(qc));
        } else {}
    }

    export action qc_processing(qc:qc_t) = {
        require received_qc(qc);

        uncommitted(QC) := uncommitted(QC) | QC = qc;
        r_v := block_t.get_round(qc_t.get_block(qc)) if block_t.get_round(qc_t.get_block(qc)) > r_v else r_v;
        call proposeNormal(qc_t.get_block(qc));
        call tryLock(qc);
        call tryCommit(qc);
        call broadcast_qc(qc);
        call advanceToRound(round_t.next(round_t.next(block_t.get_round(qc_t.get_block(qc)))));
    }

    export action proposal_n_processing(p:proposal_n_t) = {
        require received_proposal_n(p, leader(round_t.prev(r_c)));

        require ~timer;
        require block_t.get_round(proposal_n_t.get_block(p)) = round_t.prev(r_c);
        require block_t.get_parent(proposal_n_t.get_block(p)) = qc_t.get_block(locked);

        call proposeNormal(proposal_n_t.get_block(p));
        call vote(proposal_n_t.get_block(p));
    }

    action proposeFR(tc:tc_t) = {
        var ok := true;
        ok := ok & tc_t.get_round(tc) = round_t.prev(round_t.prev(r_c));
        ok := ok & leader(r_c) = id;
        ok := ok & r_p < r_c;

        if ok {
            var qcp := global_view.maxQC(locked, global_view.getMaxQC(tc));
            var b := block_t.block(r_c, qc_t.get_block(qcp));
            var p := proposal_f_t.proposal_f(b, qcp, tc);
            call broadcast_proposal_f(p);
            r_p := r_c;
        }
    }

    export action timeout = {
        require ~timer;
        timer := true;

        var t := timeout_t.timeout(round_t.prev(r_c), locked);
        call broadcast_timeout(t);
    }

    export action timeout_sync(tc:tc_fplusone_t) = {
        require received_tc_fplusone(tc);

        require r >= round_t.prev(round_t.prev(r_c));
        var t := timeout_t.timeout(tc_fplusone_t.get_round(tc), locked);
        call broadcast_timeout(t);
    }

    export action tc_processing(tc:tc_t) = {
        require received_tc(tc);

        call advanceToRound(round_t.next(round_t.next(tc_t.get_round(tc))));
        if forall P:proposal_f_t. ~(proposal_f_t.get_round(P) = round_t.next(tc_t.get_round(tc)) & received_proposal_f(P, leader(proposal_f_t.get_round(P)))) {
            call proposeFR(tc);
        }
    }

    export action proposal_f_processing(p:proposal_f_t) = {
        require received_proposal_f(p, leader(round_t.prev(r_c)));

        require ~timer;
        require block_t.get_round(proposal_f_t.get_block(p)) = round_t.prev(r_c);
        require tc_t.get_round(proposal_f_t.get_tc(p)) = round_t.prev(round_t.prev(block_t.get_round(proposal_f_t.get_block(p))));
        require block_t.get_parent(proposal_f_t.get_block(p)) = qc_t.get_block(global_view.maxQC(proposal_f_t.get_qc(p), tc_t.getMaxQC(proposal_f_t.get_tc(p))));

        call proposeNormal(proposal_f_t.get_block(p));
        call vote(proposal_f_t.get_block(p));
    }
} # object validator
} # module supraBFT
