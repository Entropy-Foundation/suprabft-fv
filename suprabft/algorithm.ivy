#lang ivy1.8

include domain_model

module moonshot(global_view) = {
object process(id:node_t) = {
    individual locked : qc_t
    individual proposed : round_t
    individual r_c : round_t
    individual timer : bool
    relation uncommitted(QC:qc_t);
    individual voted : round_t

    relation qc_processed(QC:qc_t)
    relation tc_processed(TC:tc_t)

    relation received_proposal_n(P:proposal_n_t, Src:node_t)
    relation received_proposal_f(P:proposal_f_t, Src:node_t)
    relation received_prepare(P:prepare_t, Src:node_t)
    relation received_qc(Qc:qc_t)
    relation received_timeout(T:timeout_t, Src:node_t)
    relation received_tc(Tc:tc_t)

    function blockchain(H:height_t) : block_t
    individual chain_size : height_t

    after init {
        locked := qc_t.genesis;
        proposed := 0;
        r_c := *;
        assume round_t.succ(0, r_c);
        timer := false;
        uncommitted(QC) := false;
        voted := 0;

        qc_processed(QC) := false;
        tc_processed(TC) := false;

        received_proposal_n(P, Src) := false;
        received_proposal_f(P, Src) := false;
        received_prepare(P, Src) := false;
        received_qc(Qc) := false;
        received_timeout(T, Src) := false;
        received_tc(Tc) := false;

        blockchain(0) := block_t.genesis;
        chain_size := 0;
    }

    implement shim.proposal_n_handler.handle(m:msg) {
        if proposal_n_t.valid(m.prop_n) {
            if block_t.valid(proposal_n_t.get_block(m.prop_n)) {
                received_proposal_n(m.prop_n, m.src) := true;
            }
        }
    }

    implement shim.proposal_f_handler.handle(m:msg) {
        if proposal_f_t.valid(m.prop_f) {
            if (global_view.valid_qc(proposal_f_t.get_qc(m.prop_f)) & global_view.valid_tc(proposal_f_t.get_tc(m.prop_f))) {
                received_proposal_f(m.prop_f, m.src) := true;
                received_qc(proposal_f_t.get_qc(m.prop_f)) := true;
                received_tc(proposal_f_t.get_tc(m.prop_f)) := true;
            }
        }
    }

    implement shim.prepare_handler.handle(m:msg) {
        if prepare_t.valid(m.prep) {
            received_prepare(m.prep, m.src) := true;
        }
    }

    export action aggregate_prepares(qc:qc_t) = {
        require forall N:node_t. quorum_t.member(qc_t.get_quorum(qc), N) -> received_prepare(qc_t.get_block(qc), N);

        received_qc(qc) := true;
    }

    implement shim.qc_handler.handle(m:msg) {
        if global_view.valid_qc(m.qc) {
            received_qc(m.qc) := true;
        }
    }

    implement shim.timeout_handler.handle(m:msg) {
        if timeout_t.valid(m.t) {
            if global_view.valid_qc(timeout_t.get_qc(m.t)) {
                received_timeout(m.t, m.src) := true;
                received_qc(timeout_t.get_qc(m.t)) := true;
            }
        }
    }

    export action aggregate_timeouts(tc:tc_t) = {
        require forall N:node_t. quorum_t.member(tc_t.get_quorum(tc), N) -> exists T:timeout_t. T.round = tc_t.get_round(tc) & received_timeout(T, N) & qc_t.get_round(tc_t.getMaxQC(tc)) >= qc_t.get_round(timeout_t.get_qc(T));
        require exists N:node_t. exists T:timeout_t. quorum_t.member(tc_t.get_quorum(tc), N) -> T.round = tc_t.get_round(tc) & received_timeout(T, N) & tc_t.getMaxQC(tc) = timeout_t.get_qc(T);
        require valid_qc(tc.highestQC);

        received_tc(tc) := true;
    }

    implement shim.tc_handler.handle(m:msg) {
        if global_view.valid_tc(m.tc) {
            received_tc(m.tc) := true;
        }
    }

    action broadcast_proposal_n(p:proposal_n_t) = {
        var m : msg;
        m.kind := msg_kind.proposal_n;
        m.prop_n := p;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_proposal_f(p:proposal_f_t) = {
        var m : msg;
        m.kind := msg_kind.proposal_f;
        m.prop_f := p;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_prepare(p:prepare_t) = {
        var m : msg;
        m.kind := msg_kind.prepare;
        m.prep := p;
    	m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_qc(q:qc_t) = {
        var m : msg;
        m.kind := msg_kind.qc;
        m.qc := q;
    	m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_timeout(t:timeout_t) = {
        var m : msg;
        m.kind := msg_kind.timeout;
        m.t := t;
        m.src := id;

        call shim.broadcast(id, m);
    }

    action broadcast_tc(t:tc_t) = {
        var m : msg;
        m.kind := msg_kind.tc;
        m.tc := t;
    	m.src := id;

        call shim.broadcast(id, m);
    }

    action commit(b:block_t) = {
        if forall B:block_t. (block_t.ancestor(b, B) & block_t.ancestor(B, blockchain(chain_size))) -> uncommitted(B) {
            blockchain(H) := blockchain(H) if H <= chain_size else *;
            assume H > chain_size & H < block_t.get_height(b) -> ancestor(b, blockchain(H)) & (block_t.get_height(blockchain(H)) = H);
            chain_size := block_t.get_height(b);
            blockchain(chain_size) := b;

            uncommitted(QC) := uncommitted(QC) if block_t.get_height(qc_t.get_block(QC)) <= chain_size else false;
        }
    }

    export action byzantine_send = {
        require ~is_good(id);

        var m : msg;
        var dst : node_t;
        if ~is_good(m.src) {
            if m.kind = msg_kind.proposal & (m.prop.qc ~= cert_t.nil -> valid_qc(m.prop.qc)) & (m.prop.tc ~= timeout_cert_t.nil -> valid_tc(m.prop.tc)) {
                call shim.send(id, dst, m);
            }
            if m.kind = msg_kind.prepare {
                var r : round_t;
                var bl: block_t;
                call shim.send(id, dst, m);
                call global_view.node_voted(m.src,m.prep,r,bl);
            }
            if m.kind = msg_kind.qc & valid_qc(m.qc) {
                var ok : bool;
                ok := true;
                ok := ok & forall H:height_t. ~forest_store(m.qc,H);
                if ok {
                    call shim.send(id, dst, m);
                }
            }
            if m.kind = msg_kind.timeout & valid_qc(m.t.qc) {
                call shim.send(id, dst, m);
                call global_view.node_timeout(m.src,m.t);
            }
            if m.kind = msg_kind.tc & valid_tc(m.tc) {
                call shim.send(id, dst, m);
            }
        }
    }

    action proposeNormal(pB:block_t) = {
        var ok := true;
        ok := ok & block_t.get_round(pB) = round_t.prev(r_c);
        ok := ok & leader(r_c) = id;
        ok := ok & proposed < r_c;
        if ok {
            var b := block_t.block(r_c, pB);
            var p := proposal_n_t.proposal_n(b);
            call broadcast_proposal_n(p);
            proposed := r_c;
        }
    }

    action advanceToRound(r:round_t) = {
        if r > r_c {
            r_c := r;
            timer := false;
        }
    }

    action vote(b:block_t) = {
        if block_t.get_round(b) > voted {
            var p : prepare_t.prepare(b);
            call broadcast_prepare(p);
            voted := block_t.get_round(b);
        }
    }

    action tryLock(qc:qc_t) = {
        if block_t.get_round(qc_t.get_block(qc)) > block_t.get_round(qc_t.get_block(locked)) {
            locked := qc;
        }
    }

    action tryCommit(qc:qc_t) = {
        if some qcp:qc_t. uncommitted(qcp) & round_t.next(block_t.get_round(qc_t.get_block(qcp))) = block_t.get_round(qc_t.get_block(qc)) & qc_t.get_block(qcp) = block_t.get_parent(qc_t.get_block(qc)) {
            call commit(qc_t.get_block(qcp));
        } else {}
        if some qcp:qc_t. uncommitted(qcp) & round_t.next(block_t.get_round(qc_t.get_block(qc))) = block_t.get_round(qc_t.get_block(qcp)) & qc_t.get_block(qc) = block_t.get_parent(qc_t.get_block(qcp)) {
            call commit(qc_t.get_block(qc));
        } else {}
    }

    export action qc_processing(qc:qc_t) = {
        require qc_t.valid(qc);
        require forall N:node_t. quorum_t.member(qc_t.get_quorum(qc), N) -> received_prepare(qc_t.get_block(qc));
        require forall QC:qc_t. qc_processed(QC) -> (block_t.get_round(qc_t.get_block(QC)) ~= block_t.get_round(qc_t.get_block(qc)));

        qc_processed(qc) := true;

        uncommitted(QC) := uncommitted(QC) | QC = qc;
        voted := block_t.get_round(qc_t.get_block(qc)) if block_t.get_round(qc_t.get_block(qc)) > voted else voted;
        call proposeNormal(qc_t.get_block(qc));
        call tryLock(qc);
        call tryCommit(qc);
        call broadcast_qc(qc);
        call advanceToRound(round_t.next(round_t.next(block_t.get_round(qc_t.get_block(qc)))));
    }

    export action proposal_n_processing(p:proposal_n_t) = {
        require proposal_n_t.valid(p);
        require received_proposal_n(p, leader(round_t.prev(r_c)));
        require ~timer;
        require block_t.get_round(proposal_n_t.get_block(p)) = round_t.prev(r_c);
        require block_t.get_parent(proposal_n_t.get_block(p)) = qc_t.get_block(locked);

        call proposeNormal(proposal_n_t.get_block(p));
        call vote(proposal_n_t.get_block(p));
    }

    action proposeFR(tc:tc_t) = {
        var ok := true;
        ok := ok & tc_t.get_round(tc) = round_t.prev(round_t.prev(r_c));
        ok := ok & leader(r_c) = id;
        ok := ok & proposed < r_c;

        if ok {
            var qcp := qc_t.maxQC(locked, tc_t.getMaxQC(tc));
            var b := block_t.block(r_c, qc_t.get_block(qcp));
            var p := proposal_f_t.proposal_f(b, qcp, tc);
            call broadcast_proposal_f(p);
            proposed := r_c;
        }
    }

    action timeout(r:round_t) = {
        var t := timeout_t.timeout(r, locked);
        call broadcast_timeout(t);
    }

    export action fallback = {
        require ~timer;

        timer := true;
        call timeout(round_t.prev(r_c));
    }

    export action timeout_sync(timeout_small_quorum) = {
        require quorum_member -> received_timeout
        require quorum_member -> qc_processed()
        require r >= round_t.prev(round_t.prev(r_c));

        call timeout(r);
        call advanceToRound(round_t.next(r));
    }

    export action tc_processing(tc:tc_t) = {
        require quorum_member -> received_timeout
        require quorum_member -> qc_processed()

        call advanceToRound(round_t.next(round_t.next(tc_t.get_round(tc))));
        if forall P:proposal_f_t. ~(proposal_f_t.get_round(P) = round_t.next(tc_t.get_round(tc)) & received_proposal_f(P, leader(proposal_f_t.get_round(P)))) {
            call proposeFR(tc);
        }
    }

    export action proposal_f_processing(p:proposal_f_t) = {
        require proposal_f_t.valid(p);
        require received_proposal_f(p, leader(round_t.prev(r_c)));
        require qc_processed(proposal_f_t.get_qc(p));
        require tc_processed(proposal_f_t.get_tc(p));
        require ~timer;
        require block_t.get_round(proposal_f_t.get_block(p)) = round_t.prev(r_c);
        require tc_t.get_round(proposal_f_t.get_tc(p)) = round_t.prev(round_t.prev(r_c));
        require block_t.get_parent(proposal_f_t.get_block(p)) = qc_t.get_block(qc_t.maxQC(proposal_f_t.get_qc(p), tc_t.getMaxQC(proposal_f_t.get_tc(p))));

        call proposeNormal(proposal_f_t.get_block(p));
        call vote(proposal_f_t.get_block(p));
    }
} # object validator
} # module moonshot
