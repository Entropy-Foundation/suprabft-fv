#lang ivy1.8

include types
include network
include global_view
include local_view

isolate global_view_instance = {
    axiom exists R:round_t. round_t.succ(0,R)

    property block_t.round_exists(B) | ~ block_t.round_exists(B)
    
    instantiate global_view

    property process_voted(N,B) | ~ process_voted(N,B)
    property proposal_f_valid(P) | ~ proposal_f_valid(P)
    property tc_valid(TC) | ~ tc_valid(TC)
    property block_t.parent_exists(B) | ~ block_t.parent_exists(B)
} with round_t, height_t, block_t, prepare_t, qc_t, tc_t, timeout_t, proposal_f_t, proposal_n_t

isolate gv_action_requires = {
    before global_view_instance.enter_round(n:process_index_t,r:round_t,b:block_t,tc:tc_t) {
        assume global_view_instance.process_in_round(n) < r;#_#

        assume (global_view_instance.process_processed_qc(n,b) & (forall Rb,Rs:round_t. block_t.round(b,Rb) & round_t.succ(Rb,Rs) -> round_t.succ(Rs,r))) | (global_view_instance.process_processed_tc(n,tc) & (forall Rt,Rs:round_t. tc_t.round(tc,Rt) & round_t.succ(Rt,Rs) -> round_t.succ(Rs,r)));#_#

        assume block_t.round(global_view_instance.process_locked(n),R) & round_t.succ(Rp,r) -> R < Rp;#_#

    }

    before global_view_instance.receive_normal_proposal(n:process_index_t, p:proposal_n_t) {
        assume global_view_instance.proposal_n_valid(p);#_#

    }

    before global_view_instance.receive_fallback_proposal(n:process_index_t, p:proposal_f_t) {

        assume global_view_instance.proposal_f_valid(p);#_#
    }

    before global_view_instance.vote_normal(n:process_index_t, p:proposal_n_t) {
        assume global_view_instance.process_received_normal_proposal(n,p);#_#
        assume ~is_good(n) | (forall B:block_t. forall Rb:round_t. proposal_n_t.block(p,B) & block_t.round(B,Rb) -> round_t.succ(Rb,global_view_instance.process_in_round(n)));#_#
        assume ~is_good(n) | forall B:block_t. proposal_n_t.block(p,B) -> block_t.parent(B,global_view_instance.process_locked(n)) & global_view_instance.no_timeout_for_block_round(n,global_view_instance.process_locked(n));#_#
        assume ~is_good(n) | forall B,Bvn:block_t. forall Rvn:round_t. global_view_instance.process_voted_normal(n,Bvn) & block_t.round(Bvn,Rvn) & proposal_n_t.block(p,B) & block_t.round(B,Rb)-> Rvn < Rb;#_#

    }

    before global_view_instance.vote_fallback(n:process_index_t, p:proposal_f_t, q:quorum_t) {
        assume global_view_instance.proposal_f_valid(p);#_#
        assume proposal_f_t.block(p,B) & block_t.round(B,Rb) -> round_t.succ(Rb,global_view_instance.process_in_round(n));#_#
        assume proposal_f_t.tc(p,TC) -> tc_t.quorum(TC,q);#_#
        assume proposal_f_t.block(p,B) & proposal_f_t.tc(p,TC) & block_t.round(B,Rb) & tc_t.round(TC,Rt) -> round_t.succ(Rt,Rb);#_#
        assume proposal_f_t.block(p,Br) & block_t.parent(Br,Bp) & block_t.round(Bp,Rp) & proposal_f_t.tc(p,TC) & tc_t.timeout(TC,T) & timeout_t.qc(T,QC) & qc_t.block(QC,Bq) & block_t.round(Bq,Rq) -> Rq <= Rp;#_#
        assume ~is_good(n) | forall B,Bvf:block_t. forall Rvf:round_t. global_view_instance.process_voted_fallback(n,Bvf,Q) & block_t.round(Bvf,Rvf) & proposal_f_t.block(p,B) & block_t.round(B,Rb)-> Rvf < Rb;#_#
    }

    before global_view_instance.process_qc(n:process_index_t, b:block_t, qc:qc_t) {
        assume global_view_instance.qc_valid(qc);#_#
        assume qc_t.block(qc,b);#_#
        assume block_t.round(b,R) & round_t.succ(R,Rs) -> Rs < global_view_instance.process_in_round(n);#_#

    }

    before global_view_instance.lock(n:process_index_t, b:block_t, qc:qc_t) {
        assume block_t.cstd(b);#_#
        assume global_view_instance.qc_valid(qc);#_#
        assume qc_t.block(qc, b);#_#
        assume global_view_instance.process_processed_qc(n,b);#_#
        assume forall R1,R2:round_t. block_t.round(global_view_instance.process_locked(n), R1) & block_t.round(b, R2) -> R1 < R2;#_#
        assume forall Rq,Rs:round_t. block_t.round(b,Rq) & round_t.succ(Rq,Rs)-> global_view_instance.process_in_round(n) <= Rs;#_#
        assume forall Rq:round_t. block_t.round(b,Rq) -> (forall QC:qc_t. ~ global_view_instance.process_sent_timeout(N,Rq,QC));#_#

    }

    before global_view_instance.commit(n:process_index_t, b:block_t) {
        assume block_t.cstd(b);#_#
        assume exists QC:qc_t. global_view_instance.qc_valid(QC) & qc_t.block(QC, b);#_#
        assume b ~= block_t.genesis -> forall PB:block_t. block_t.parent(b, PB) -> global_view_instance.process_committed(n, PB);#_#
        assume forall B:block_t. forall R1,R2:round_t. global_view_instance.process_committed(n, B) & block_t.round(B, R1) & block_t.round(b, R2) -> R1 < R2;#_#
        assume forall B:block_t. forall H1,H2:height_t. global_view_instance.process_committed(n, B) & block_t.height(B, H1) & block_t.height(b, H2) -> H1 < H2;#_#

    }

    before global_view_instance.timeout(n:process_index_t, r:round_t, locked:qc_t) {
        assume global_view_instance.qc_valid(locked);#_#
        assume qc_t.block(locked,global_view_instance.process_locked(n)) & (block_t.round(global_view_instance.process_locked(n),R) -> R < r);#_#
        assume round_t.succ(r,Rs) & is_good(n) -> global_view_instance.process_in_round(n) <= Rs;#_#
        assume ~global_view_instance.process_sent_timeout(n,r,QC);#_#

    }

    before global_view_instance.processed_tc(n:process_index_t, tc:tc_t) {
        assume global_view_instance.tc_valid(tc);#_#

    }
} with global_view_instance, block_t, proposal_n_t, timeout_t, proposal_f_t

isolate gv_action_ensures = {
    after global_view_instance.enter_round(n:process_index_t,r:round_t,b:block_t,tc:tc_t) {

        global_view_instance.process_in_round(n) := r;
        global_view_instance.process_locked_but_round_not_advanced_yet(n) := false;

    }

    after global_view_instance.receive_normal_proposal(n:process_index_t, p:proposal_n_t) {

        global_view_instance.process_received_normal_proposal(n,p) := true;

    }

    after global_view_instance.receive_fallback_proposal(n:process_index_t, p:proposal_f_t) {

        global_view_instance.process_received_fallback_proposal(n,p) := true;

    }

    after global_view_instance.vote_normal(n:process_index_t, p:proposal_n_t) {

        global_view_instance.process_voted_normal(n, B) := global_view_instance.process_voted_normal(n, B) | proposal_n_t.block(p,B);

    }

    after global_view_instance.vote_fallback(n:process_index_t, p:proposal_f_t, q:quorum_t) {

        global_view_instance.process_voted_fallback(n, B, q) := global_view_instance.process_voted_fallback(n,B,q) | proposal_f_t.block(p,B);

    }

    after global_view_instance.process_qc(n:process_index_t, b:block_t, qc:qc_t) {

        global_view_instance.process_processed_qc(n,b) := true;

    }

    after global_view_instance.lock(n:process_index_t, b:block_t, qc:qc_t) {

        global_view_instance.process_locked(n) := b;
        global_view_instance.process_locked_but_round_not_advanced_yet(n) := true;
    }

    after global_view_instance.commit(n:process_index_t, b:block_t) {

        global_view_instance.process_committed(n, b) := true;

    }

    after global_view_instance.timeout(n:process_index_t, r:round_t, locked:qc_t) {
        
        global_view_instance.process_sent_timeout(n, r, locked) := true;
        
    }

    after global_view_instance.processed_tc(n:process_index_t, tc:tc_t) {

        global_view_instance.process_processed_tc(n,tc) := true;

    }
} with global_view_instance, block_t, proposal_n_t, timeout_t, proposal_f_t

isolate gv_basic_validities = {

    property block_t.parent_exists(B) | ~ block_t.parent_exists(B)

    invariant 0 < global_view_instance.process_in_round(N)

    invariant global_view_instance.tc_valid(TC) & tc_t.round(TC,R) -> 0 < R

    invariant global_view_instance.tc_fplusone_valid(TC) & tc_fplusone_t.round(TC,R) -> 0 < R

    invariant global_view_instance.process_sent_timeout(N,R,QC) & is_good(N) -> 0 < R

    invariant global_view_instance.qc_valid(qc_t.genesis)

    invariant global_view_instance.process_received_normal_proposal(N,P) -> global_view_instance.proposal_n_valid(P)
    invariant global_view_instance.process_received_fallback_proposal(N,P) -> global_view_instance.proposal_f_valid(P)
    invariant global_view_instance.process_voted(N, block_t.genesis)
    invariant global_view_instance.process_voted(N, B) -> block_t.cstd(B)
    invariant global_view_instance.process_processed_qc(N,B) -> block_t.cstd(B)
    invariant block_t.cstd(global_view_instance.process_locked(N))
    invariant global_view_instance.process_committed(N, B) -> block_t.cstd(B)
    invariant global_view_instance.process_sent_timeout(N, R, QC) -> global_view_instance.qc_valid(QC)
    invariant global_view_instance.process_processed_tc(N,TC) -> global_view_instance.tc_valid(TC)
} with round_t, height_t, block_t, prepare_t, qc_t, tc_t, timeout_t, proposal_f_t, proposal_n_t, global_view_instance, gv_action_requires, gv_action_ensures

isolate gv_basic_consequences = {

    relation round_max_for_tc(TC:tc_t, R:round_t)

    definition round_max_for_tc(TC, R) = forall T:timeout_t. forall QC:qc_t. forall B:block_t. forall Rq:round_t. tc_t.timeout(TC,T) & timeout_t.qc(T,QC) & qc_t.block(QC,B) & block_t.round(B,Rq) -> Rq <= R

    relation round_max_for_timeout_quorum(Q:quorum_t, Rt:round_t, R:round_t)
    
    definition round_max_for_timeout_quorum(Q,Rt,R) = forall N:process_index_t. forall QC:qc_t. forall Bq:block_t. forall Rq:round_t. quorum_t.member(Q,N) & global_view_instance.process_sent_timeout(N,Rt,QC) & qc_t.block(QC,Bq) & block_t.round(Bq,Rq) -> Rq <= R
    
    invariant forall TC:tc_t. forall Rt,Rp:round_t. global_view_instance.quorum_is_subset(TC) & tc_t.round(TC,Rt) & round_max_for_tc(TC,Rp) -> (forall Q:quorum_t. tc_t.quorum(TC,Q) -> round_max_for_timeout_quorum(Q,Rt,Rp))

    invariant is_good(N) & (global_view_instance.process_voted_normal(N,B) | global_view_instance.process_voted_fallback(N,B,Q)) & block_t.round(B,R) -> R < global_view_instance.process_in_round(N)

    invariant global_view_instance.process_processed_qc(N,B) & B ~= block_t.genesis & block_t.round(B,R) & round_t.succ(R,Rs) -> Rs < global_view_instance.process_in_round(N)

    invariant block_t.round(global_view_instance.process_locked(N),R) & global_view_instance.process_locked(N) ~= block_t.genesis & ~ global_view_instance.process_locked_but_round_not_advanced_yet(N) & round_t.succ(Rp,global_view_instance.process_in_round(N)) -> R < Rp

    invariant global_view_instance.process_voted_fallback(N,B,Q) & block_t.round(B,Rv) & round_t.succ(Rm,Rv) & quorum_t.member(Q,N1) -> exists QC:qc_t. global_view_instance.process_sent_timeout(N1,Rm,QC)

    invariant global_view_instance.process_voted_fallback(N,B,Q) & block_t.parent(B,Bp) & block_t.round(Bp,Rp) & block_t.round(B,Rv) & round_t.succ(Rm,Rv) & quorum_t.member(Q,N1) & global_view_instance.process_sent_timeout(N1,Rm,QC) & qc_t.block(QC,Bq) & block_t.round(Bq,Rq) -> Rq <= Rp

    ###### invariants related to process_received_normal_proposal
    invariant global_view_instance.process_received_normal_proposal(N,P) -> global_view_instance.proposal_n_valid(P)

    ###### invariants related to process_received_fallback_proposal

    invariant global_view_instance.process_received_fallback_proposal(N,P) -> global_view_instance.proposal_f_valid(P)
    
    invariant global_view_instance.process_sent_timeout(N,Rt,QC) & qc_t.block(QC,B) & block_t.round(B,Rq) -> Rq < Rt

    # same block cannot be received as a normal proposal by one process and as fallback proposal by another/same process
    invariant global_view_instance.process_received_normal_proposal(Nn,Pn) & global_view_instance.process_received_fallback_proposal(Nf,Pf) & proposal_n_t.block(Pn,Bn) & proposal_f_t.block(Pf,Bf) -> Bn ~= Bf

    ### invariants related to process_voted_normal
    invariant global_view_instance.process_voted_normal(N,B) & block_t.parent(B,Bp) & block_t.round(B,R) & block_t.round(Bp,Rp) -> (B = block_t.genesis | round_t.succ(Rp,R))

    ### invariants related to process_voted_fallback
    invariant global_view_instance.process_voted_fallback(N,Bv,Q) & block_t.parent(Bv,Bp) & block_t.round(Bv,Rv) & block_t.round(Bp,Rp) & round_t.succ(Rp,Rt) -> Rt < Rv
    
    ### invariants related to process_voted
    ### invariants related to process_locked

    ### invriants related to process_processed_qc
    invariant global_view_instance.process_processed_qc(N, global_view_instance.process_locked(N))

    ### invariants related to process_sent_timeout

    invariant global_view_instance.process_sent_timeout(N,R,QC1) & global_view_instance.process_sent_timeout(N,R,QC2) -> QC1 = QC2

    invariant global_view_instance.process_sent_timeout(N,R,QC) & is_good(N) -> (forall Rl:round_t. block_t.round(global_view_instance.process_locked(N),Rl) -> Rl ~= R)

    attribute macro_finder=false
} with round_t, height_t, block_t, prepare_t, qc_t, tc_t, timeout_t, proposal_f_t, proposal_n_t, global_view_instance, gv_action_requires, gv_action_ensures, gv_basic_validities

isolate no_normal_vote_after_timeout = {

    # if N sends a timeout for R, it will never send a normal vote any block proposed in R+1
    invariant is_good(N) & global_view_instance.process_sent_timeout(N,R,QC) -> (forall B:block_t. forall Rs:round_t. round_t.succ(R,Rs) & block_t.round(B,Rs) -> ~ global_view_instance.process_voted_normal(N,B))

} with round_t, height_t, block_t, prepare_t, qc_t, tc_t, timeout_t, proposal_f_t, proposal_n_t, global_view_instance, gv_action_requires, gv_action_ensures, gv_basic_validities,gv_basic_consequences

isolate gv_quorum_of_normal_votes = {
    # quorum of normal votes
    relation qonv(B:block_t)
    definition qonv(B) = exists Q:quorum_t. forall N:process_index_t. quorum_t.member(Q,N) -> global_view_instance.process_voted_normal(N,B)

    # quorum of time out messages for round r
    relation qoto(R:round_t)
    definition qoto(R) = exists Q:quorum_t. forall N:process_index_t. quorum_t.member(Q,N) -> exists QC:qc_t. global_view_instance.process_sent_timeout(N,R,QC)

    invariant qoto(R) & round_t.succ(R,Rs) & block_t.round(B,Rs) -> ~ qonv(B)

    attribute macro_finder=false
} with quorum_intersection_axiom, round_t, height_t, block_t, prepare_t, qc_t, tc_t, timeout_t, proposal_f_t, proposal_n_t, global_view_instance, no_normal_vote_after_timeout, gv_action_ensures#, gv_action_requires, gv_basic_validities, gv_basic_consequences

isolate normal_vote_requires_gc_candidate = {
    # process N locked B whilst in B.r +1 before sending a timeout for R, so it is a candidate for global commit
    relation gc_candidate(N:process_index_t, B:block_t)

    after init {
        gc_candidate(N,B) := B = block_t.genesis;
    }

    after global_view_instance.lock(n:process_index_t, b:block_t, qc:qc_t) {
            gc_candidate(n,b) := true;
    }

    before global_view_instance.vote_normal(n:process_index_t, p:proposal_n_t) {
        assume ~is_good(n) | (proposal_n_t.block(p,B) & block_t.parent(B,Bp) -> gc_candidate(n,Bp));#_#
    }

    invariant gc_candidate(N,global_view_instance.process_locked(N))
    
    invariant gc_candidate(N,B) & block_t.round(B,Rg) & block_t.round(global_view_instance.process_locked(N), Rl) -> Rg <= Rl

    attribute macro_finder=false

}  with block_t, proposal_n_t, round_t, prepare_t, timeout_t, proposal_f_t, quorum_t, qc_t,  global_view_instance, gv_action_requires, gv_action_ensures, gv_basic_validities

isolate later_normal_vote_later_parent = {

    invariant global_view_instance.process_voted_normal(N,B1) & global_view_instance.process_voted_normal(N,B2) & block_t.round(B1,R1)  & block_t.round(B2,R2) & block_t.parent(B1,Bp1) & block_t.parent(B2,Bp2) & block_t.round(Bp1,Rp1) & block_t.round(Bp2,Rp2) & R1 < R2 -> Rp1 <= Rp2
}  with block_t, proposal_n_t, round_t, prepare_t, timeout_t, proposal_f_t, quorum_t, qc_t,  global_view_instance, gv_action_requires, gv_action_ensures, gv_basic_validities, gv_basic_consequences

isolate gv_fallback_vote_implies_qoto = {
    relation process_voted_fallback_projection(N:process_index_t, B:block_t)
    definition process_voted_fallback_projection(N,B) = exists QN:quorum_t. global_view_instance.process_voted_fallback(N,B,QN)

    invariant global_view_instance.process_voted_fallback(N,B,Q) & block_t.round(B,Rb) & round_t.succ(Rp,Rb) -> (forall N:process_index_t. quorum_t.member(Q,N) -> exists QC:qc_t. global_view_instance.process_sent_timeout(N,Rp,QC))

    invariant global_view_instance.process_voted_fallback(N,B,Q) & block_t.round(B,Rb) & round_t.succ(Rp,Rb) -> gv_quorum_of_normal_votes.qoto(Rp)

    invariant process_voted_fallback_projection(N,B) & block_t.round(B,Rb) & round_t.succ(Rp,Rb) -> gv_quorum_of_normal_votes.qoto(Rp)

    #attribute macro_finder=false

} with round_t, height_t, block_t, prepare_t, qc_t, tc_t, timeout_t, proposal_f_t, proposal_n_t, global_view_instance, gv_action_ensures, gv_action_requires, gv_quorum_of_normal_votes 

isolate gv_quorum_of_fallback_votes = {
    # quorum of fallback votes
    relation qofv(B:block_t)
    definition qofv(B) = exists Q:quorum_t. forall N:process_index_t. quorum_t.member(Q,N) -> gv_fallback_vote_implies_qoto.process_voted_fallback_projection(N,B)

    invariant qofv(B) & block_t.round(B,Rb) & round_t.succ(Rp,Rb) -> gv_quorum_of_normal_votes.qoto(Rp)

} with every_quorum_good, round_t, height_t, block_t, prepare_t, qc_t, tc_t, timeout_t, proposal_f_t, proposal_n_t, global_view_instance, gv_fallback_vote_implies_qoto, gv_action_ensures#, gv_action_requires, gv_quorum_of_normal_votes 

isolate round_safety_m1 = {


    # invariant global_view_instance.process_voted_normal(N,Bn) & global_view_instance.process_voted_fallback(N,Bf,Q) -> Bn ~= Bf

    # invariant global_view_instance.process_voted(N,B) -> global_view_instance.process_voted_normal(N,B) | gv_fallback_vote_implies_qoto.process_voted_fallback_projection(N,B)

    # invariant global_view_instance.process_voted_normal(N1,B) -> ~ gv_fallback_vote_implies_qoto.process_voted_fallback_projection(N2,B)

    # invariant gv_fallback_vote_implies_qoto.process_voted_fallback_projection(N2,B) -> ~ global_view_instance.process_voted_normal(N1,B)

    relation normal_vote_exists(B:block_t)
    definition normal_vote_exists(B) = exists N:process_index_t. global_view_instance.process_voted_normal(N,B)
    invariant gv_quorum_of_normal_votes.qonv(B) -> normal_vote_exists(B)

    invariant [i1] normal_vote_exists(B) -> forall N:process_index_t. ~ gv_fallback_vote_implies_qoto.process_voted_fallback_projection(N, B)


    #invariant normal_vote_exists(B) -> ~ gv_quorum_of_fallback_votes.qofv(B)
    # invariant gv_quorum_of_normal_votes.qonv(B) -> (forall N:process_index_t. ~ gv_fallback_vote_implies_qoto.process_voted_fallback_projection(N,B))

    # invariant qov(B) -> gv_quorum_of_normal_votes.qonv(B) | gv_quorum_of_fallback_votes.qofv(B)

    attribute macro_finder=false
} with every_quorum_good, round_t, height_t, block_t, prepare_t, qc_t, tc_t, timeout_t, proposal_f_t, proposal_n_t, global_view_instance, gv_action_ensures, gv_basic_validities, gv_basic_consequences, gv_quorum_of_fallback_votes, gv_quorum_of_normal_votes, gv_fallback_vote_implies_qoto

isolate round_safety_m2 = {


    invariant [i2] (forall N:process_index_t. ~ gv_fallback_vote_implies_qoto.process_voted_fallback_projection(N, B)) -> ~ gv_quorum_of_fallback_votes.qofv(B)


    #attribute macro_finder=false
} with every_quorum_good, round_t, height_t, block_t, prepare_t, qc_t, tc_t, timeout_t, proposal_f_t, proposal_n_t, global_view_instance, gv_action_ensures, gv_basic_validities, gv_basic_consequences, gv_quorum_of_fallback_votes, gv_quorum_of_normal_votes, gv_fallback_vote_implies_qoto,round_safety_m1

isolate round_safety_m3 = {


    invariant [i2] round_safety_m1.normal_vote_exists(B) -> ~ gv_quorum_of_fallback_votes.qofv(B)

    attribute macro_finder=false
} with every_quorum_good, round_t, height_t, block_t, prepare_t, qc_t, tc_t, timeout_t, proposal_f_t, proposal_n_t, global_view_instance, gv_action_ensures, gv_basic_validities, gv_basic_consequences, gv_quorum_of_fallback_votes, gv_quorum_of_normal_votes, gv_fallback_vote_implies_qoto,round_safety_m1,round_safety_m2

isolate round_safety_m4 = {
    relation qov(B:block_t)
    definition qov(B) = exists Q:quorum_t. forall N:process_index_t. quorum_t.member(Q,N) -> global_view_instance.process_voted(N,B)

    #invariant gv_quorum_of_normal_votes.qonv(B) -> ~ gv_quorum_of_fallback_votes.qofv(B)

    invariant global_view_instance.process_voted_normal(N1,B) -> ~ gv_fallback_vote_implies_qoto.process_voted_fallback_projection(N2,B) 

    #invariant qov(B) -> gv_quorum_of_normal_votes.qonv(B) | gv_quorum_of_fallback_votes.qofv(B)

    #invariant qov(B) & ~ gv_quorum_of_normal_votes.qonv(B) & ~ gv_quorum_of_fallback_votes.qofv(B) -> exists N1,N2:process_index_t. global_view_instance.process_voted_normal(N1,B) & gv_fallback_vote_implies_qoto.process_voted_fallback_projection(N2,B)

    relation qonv_q(B:block_t, Q:quorum_t)
    definition qonv_q(B,Q) = forall N:process_index_t. quorum_t.member(Q,N) -> global_view_instance.process_voted_normal(N,B)

    invariant gv_quorum_of_normal_votes.qonv(B) -> exists Q:quorum_t. qonv_q(B:block_t, Q:quorum_t)

    relation qov_q(B:block_t, Q:quorum_t)
    definition qov_q(B,Q) = forall N:process_index_t. quorum_t.member(Q,N) -> global_view_instance.process_voted(N,B)

    invariant qov(B) -> exists Q:quorum_t. qov_q(B,Q)

    #invariant qov(B) & ~ gv_quorum_of_normal_votes.qonv(B) -> exists N2:process_index_t. gv_fallback_vote_implies_qoto.process_voted_fallback_projection(N2,B)

    #attribute macro_finder=false
} with every_quorum_good, round_t, height_t, block_t, prepare_t, qc_t, tc_t, timeout_t, proposal_f_t, proposal_n_t, global_view_instance, gv_action_ensures, gv_basic_validities, gv_basic_consequences, gv_quorum_of_fallback_votes, gv_quorum_of_normal_votes, gv_fallback_vote_implies_qoto,round_safety_m1,round_safety_m3

isolate round_safety_m5 = {

    relation qofv_q(B:block_t, Q:quorum_t)
    definition qofv_q(B,Q) = forall N:process_index_t. quorum_t.member(Q,N) -> gv_fallback_vote_implies_qoto.process_voted_fallback_projection(N,B)

    invariant gv_quorum_of_fallback_votes.qofv(B) -> exists Q:quorum_t. qofv_q(B,Q)

} with every_quorum_good, round_t, height_t, block_t, prepare_t, qc_t, tc_t, timeout_t, proposal_f_t, proposal_n_t, global_view_instance, gv_action_ensures, gv_basic_validities, gv_basic_consequences, gv_quorum_of_fallback_votes, gv_quorum_of_normal_votes, gv_fallback_vote_implies_qoto,round_safety_m1,round_safety_m3

isolate round_safety_m6 = {
    invariant round_safety_m4.qov_q(B,Q) & ~ round_safety_m4.qonv_q(B,Q) -> exists N2:process_index_t. gv_fallback_vote_implies_qoto.process_voted_fallback_projection(N2,B)

    invariant round_safety_m4.qov_q(B,Q) & ~ round_safety_m5.qofv_q(B,Q) -> exists N:process_index_t. global_view_instance.process_voted_normal(N,B)

    invariant round_safety_m4.qov_q(B,Q) & ~ round_safety_m4.qonv_q(B,Q) & ~ round_safety_m5.qofv_q(B,Q) -> exists N, N2:process_index_t. gv_fallback_vote_implies_qoto.process_voted_fallback_projection(N2,B) & global_view_instance.process_voted_normal(N,B)

    invariant round_safety_m4.qov_q(B,Q) -> round_safety_m4.qonv_q(B,Q) | round_safety_m5.qofv_q(B,Q)

    invariant round_safety_m4.qov(B) -> gv_quorum_of_normal_votes.qonv(B) | gv_quorum_of_fallback_votes.qofv(B)
} with every_quorum_good, round_t, height_t, block_t, prepare_t, qc_t, tc_t, timeout_t, proposal_f_t, proposal_n_t, global_view_instance, gv_action_ensures, gv_basic_validities, gv_basic_consequences, gv_quorum_of_fallback_votes, gv_quorum_of_normal_votes, gv_fallback_vote_implies_qoto,round_safety_m4,round_safety_m5

isolate round_safety_m7 = {

    invariant round_safety_m4.qov(B) -> gv_quorum_of_normal_votes.qonv(B) | gv_quorum_of_fallback_votes.qofv(B)

    attribute macro_finder=false
} with every_quorum_good, round_t, height_t, block_t, prepare_t, qc_t, tc_t, timeout_t, proposal_f_t, proposal_n_t, global_view_instance, gv_action_ensures, gv_basic_validities, gv_basic_consequences, gv_quorum_of_fallback_votes, gv_quorum_of_normal_votes, gv_fallback_vote_implies_qoto,round_safety_m4,round_safety_m6

isolate round_safety_m8 = {
    invariant is_good(N) & global_view_instance.process_voted_normal(N,B1) & global_view_instance.process_voted_normal(N,B2) & block_t.round(B1,R) & block_t.round(B2,R) -> B1 = B2

    invariant is_good(N) & gv_fallback_vote_implies_qoto.process_voted_fallback_projection(N,B1) & gv_fallback_vote_implies_qoto.process_voted_fallback_projection(N,B2) & block_t.round(B1,R) & block_t.round(B2,R) -> B1 = B2

    invariant round_safety_m4.qonv_q(B1,Q1) & round_safety_m4.qonv_q(B2,Q2) -> exists N:process_index_t. is_good(N) & quorum_t.member(Q1,N) & quorum_t.member(Q2,N)

    invariant round_safety_m4.qonv_q(B1,Q1) & round_safety_m4.qonv_q(B2,Q2)  & block_t.round(B1,R) & block_t.round(B2,R) -> exists N:process_index_t. is_good(N) & global_view_instance.process_voted_normal(N,B1) & global_view_instance.process_voted_normal(N,B2)
} with quorum_intersection_axiom, global_view_instance, gv_action_ensures, gv_action_requires, gv_fallback_vote_implies_qoto, block_t, proposal_n_t, timeout_t, round_t, proposal_f_t, round_safety_m4

isolate round_safety_m9 = {

    invariant gv_quorum_of_normal_votes.qonv(B1) & gv_quorum_of_normal_votes.qonv(B2) & block_t.round(B1,R) & block_t.round(B2,R) -> B1 = B2
} with quorum_intersection_axiom, global_view_instance, gv_action_ensures, gv_action_requires, gv_fallback_vote_implies_qoto, block_t, proposal_n_t, timeout_t, round_t, proposal_f_t, round_safety_m4, round_safety_m8

isolate round_safety_m10 = {

    invariant round_safety_m5.qofv_q(B1,Q1) & round_safety_m5.qofv_q(B2,Q2) & block_t.round(B1,R) & block_t.round(B2,R) -> exists N:process_index_t. is_good(N) & quorum_t.member(Q1,N) & quorum_t.member(Q2,N)

    attribute macro_finder=false
} with quorum_intersection_axiom, global_view_instance, gv_action_ensures, block_t, proposal_n_t, timeout_t, round_t, proposal_f_t#, round_safety_m5, gv_action_requires, gv_fallback_vote_implies_qoto

isolate round_safety_m11 = {


    invariant round_safety_m5.qofv_q(B1,Q1) & round_safety_m5.qofv_q(B2,Q2) & block_t.round(B1,R) & block_t.round(B2,R) -> exists N:process_index_t. is_good(N) & gv_fallback_vote_implies_qoto.process_voted_fallback_projection(N,B1) & gv_fallback_vote_implies_qoto.process_voted_fallback_projection(N,B2)

    invariant round_safety_m5.qofv_q(B1,Q1) & round_safety_m5.qofv_q(B2,Q2) & block_t.round(B1,R) & block_t.round(B2,R) -> B1 = B2

    invariant gv_quorum_of_fallback_votes.qofv(B1) & gv_quorum_of_fallback_votes.qofv(B2) & block_t.round(B1,R) & block_t.round(B2,R) -> B1 = B2

    attribute macro_finder=false
} with global_view_instance, gv_action_ensures, block_t, proposal_n_t, timeout_t, round_t, proposal_f_t, round_safety_m5, round_safety_m10, gv_fallback_vote_implies_qoto, round_safety_m8, gv_quorum_of_fallback_votes#,gv_action_requires, gv_fallback_vote_implies_qoto

isolate round_safety_m12 = {
    invariant gv_quorum_of_fallback_votes.qofv(B1) & block_t.round(B1,R) & block_t.round(B2,R) & 0 < R & round_t.succ(Rp,R) -> gv_quorum_of_fallback_votes.qofv(B1) & block_t.round(B1,R) & block_t.round(B2,R) & 0 < R & round_t.succ(Rp,R) & gv_quorum_of_normal_votes.qoto(Rp)

    invariant gv_quorum_of_fallback_votes.qofv(B1) & block_t.round(B1,R) & block_t.round(B2,R) & 0 < R & round_t.succ(Rp,R) & gv_quorum_of_normal_votes.qoto(Rp) -> ~ gv_quorum_of_normal_votes.qonv(B2)

    relation predicate1(B1:block_t, B2:block_t, R:round_t, Rp:round_t)
    definition predicate1(B1,B2,R,Rp) = gv_quorum_of_fallback_votes.qofv(B1) & block_t.round(B1,R) & block_t.round(B2,R) & 0 < R & round_t.succ(Rp,R)

    relation predicate2(B1:block_t, B2:block_t, R:round_t, Rp:round_t)
    definition predicate2(B1,B2,R,Rp) = gv_quorum_of_fallback_votes.qofv(B1) & block_t.round(B1,R) & block_t.round(B2,R) & 0 < R & round_t.succ(Rp,R) & gv_quorum_of_normal_votes.qoto(Rp)

    invariant predicate1(B1,B2,R,Rp) -> predicate2(B1,B2,R,Rp)

    invariant predicate2(B1,B2,R,Rp) ->  ~ gv_quorum_of_normal_votes.qonv(B2)

    invariant predicate1(B1,B2,R,Rp) -> ~ gv_quorum_of_normal_votes.qonv(B2)

    invariant gv_quorum_of_fallback_votes.qofv(B1) & block_t.round(B1,R) & block_t.round(B2,R) & 0 < R & round_t.succ(Rp,R) -> ~ gv_quorum_of_normal_votes.qonv(B2)
    attribute macro_finder=false
} with every_quorum_good, gv_quorum_of_normal_votes, gv_quorum_of_fallback_votes, global_view_instance, gv_action_ensures, gv_fallback_vote_implies_qoto, block_t, round_t, proposal_n_t, timeout_t, round_t, proposal_f_t

isolate round_safety_m13 = {

    private {
        invariant round_safety_m4.qov(B1) & round_safety_m4.qov(B2) & block_t.round(B1,R) & block_t.round(B2,R) & round_t.succ(Rp,R) -> (gv_quorum_of_normal_votes.qonv(B1) | gv_quorum_of_fallback_votes.qofv(B1)) & (gv_quorum_of_normal_votes.qonv(B2) | gv_quorum_of_fallback_votes.qofv(B2))

        invariant round_safety_m4.qov(B1) & round_safety_m4.qov(B2) & block_t.round(B1,R) & block_t.round(B2,R) & round_t.succ(Rp,R)  & gv_quorum_of_normal_votes.qonv(B1) & gv_quorum_of_normal_votes.qonv(B2) -> B1 = B2

        invariant round_safety_m4.qov(B1) & round_safety_m4.qov(B2) & block_t.round(B1,R) & block_t.round(B2,R) & round_t.succ(Rp,R)  & gv_quorum_of_fallback_votes.qofv(B1) & gv_quorum_of_fallback_votes.qofv(B2) -> B1 = B2

        invariant round_safety_m4.qov(B1) & round_safety_m4.qov(B2) & block_t.round(B1,R) & block_t.round(B2,R) & round_t.succ(Rp,R)  & gv_quorum_of_fallback_votes.qofv(B1) & 0 < R -> ~ gv_quorum_of_normal_votes.qonv(B2)

        invariant round_safety_m4.qov(B1) & round_safety_m4.qov(B2) & block_t.round(B1,R) & block_t.round(B2,R) & round_t.succ(Rp,R)  & gv_quorum_of_fallback_votes.qofv(B2) & 0 < R -> ~ gv_quorum_of_normal_votes.qonv(B1)

        invariant round_safety_m4.qov(B1) & round_safety_m4.qov(B2) & block_t.round(B1,R) & block_t.round(B2,R) & round_t.succ(Rp,R) & 0 = R -> B1 = B2
    }

    invariant round_safety_m4.qov(B1) & round_safety_m4.qov(B2) & block_t.round(B1,R) & block_t.round(B2,R) & round_t.succ(Rp,R) -> B1 = B2

    invariant round_safety_m4.qov(B1) & round_safety_m4.qov(B2) & block_t.round(B1,R) & block_t.round(B2,R) & 0 = R -> B1 = B2

    attribute macro_finder=false
} with global_view_instance, gv_action_ensures, gv_quorum_of_normal_votes, gv_quorum_of_fallback_votes, gv_fallback_vote_implies_qoto, round_safety_m4,round_safety_m5, round_safety_m6,round_safety_m9, round_safety_m11, round_safety_m12, block_t, round_t, proposal_n_t, timeout_t, round_t, proposal_f_t

isolate round_predecessor = {
    axiom [round_induction] {
        relation rel1(R:round_t)
        #-------------------------
        property rel1(0) & (forall R1,R2:round_t. rel1(R1) & round_t.succ(R1,R2) -> rel1(R2)) -> forall R:round_t. rel1(R2)
    }

    relation pred_exists(R:round_t)
    definition pred_exists(R) = 0 < R -> exists Rp:round_t. round_t.succ(Rp,R)

    property pred_exists(0)
    property pred_exists(R1) & round_t.succ(R1,R2) -> pred_exists(R2)

    property pred_exists(0) & (forall R1,R2:round_t. pred_exists(R1) & round_t.succ(R1,R2) -> pred_exists(R2)) -> forall R:round_t. pred_exists(R2)
    proof {
        apply round_induction
    }
} with round_t

isolate round_safety = {

    relation predicate3(B1,B2,R) = exists Rp:round_t. round_safety_m4.qov(B1) & round_safety_m4.qov(B2) & block_t.round(B1,R) & block_t.round(B2,R) & round_t.succ(Rp,R)

    invariant predicate3(B1,B2,R) -> B1 = B2

    invariant round_safety_m4.qov(B1) & round_safety_m4.qov(B2) & block_t.round(B1,R) & block_t.round(B2,R) & 0 < R -> predicate3(B1,B2,R)

    invariant round_safety_m4.qov(B1) & round_safety_m4.qov(B2) & block_t.round(B1,R) & block_t.round(B2,R) & 0 < R -> B1 = B2

    invariant round_safety_m4.qov(B1) & round_safety_m4.qov(B2) & block_t.round(B1,R) & block_t.round(B2,R) -> B1 = B2

} with global_view_instance, gv_action_ensures, block_t, round_t, proposal_n_t, timeout_t, round_t, proposal_f_t, round_safety_m13, round_predecessor

isolate genesis_starts_the_chain = {
    invariant block_t.parent_exists(B) | ~block_t.parent_exists(B)

    invariant is_good(N) & global_view_instance.process_committed(N, B) & block_t.height(B, 0) -> B = block_t.genesis
} with block_t, prepare_t, timeout_t, proposal_f_t, global_view_instance

isolate local_view_instance = {
    property global_view_instance.proposal_f_valid(P) & proposal_f_t.tc(P,TC) -> global_view_instance.tc_valid(TC)
    instantiate supraBFT(global_view_instance)

    attribute macro_finder=false

} with round_t, height_t, block_t, ancestor_transitive_closure_block, parent_same_implications, parent_same_implications_height, shim, proposal_n_t, prepare_t, genesis_member, qc_t, timeout_t,proposal_f_t, global_view_instance, lv_validity_invariants, lv_basic_invariants, lv_action_ensures, gv_basic_validities, gv_action_ensures, gv_basic_consequences, types_ensures, types_requires, lv_action_requires, gv_action_requires, normal_vote_requires_gc_candidate

isolate lv_action_requires = {
    before local_view_instance.local_view.proposal_f_get_tc(id:process_index_t, p:proposal_f_t) returns (tc:tc_t) {
        assume global_view_instance.proposal_f_valid(p);#_#
    }

    before local_view_instance.local_view.timeout_get_qc(id:process_index_t, t:timeout_t) returns (qc:qc_t) {
        assume global_view_instance.timeout_valid(t);#_#
    }

    before local_view_instance.local_view.qc_get_block(id:process_index_t, qc:qc_t) returns (b:block_t) {
        assume global_view_instance.qc_valid(qc);#_#
    }

    before local_view_instance.local_view.commit(id:process_index_t) {
        require local_view_instance.local_view(id).commit_mode;
    }

    before local_view_instance.local_view.proposeNormal(id:process_index_t, pB:block_t) {
        assume block_t.round(pB,Rp) -> round_t.succ(Rp,local_view_instance.local_view(id).r_c);#_#
    }

    before local_view_instance.local_view.proposal_n_processing(id:process_index_t, p:proposal_n_t) {
        require ~local_view_instance.local_view(id).timer;

        require local_view_instance.local_view(id).received_proposal_n(p, leader(round_t.prev(local_view_instance.local_view(id).r_c)));
    }

    before local_view_instance.local_view.timeout(id:process_index_t, r:round_t) {
        assume round_t.succ(r,Rs) -> global_view_instance.process_in_round(id) <= Rs;#_#
        assume r ~= 0;#_#
    }

    before local_view_instance.local_view.timer_expire(id:process_index_t) {
        require ~local_view_instance.local_view(id).timer;
        require round_t.succ(0,R1) -> R1 < local_view_instance.local_view(id).r_c;
    }

    before local_view_instance.local_view.timeout_sync(id:process_index_t, tc:tc_fplusone_t) {
        require local_view_instance.local_view(id).received_tc_fplusone(tc);

        #ensure all QCs contained in tc are processed. In implementation, this is done by calling the subroutine for processing qc. Here, we contrain the environment to call qc_processing on the qcs before calling timeout_sync
        require forall T:timeout_t. forall QC:qc_t. forall B:block_t. tc_fplusone_t.timeout(tc,T) & timeout_t.qc(T,QC) & qc_t.block(QC,B) -> local_view_instance.local_view(id).processed_qc(B);
    }

    before local_view_instance.local_view.proposal_f_processing(id:process_index_t, p:proposal_f_t) {
        require ~local_view_instance.local_view(id).timer;

        require local_view_instance.local_view(id).received_proposal_f(p, leader(round_t.prev(local_view_instance.local_view(id).r_c)));

        require proposal_f_t.tc(p,TC) -> local_view_instance.local_view(id).received_tc(TC) & local_view_instance.local_view(id).qcs_in_tc_processed(TC);
    }

    before local_view_instance.local_view.tc_getMaxQC(id:process_index_t, tc:tc_t) returns (qc:qc_t) {
        assume global_view_instance.tc_valid(tc);#_#
    }

    before local_view_instance.local_view.tc_getMaxTC(id:process_index_t, tc:tc_t) returns (t:timeout_t) {
        assume global_view_instance.tc_valid(tc);#_#
    }

    before local_view_instance.local_view.tc_get_round(id:process_index_t, tc:tc_t) returns (r:round_t) {
        assume global_view_instance.tc_valid(tc);#_#
    }

    before local_view_instance.local_view.tc_get_quorum(id:process_index_t, tc:tc_t) returns (q:quorum_t) {
        assume global_view_instance.tc_valid(tc);#_#
    }

    before local_view_instance.local_view.qc_get_round(id:process_index_t, qc:qc_t) returns (r:round_t) {
        assume global_view_instance.qc_valid(qc);#_#
    }

    before local_view_instance.local_view.tc_fplusone_get_round(id:process_index_t, tc:tc_fplusone_t) returns (r:round_t) {
        assume global_view_instance.tc_fplusone_valid(tc);#_#
    }

} with shim, block_t, proposal_n_t, round_t, prepare_t, timeout_t, proposal_f_t, quorum_t, qc_t, local_view_instance, global_view_instance, gv_action_ensures

isolate lv_action_ensures = {

    after local_view_instance.local_view.proposal_f_get_tc(id:process_index_t, p:proposal_f_t) returns (tc:tc_t) {
        assume proposal_f_t.tc(p, tc);#_#   
    }

    after local_view_instance.local_view.timeout_get_qc(id:process_index_t, t:timeout_t) returns (qc:qc_t) {

        assume timeout_t.qc(t, qc);#_#
    }

    after local_view_instance.local_view.qc_get_block(id:process_index_t, qc:qc_t) returns (b:block_t) {
        assume qc_t.block(qc, b);#_#
    }

    after local_view_instance.local_view.tc_getMaxQC(id:process_index_t, tc:tc_t) returns (qc:qc_t) {
        assume global_view_instance.qc_valid(qc);#_#
    }

    after local_view_instance.local_view.tc_get_round(id:process_index_t, tc:tc_t) returns (r:round_t) {
        assume tc_t.round(tc, r);#_#
    }

    after local_view_instance.local_view.tc_get_quorum(id:process_index_t, tc:tc_t) returns (q:quorum_t) {
        assume tc_t.quorum(tc,q);#_#
    }

    after local_view_instance.local_view.qc_get_round(id:process_index_t, qc:qc_t) returns (r:round_t) {
        assume forall B:block_t. qc_t.block(qc,B) -> block_t.round(B, r);#_#
    }

    after local_view_instance.local_view.tc_fplusone_get_round(id:process_index_t, tc:tc_fplusone_t) returns (r:round_t) {
        assume tc_fplusone_t.round(tc, r);#_#
    }
} with shim, block_t, proposal_n_t, round_t, prepare_t, timeout_t, proposal_f_t, quorum_t, qc_t, local_view_instance, global_view_instance

isolate lv_validity_invariants = {

    invariant local_view_instance.local_view(Id).r_c > 0
    invariant round_t.succ(local_view_instance.local_view(Id).r_c_m1, local_view_instance.local_view(Id).r_c)

    invariant local_view_instance.local_view.received_proposal_f(Id, P, N) -> global_view_instance.proposal_f_valid(P)
    invariant forall M:msg. shim.sent(M,D) & M.kind = msg_kind.proposal_f -> global_view_instance.proposal_f_valid(M.prop_f)

    invariant local_view_instance.local_view.received_proposal_n(Id, P, N) -> global_view_instance.proposal_n_valid(P)
    invariant forall M:msg. shim.sent(M,D) & M.kind = msg_kind.proposal_n -> global_view_instance.proposal_n_valid(M.prop_n)

    invariant local_view_instance.local_view.received_timeout(Id, T, N) -> global_view_instance.timeout_valid(T)
    invariant forall M:msg. shim.sent(M,D) & M.kind = msg_kind.timeout -> global_view_instance.timeout_valid(M.t)

    invariant local_view_instance.local_view.received_tc(Id, TC) -> global_view_instance.tc_valid(TC)
    invariant forall M:msg. shim.sent(M,D) & M.kind = msg_kind.tc -> global_view_instance.tc_valid(M.tc)

    invariant local_view_instance.local_view.received_tc_fplusone(Id, TC) -> global_view_instance.tc_fplusone_valid(TC)
    invariant forall M:msg. shim.sent(M,D) & M.kind = msg_kind.tcfpo -> global_view_instance.tc_fplusone_valid(M.tc_po)

    invariant local_view_instance.local_view.received_prepare(Id, P, N) -> prepare_t.cstd(P)
    invariant forall M:msg. shim.sent(M,D) & M.kind = msg_kind.prepare -> prepare_t.cstd(M.prep)

    invariant local_view_instance.local_view.received_qc(Id, QC) -> global_view_instance.qc_valid(QC)
    invariant forall M:msg. shim.sent(M,D) & M.kind = msg_kind.qc -> global_view_instance.qc_valid(M.qc)

    invariant global_view_instance.qc_valid(local_view_instance.local_view(Id).locked)

    invariant qc_t.block(local_view_instance.local_view(Id).locked,B) -> local_view_instance.local_view(Id).processed_qc(B)

    invariant local_view_instance.local_view(Id).processed_qc(B) & B ~= block_t.genesis & block_t.round(B,R) -> R < local_view_instance.local_view(Id).r_c_m1

    #attribute macro_finder=false

} with shim, block_t, proposal_n_t, round_t, prepare_t, timeout_t, proposal_f_t, quorum_t, qc_t, global_view_instance, gv_action_ensures, local_view_instance, lv_action_requires, lv_action_ensures, types_ensures

isolate lv_basic_invariants = {

    invariant block_t.parent_exists(B) | ~block_t.parent_exists(B)
    invariant ancestor_transitive_closure_block.inbetween(B1, B2) | ~ancestor_transitive_closure_block.inbetween(B1, B2)
    invariant round_t.succ(R1,R2) | ~ round_t.succ(R1,R2)

    invariant is_good(Id) & global_view_instance.process_voted_normal(Id,B) & block_t.round(B,R) -> R <= local_view_instance.local_view(Id).r_vn
    invariant is_good(Id) & global_view_instance.process_voted_fallback(Id,B,Q) & block_t.round(B,R) -> R <= local_view_instance.local_view(Id).r_vf
    invariant global_view_instance.process_in_round(Id) = local_view_instance.local_view(Id).r_c

    invariant forall R:round_t. local_view_instance.local_view(Id).expired_rounds(R) -> exists QC:qc_t. global_view_instance.process_sent_timeout(Id,R,QC)

    invariant forall R,Rs1,Rs2:round_t. forall QC:qc_t. is_good(Id) & global_view_instance.process_sent_timeout(Id,R,QC) & round_t.succ(R,Rs1) & round_t.succ(Rs1,Rs2) & Rs2 > local_view_instance.local_view(Id).r_c -> local_view_instance.local_view(Id).expired_rounds(R)

    invariant local_view_instance.local_view(Id).timer & round_t.succ(Rp,local_view_instance.local_view(Id).r_c) -> exists QC:qc_t. global_view_instance.process_sent_timeout(Id,Rp,QC)

    invariant local_view_instance.local_view(Id).processed_qc(QC) <-> global_view_instance.process_processed_qc(Id,QC)

    invariant qc_t.block(local_view_instance.local_view(Id).locked,global_view_instance.process_locked(Id))

    invariant local_view_instance.local_view(Id).locked ~= qc_t.genesis & qc_t.block(local_view_instance.local_view(Id).locked,B) & block_t.round(B,R) & round_t.succ(Rp,local_view_instance.local_view(Id).r_c) -> R < Rp

    invariant local_view_instance.local_view(Id).processed_qc(B) -> global_view_instance.qc_valid(local_view_instance.local_view(Id).qc_for_block(B)) & qc_t.block(local_view_instance.local_view(Id).qc_for_block(B),B)

    invariant local_view_instance.local_view(Id).commit_mode -> local_view_instance.local_view(Id).uncommitted(local_view_instance.local_view(Id).commit_mode_block)

    invariant global_view_instance.process_committed(Id,B) -> local_view_instance.local_view(Id).processed_qc(B) & ~ local_view_instance.local_view(Id).uncommitted(B)

    invariant local_view_instance.local_view(Id).uncommitted(B) -> local_view_instance.local_view(Id).processed_qc(B)

    invariant local_view_instance.local_view(Id).last_committed ~= block_t.unused -> global_view_instance.process_committed(Id,local_view_instance.local_view(Id).last_committed)

    invariant local_view_instance.local_view(Id).last_committed = block_t.unused -> ~ global_view_instance.process_committed(Id,B)

    invariant global_view_instance.process_committed(Id,B) & block_t.round(B,Rb) & block_t.round(local_view_instance.local_view(Id).last_committed,Rl) -> Rb <= Rl

    invariant global_view_instance.process_committed(Id,B) & block_t.height(B,Hb) & block_t.height(local_view_instance.local_view(Id).last_committed,Hl) -> Hb <= Hl

    attribute macro_finder=false

} with shim, block_t, proposal_n_t, round_t, prepare_t, timeout_t, proposal_f_t, quorum_t, qc_t, local_view_instance, global_view_instance, gv_action_ensures, lv_action_ensures, lv_action_requires, lv_validity_invariants