#lang ivy1.8

include types
include quorum_verification
include moonshot

isolate only_cstd_blocks = {
    invariant [genesis_block_cstd] block_t.cstd(block_t.genesis)
    
    invariant [prepare_o_cstd] verify_quorum.processor_sent_prepare_o(N,B) & is_good(N) -> block_t.cstd(B)

    invariant [locked_block_cstd] qc_t.block(verify_quorum.processor(N).qc_l,B_l) & is_good(N) -> block_t.cstd(B_l)
} with block_t, verify_quorum, qc_t, qc_t_properties

isolate basic_validities = {
    invariant [qc_l_valid] verify_quorum.qc_sanity_check(verify_quorum.processor(N).qc_l) & verify_quorum.qc_has_quorum(verify_quorum.processor(N).qc_l)
} with verify_quorum, block_t, qc_t, qc_t_properties

isolate tc_qc_o_intersection = {

    invariant forall Q_t,Q_q:quorum_t. exists N:process_index_t. quorum_t.member(Q_q,N) & quorum_t.member(Q_t,N) & is_good(N)

    invariant verify_quorum.tc_sanity_check(TC) & verify_quorum.tc_has_quorum(TC) & tc_t.quorum(TC,Q_t) & verify_quorum.qc_sanity_check(QC) & verify_quorum.qc_has_quorum_o(QC) & qc_t.quorum(QC,Q_q) -> exists N:process_index_t. quorum_t.member(Q_q,N) & quorum_t.member(Q_t,N) & is_good(N)

    # attribute macro_finder=false
} with verify_quorum, block_t, quorum_intersection_axiom, every_quorum_good

isolate tc_r_no_po_rs_quorum_m1 = {
    property block_t_properties.round_exists(B) | ~ block_t_properties.round_exists(B)

    invariant verify_quorum.processor_sent_prepare_o(N,B) & is_good(N) & block_t.round(B,R) & qc_t.block(verify_quorum.processor(N).qc_l,B_l) & block_t.round(B_l,R_l) & round_t.succ(Rp,R) -> Rp <= R_l 

    invariant qc_t.block(verify_quorum.processor(N).qc_l,B_l) & block_t.round(B_l,R_l) -> R_l < verify_quorum.processor(N).r_c

    invariant [honest_sends_prepare_o_timeout] verify_quorum.tc_sanity_check(TC) & verify_quorum.tc_has_quorum(TC) & tc_t.round(TC,R_tc) & tc_t.quorum(TC,Q_t) & quorum_t.member(Q_t,N) & is_good(N) & verify_quorum.qc_sanity_check(QC) & verify_quorum.qc_has_quorum_o(QC) & qc_t.block(QC,B) & qc_t.quorum(QC,Q_q) & quorum_t.member(Q_q,N) -> ((exists QC_to:qc_t. verify_quorum.processor_sent_timeout(N,R_tc,QC_to)) & verify_quorum.processor_sent_prepare_o(N,B))

    invariant verify_quorum.processor_sent_timeout(N,R_tc,QC_to) & is_good(N) -> R_tc <= verify_quorum.processor(N).t_l

    invariant [prepare_o_not_succ_timeout] verify_quorum.processor_sent_timeout(N,R_tc,QC_to) & verify_quorum.processor_sent_prepare_o(N,B) & is_good(N) & block_t.round(B,R) -> ~ round_t.succ(R_tc,R)

    # attribute macro_finder=false
} with block_t, verify_quorum, round_t, only_cstd_blocks.prepare_o_cstd, only_cstd_blocks.locked_block_cstd, block_t_properties.genesis_round_0, qc_t_properties, block_t_properties.block_t_inv_round_unique, basic_validities.qc_l_valid, block_t_properties.block_t_inv_round_exists, block_t_properties.round_exists

isolate tc_r_no_po_rs_quorum = {

    invariant verify_quorum.tc_sanity_check(TC) & verify_quorum.tc_has_quorum(TC) & tc_t.round(TC,R_tc) & verify_quorum.qc_sanity_check(QC) & verify_quorum.qc_has_quorum_o(QC) & qc_t.block(QC,B) & block_t.round(B,R) -> ~ round_t.succ(R_tc,R)

    attribute macro_finder=false

} with block_t, verify_quorum, round_t, tc_r_no_po_rs_quorum_m1.honest_sends_prepare_o_timeout, tc_r_no_po_rs_quorum_m1.prepare_o_not_succ_timeout, tc_qc_o_intersection

isolate qc_o_qc_n = {
    invariant forall B:block_t. forall R,Ro:round_t. forall N:process_index_t. is_good(N) & verify_quorum.processor_sent_prepare_o(N,B) & block_t.round(B,R) & block_t.round(verify_quorum.processor(N).b_o,Ro) -> verify_quorum.processor_sent_prepare_o(N,verify_quorum.processor(N).b_o)

    invariant verify_quorum.qc_sanity_check(QCo) & verify_quorum.qc_sanity_check(QCn) & verify_quorum.qc_has_quorum_o(QCo) & verify_quorum.qc_has_quorum_n(QCn) & qc_t.block(QCo,Bo) & qc_t.block(QCn,Bn) & block_t.round(Bo,Ro) & block_t.round(Bn,Rn) & Ro = Rn -> Bo = Bn
} with block_t, verify_quorum, quorum_intersection_axiom, block_t_properties.unused_not_cstd