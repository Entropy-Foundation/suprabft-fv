#lang ivy1.8

include types
include quorum_verification
include moonshot

isolate only_cstd_blocks = {
    invariant [genesis_block_cstd] block_t.cstd(block_t.genesis)
    
    invariant [prepare_o_cstd] verify_quorum.processor_sent_prepare_o(N,B) & is_good(N) -> B = block_t.unused | block_t.cstd(B)

    invariant [locked_block_cstd] qc_t.block(verify_quorum.processor(N).qc_l,B_l) & is_good(N) -> block_t.cstd(B_l)

    invariant [prepare_n_cstd] verify_quorum.processor_sent_prepare_n(N,B) & is_good(N) -> block_t.cstd(B)

    invariant [prepare_f_cstd] verify_quorum.processor_sent_prepare_f(N,B) & is_good(N) -> block_t.cstd(B)

    invariant [certified_block_cstd] verify_quorum.qc_sanity_check(QC) & qc_t.block(QC,B) -> block_t.cstd(B)

    invariant [processed_qc_cstd] is_good(N) & verify_quorum.processor(N).processed_qc(B) -> block_t.cstd(B)
} with block_t, verify_quorum, qc_t, qc_t_properties

isolate basic_validities = {
    invariant [qc_l_valid] verify_quorum.qc_sanity_check(verify_quorum.processor(N).qc_l) & verify_quorum.qc_has_quorum(verify_quorum.processor(N).qc_l)
} with verify_quorum, block_t, qc_t, qc_t_properties

isolate tc_qc_o_intersection = {

    invariant forall Q_t,Q_q:quorum_t. exists N:process_index_t. quorum_t.member(Q_q,N) & quorum_t.member(Q_t,N) & is_good(N)

    invariant verify_quorum.tc_sanity_check(TC) & verify_quorum.tc_has_quorum(TC) & tc_t.quorum(TC,Q_t) & verify_quorum.qc_sanity_check(QC) & verify_quorum.qc_has_quorum_o(QC) & qc_t.quorum(QC,Q_q) -> exists N:process_index_t. quorum_t.member(Q_q,N) & quorum_t.member(Q_t,N) & is_good(N)

    # attribute macro_finder=false
} with verify_quorum, block_t, quorum_intersection_axiom, every_quorum_good, only_cstd_blocks.prepare_o_cstd

isolate tc_r_no_po_rs_quorum_m1 = {
    property block_t_properties.round_exists(B) | ~ block_t_properties.round_exists(B)

    invariant verify_quorum.processor_sent_prepare_o(N,B) & is_good(N) & block_t.round(B,R) & qc_t.block(verify_quorum.processor(N).qc_l,B_l) & block_t.round(B_l,R_l) & round_t.succ(Rp,R) -> Rp <= R_l 

    invariant [rc_gt_locked_block] qc_t.block(verify_quorum.processor(N).qc_l,B_l) & block_t.round(B_l,R_l) -> R_l < verify_quorum.processor(N).r_c

    invariant [honest_sends_prepare_o_timeout] verify_quorum.tc_sanity_check(TC) & verify_quorum.tc_has_quorum(TC) & tc_t.round(TC,R_tc) & tc_t.quorum(TC,Q_t) & quorum_t.member(Q_t,N) & is_good(N) & verify_quorum.qc_sanity_check(QC) & verify_quorum.qc_has_quorum_o(QC) & qc_t.block(QC,B) & qc_t.quorum(QC,Q_q) & quorum_t.member(Q_q,N) -> ((exists QC_to:qc_t. verify_quorum.processor_sent_timeout(N,R_tc,QC_to)) & verify_quorum.processor_sent_prepare_o(N,B))

    invariant [tl_greatest_to] verify_quorum.processor_sent_timeout(N,R_tc,QC_to) & is_good(N) -> R_tc <= verify_quorum.processor(N).t_l

    invariant [prepare_o_not_succ_timeout] verify_quorum.processor_sent_timeout(N,R_tc,QC_to) & verify_quorum.processor_sent_prepare_o(N,B) & is_good(N) & block_t.round(B,R) -> ~ round_t.succ(R_tc,R)

    # attribute macro_finder=false
} with block_t, verify_quorum, round_t, only_cstd_blocks.prepare_o_cstd, only_cstd_blocks.locked_block_cstd, block_t_properties.genesis_round_0, qc_t_properties, block_t_properties.block_t_inv_round_unique, basic_validities.qc_l_valid, block_t_properties.block_t_inv_round_exists, block_t_properties.round_exists

isolate tc_r_no_po_rs_quorum = {

    invariant verify_quorum.tc_sanity_check(TC) & verify_quorum.tc_has_quorum(TC) & tc_t.round(TC,R_tc) & verify_quorum.qc_sanity_check(QC) & verify_quorum.qc_has_quorum_o(QC) & qc_t.block(QC,B) & block_t.round(B,R) -> ~ round_t.succ(R_tc,R)

    attribute macro_finder=false

} with block_t, verify_quorum, round_t, tc_r_no_po_rs_quorum_m1.honest_sends_prepare_o_timeout, tc_r_no_po_rs_quorum_m1.prepare_o_not_succ_timeout, tc_qc_o_intersection

isolate qc_o_qc_n_m1 = {
    invariant verify_quorum.processor_sent_prepare_o(N,verify_quorum.processor(N).b_o)

    invariant verify_quorum.processor(N).b_o ~= block_t.unused -> block_t.round(verify_quorum.processor(N).b_o,verify_quorum.processor(N).a_o)

    invariant [ao_an_le_rc] verify_quorum.processor(N).a_o <= verify_quorum.processor(N).r_c & verify_quorum.processor(N).a_n <= verify_quorum.processor(N).r_c

    invariant is_good(N) & verify_quorum.processor_sent_prepare_o(N,B) & block_t.round(B,R) -> verify_quorum.processor(N).possessed_optimistic_for_round(R)

    invariant [optimistic_round_safety] is_good(N) & verify_quorum.processor_sent_prepare_o(N,B1) & verify_quorum.processor_sent_prepare_o(N,B2) & block_t.round(B1,R1) & block_t.round(B2,R2) & R1 = R2 -> B1 = B2

    invariant verify_quorum.processor_sent_prepare_o(N,B) & is_good(N) -> (B = block_t.unused | block_t.cstd(B))

    invariant forall B:block_t. forall R:round_t. forall N:process_index_t. is_good(N) & verify_quorum.processor_sent_prepare_o(N,B) & block_t.round(B,R) -> R <= verify_quorum.processor(N).a_o

    invariant [an_highest] forall B:block_t. forall R:round_t. forall N:process_index_t. is_good(N) & verify_quorum.processor_sent_prepare_n(N,B) & block_t.round(B,R) -> R <= verify_quorum.processor(N).a_n

    invariant [honest_vote] is_good(N) & verify_quorum.processor_sent_prepare_o(N,B1) & verify_quorum.processor_sent_prepare_n(N,B2) & block_t.round(B1,R1) & block_t.round(B2,R2) & R1 = R2 -> B1 = B2

    # attribute macro_finder=false
} with block_t, round_t, verify_quorum, quorum_intersection_axiom, block_t_properties.unused_not_cstd, block_t_properties.genesis_cstd, block_t_properties.round_only_for_cstd, block_t_properties.block_t_inv_round_unique, only_cstd_blocks.prepare_n_cstd

isolate qc_o_qc_n = {

    invariant verify_quorum.qc_sanity_check(QCo) & verify_quorum.qc_sanity_check(QCn) & verify_quorum.qc_has_quorum_o(QCo) & verify_quorum.qc_has_quorum_n(QCn) & qc_t.block(QCo,Bo) & qc_t.block(QCn,Bn) & block_t.round(Bo,Ro) & block_t.round(Bn,Rn) & Ro = Rn -> Bo = Bn

    # attribute macro_finder=false

} with block_t, round_t, verify_quorum, quorum_intersection_axiom, qc_o_qc_n_m1.honest_vote, only_cstd_blocks.prepare_n_cstd, only_cstd_blocks.prepare_o_cstd

isolate round_safety_m1 = {
    invariant verify_quorum.processor(N).a_f <= verify_quorum.processor(N).r_c

    invariant is_good(N) & verify_quorum.processor_sent_prepare_n(N,B) & block_t.round(B,R) -> verify_quorum.processor(N).possessed_normal_for_round(R)

    invariant [prepare_n_prepare_n] is_good(N) & verify_quorum.processor_sent_prepare_n(N,B1) & verify_quorum.processor_sent_prepare_n(N,B2) & block_t.round(B1,R1) & block_t.round(B2,R2) & R1 = R2 -> B1 = B2

    invariant is_good(N) & verify_quorum.processor_sent_prepare_f(N,B) & block_t.round(B,R) -> verify_quorum.processor(N).possessed_fallback_for_round(R)

    invariant [prepare_f_prepare_f] is_good(N) & verify_quorum.processor_sent_prepare_f(N,B1) & verify_quorum.processor_sent_prepare_f(N,B2) & block_t.round(B1,R1) & block_t.round(B2,R2) & R1 = R2 -> B1 = B2

    invariant is_good(N) & verify_quorum.processor_sent_prepare_o(N,B) & block_t.round(B,R) -> verify_quorum.processor(N).possessed_optimistic_for_round(R)

    invariant [prepare_o_prepare_o] is_good(N) & verify_quorum.processor_sent_prepare_o(N,B1) & verify_quorum.processor_sent_prepare_o(N,B2) & block_t.round(B1,R1) & block_t.round(B2,R2) & R1 = R2 -> B1 = B2

    invariant [af_highest] forall B:block_t. forall R:round_t. forall N:process_index_t. is_good(N) & verify_quorum.processor_sent_prepare_f(N,B) & block_t.round(B,R) -> R <= verify_quorum.processor(N).a_f

    invariant [prepare_f_prepare_n] is_good(N) & verify_quorum.processor_sent_prepare_f(N,Bf) & verify_quorum.processor_sent_prepare_n(N,Bn) & block_t.round(Bf,Rf) & block_t.round(Bn,Rn) & Rf = Rn -> Bf = Bn
} with block_t, round_t, verify_quorum, qc_o_qc_n_m1.ao_an_le_rc, qc_o_qc_n_m1.optimistic_round_safety, block_t_properties.genesis_cstd, block_t_properties.block_t_inv_round_unique, block_t_properties.genesis_round_0, only_cstd_blocks.prepare_n_cstd, only_cstd_blocks.prepare_f_cstd, qc_o_qc_n_m1.an_highest, only_cstd_blocks.prepare_o_cstd

isolate round_safety_m2 = {

    relation processor_sent_prepare_f_tc(N:process_index_t, B:block_t, TC:tc_t)

    after init {
        processor_sent_prepare_f_tc(N,B,TC) := false;
    }

    before verify_quorum.processor.byzantine_send(id:process_index_t, m:msg) {
        if m.kind = msg_kind.prepare_f {
            processor_sent_prepare_f_tc(m.src, m.block, m.tc) := true;
        }
    }

    before verify_quorum.processor.fallback_proposal_processing(id:process_index_t, b_pr:block_t, tc:tc_t) {
            processor_sent_prepare_f_tc(id,b_pr,tc) := true;
    }

    invariant processor_sent_prepare_f_tc(N,B,TC) & is_good(N) -> block_t.cstd(B) & verify_quorum.tc_sanity_check(TC) & verify_quorum.tc_has_quorum(TC)

    invariant [prepare_f_tc_for_prev_round] processor_sent_prepare_f_tc(N,B,TC) & is_good(N) & block_t.round(B,R_b) & tc_t.round(TC,R_tc) -> round_t.succ(R_tc,R_b)

    invariant verify_quorum.processor_sent_prepare_f(N,B) & is_good(N) -> exists TC:tc_t. processor_sent_prepare_f_tc(N,B,TC)
    
    invariant verify_quorum.qc_sanity_check(QCf) & verify_quorum.qc_has_quorum_f(QCf) & qc_t.block(QCf,Bf) & block_t.round(Bf,Rf) & round_t.succ(R_tc,Rf) & qc_t.quorum(QCf,Q) & quorum_t.member(Q,N) & is_good(N) -> verify_quorum.processor_sent_prepare_f(N,Bf)

} with block_t, round_t, verify_quorum, block_t_properties.block_t_inv_round_unique

isolate round_safety_m3 = {
    
    invariant verify_quorum.qc_sanity_check(QCf) & verify_quorum.qc_has_quorum_f(QCf) & qc_t.block(QCf,Bf) & block_t.round(Bf,Rf) & round_t.succ(R_tc,Rf) & qc_t.quorum(QCf,Q) & quorum_t.member(Q,N) & is_good(N) -> exists TC:tc_t. round_safety_m2.processor_sent_prepare_f_tc(N,Bf,TC) & verify_quorum.tc_sanity_check(TC) & verify_quorum.tc_has_quorum(TC) & tc_t.round(TC,R_tc)

    relation tc_in_prev_round(TC:tc_t, R:round_t)
    definition tc_in_prev_round(TC,R) = verify_quorum.tc_sanity_check(TC) & verify_quorum.tc_has_quorum(TC) &(forall R_tc:round_t. tc_t.round(TC,R_tc) -> round_t.succ(R_tc,R))

    invariant [tc_r_no_qc_o_rs] tc_in_prev_round(TC,R) & verify_quorum.qc_sanity_check(QC) & qc_t.block(QC,B) & block_t.round(B,R) -> ~ verify_quorum.qc_has_quorum_o(QC)

    attribute macro_finder = false

} with block_t, round_t, verify_quorum, round_safety_m2, tc_r_no_po_rs_quorum#, quorum_intersection_axiom

isolate round_safety_m4 = {

    invariant verify_quorum.qc_sanity_check(QCf) & verify_quorum.qc_has_quorum_f(QCf) & qc_t.block(QCf,Bf) -> exists N:process_index_t. exists TC:tc_t. is_good(N) & round_safety_m2.processor_sent_prepare_f_tc(N,Bf,TC)

    # attribute macro_finder = false

} with block_t, round_t, verify_quorum, round_safety_m3, round_safety_m2, every_quorum_good

isolate round_safety_m5 = {

    invariant verify_quorum.qc_sanity_check(QCf) & verify_quorum.qc_has_quorum_f(QCf) & qc_t.block(QCf,Bf) & block_t.round(Bf,Rf) -> exists N:process_index_t. exists TC:tc_t. is_good(N) & round_safety_m2.processor_sent_prepare_f_tc(N,Bf,TC) & round_safety_m3.tc_in_prev_round(TC,Rf)

    attribute macro_finder = false

} with block_t, round_t, verify_quorum, round_safety_m3, round_safety_m2, round_safety_m4, every_quorum_good

isolate round_safety_m6 = {

    invariant verify_quorum.qc_sanity_check(QCf) & verify_quorum.qc_has_quorum_f(QCf) & qc_t.block(QCf,Bf) & block_t.round(Bf,Rf) -> exists TC:tc_t. round_safety_m3.tc_in_prev_round(TC,Rf)

    invariant verify_quorum.qc_sanity_check(QCf) & verify_quorum.qc_has_quorum_f(QCf) & qc_t.block(QCf,Bf) & block_t.round(Bf,Rf) & verify_quorum.qc_sanity_check(QCo) & qc_t.block(QCo,Bo) & block_t.round(Bo,Rf) -> ~ verify_quorum.qc_has_quorum_o(QCo)

    # attribute macro_finder = false

} with block_t, round_t, verify_quorum, round_safety_m5, round_safety_m2, every_quorum_good, round_safety_m3.tc_r_no_qc_o_rs

isolate qc_f_qc_n = {

    invariant verify_quorum.qc_sanity_check(QCf) & verify_quorum.qc_sanity_check(QCn) & verify_quorum.qc_has_quorum_f(QCf) & verify_quorum.qc_has_quorum_n(QCn) & qc_t.block(QCf,Bf) & qc_t.block(QCn,Bn) & block_t.round(Bf,Rf) & block_t.round(Bn,Rn) & Rf = Rn -> Bf = Bn

    # attribute macro_finder=false

} with block_t, round_t, verify_quorum, quorum_intersection_axiom, round_safety_m1.prepare_f_prepare_n, only_cstd_blocks.prepare_n_cstd, only_cstd_blocks.prepare_f_cstd

isolate qc_f_qc_o = {

    invariant verify_quorum.qc_sanity_check(QCf) & verify_quorum.qc_sanity_check(QCo) & verify_quorum.qc_has_quorum_f(QCf) & verify_quorum.qc_has_quorum_o(QCo) & qc_t.block(QCf,Bf) & qc_t.block(QCo,Bo) & block_t.round(Bf,Rf) & block_t.round(Bo,Ro) & Rf = Ro -> Bf = Bo

    # attribute macro_finder=false

} with block_t, round_t, verify_quorum, quorum_intersection_axiom, only_cstd_blocks.prepare_n_cstd, only_cstd_blocks.prepare_o_cstd, only_cstd_blocks.prepare_f_cstd, round_safety_m6, round_safety_m2

isolate qc_ff_or_nn = {

    invariant verify_quorum.qc_sanity_check(QC1) & verify_quorum.qc_sanity_check(QC2) & verify_quorum.qc_has_quorum_f(QC1) & verify_quorum.qc_has_quorum_f(QC2) & qc_t.block(QC1,B1) & qc_t.block(QC2,B2) & block_t.round(B1,R1) & block_t.round(B2,R2) & R1 = R2 -> B1 = B2

    invariant verify_quorum.qc_sanity_check(QC1) & verify_quorum.qc_sanity_check(QC2) & verify_quorum.qc_has_quorum_n(QC1) & verify_quorum.qc_has_quorum_n(QC2) & qc_t.block(QC1,B1) & qc_t.block(QC2,B2) & block_t.round(B1,R1) & block_t.round(B2,R2) & R1 = R2 -> B1 = B2

    # attribute macro_finder=false

} with block_t, round_t, verify_quorum, quorum_intersection_axiom, only_cstd_blocks, round_safety_m1.prepare_f_prepare_f, round_safety_m1.prepare_n_prepare_n, block_t_properties.genesis_cstd

isolate qc_oo = {

    invariant verify_quorum.qc_sanity_check(QC1) & verify_quorum.qc_sanity_check(QC2) & verify_quorum.qc_has_quorum_o(QC1) & verify_quorum.qc_has_quorum_o(QC2) & qc_t.block(QC1,B1) & qc_t.block(QC2,B2) & block_t.round(B1,R1) & block_t.round(B2,R2) & R1 = R2 -> B1 = B2

    # attribute macro_finder=false

} with block_t, round_t, verify_quorum, quorum_intersection_axiom, only_cstd_blocks, round_safety_m1.prepare_o_prepare_o

isolate round_safety = {

    invariant verify_quorum.qc_sanity_check(QC1) & verify_quorum.qc_has_quorum(QC1) & verify_quorum.qc_sanity_check(QC2) & verify_quorum.qc_has_quorum(QC2) & qc_t.block(QC1,B1)  & qc_t.block(QC2,B2) & block_t.round(B1,R1) & block_t.round(B2,R2) & R1 = R2 -> B1 = B2
} with block_t, round_t, verify_quorum, qc_o_qc_n, qc_f_qc_n, qc_f_qc_o, qc_ff_or_nn, qc_oo

isolate to_after_prepare = {
    property block_t_properties.round_exists(B) | ~ block_t_properties.round_exists(B)

    invariant is_good(N) & verify_quorum.processor_sent_timeout(N,Rt,QC) -> verify_quorum.qc_sanity_check(QC)

    invariant is_good(N) & verify_quorum.processor_sent_timeout(N,Rt,QC) -> Rt <= verify_quorum.processor(N).t_l

    invariant verify_quorum.qc_sanity_check(qc_t.genesis)

    invariant is_good(N) -> verify_quorum.qc_sanity_check(verify_quorum.processor(N).qc_l) 

    invariant [locked_qc_latest_processed] is_good(N) & verify_quorum.processor(N).processed_qc(Bp) & block_t.round(Bp,Rp) & qc_t.block(verify_quorum.processor(N).qc_l,Bl) & block_t.round(Bl,Rl) -> Rp <= Rl

    invariant is_good(N) & (verify_quorum.processor_sent_prepare_n(N,B) | verify_quorum.processor_sent_prepare_o(N,B) | verify_quorum.processor_sent_prepare_f(N,B)) & B ~= block_t.genesis & block_t.parent(B,Bp) & block_t.round(Bp,Rp) & qc_t.block(verify_quorum.processor(N).qc_l,Bl) & block_t.round(Bl,Rl) -> Rp <= Rl

    invariant [inv_to_after_prepare] is_good(N) & (verify_quorum.processor_sent_prepare_n(N,B) | verify_quorum.processor_sent_prepare_o(N,B) | verify_quorum.processor_sent_prepare_f(N,B)) & B ~= block_t.genesis & block_t.round(B,R) & block_t.parent(B,Bp) & block_t.round(Bp,Rp) & verify_quorum.processor_sent_timeout(N,Rt,QC) & R <= Rt & qc_t.block(QC,Bq) & block_t.round(Bq,Rq) -> Rp <= Rq
} with block_t, round_t, verify_quorum, only_cstd_blocks.prepare_n_cstd, only_cstd_blocks.certified_block_cstd, only_cstd_blocks.locked_block_cstd, block_t_properties.block_t_inv_round_unique, block_t_properties.unused_not_cstd, block_t_properties.genesis_cstd, block_t_properties.genesis_round_0, qc_t_properties, qc_t, block_t_properties.block_t_inv_round_exists, block_t_properties.round_exists, only_cstd_blocks.processed_qc_cstd, block_t_properties.parent_unique, block_t_properties.parent_only_for_cstd, only_cstd_blocks.prepare_o_cstd, only_cstd_blocks.prepare_f_cstd

isolate tc_after_prepare = {

    invariant is_good(N) & (verify_quorum.processor_sent_prepare_n(N,B) | verify_quorum.processor_sent_prepare_o(N,B) | verify_quorum.processor_sent_prepare_f(N,B)) & B ~= block_t.genesis & block_t.round(B,R) & block_t.parent(B,Bp) & block_t.round(Bp,Rp) & verify_quorum.tc_sanity_check(TC) & tc_t.round(TC,Rt) & tc_t.to_messages(TC,N,QC) & R <= Rt & qc_t.block(QC,Bq) & block_t.round(Bq,Rq) -> Rp <= Rq

    invariant is_good(N) & (verify_quorum.processor_sent_prepare_n(N,B) | verify_quorum.processor_sent_prepare_o(N,B) | verify_quorum.processor_sent_prepare_f(N,B)) & B ~= block_t.genesis & block_t.round(B,R) & block_t.parent(B,Bp) & block_t.round(Bp,Rp) & verify_quorum.tc_sanity_check(TC) & tc_t.round(TC,Rt) & tc_t.to_messages(TC,N,QC) & R <= Rt & qc_t.block(QC,Bq) & block_t.round(Bq,Rq) & verify_quorum.tc_maxQC(TC) & tc_t.maxQC(TC,QCm) & qc_t.block(QCm,Bm) & block_t.round(Bm,Rm) -> Rp <= Rq & Rq <= Rm & Rp <= Rm

    invariant is_good(N) & (verify_quorum.processor_sent_prepare_n(N,B) | verify_quorum.processor_sent_prepare_o(N,B) | verify_quorum.processor_sent_prepare_f(N,B)) & B ~= block_t.genesis & block_t.round(B,R) & block_t.parent(B,Bp) & block_t.round(Bp,Rp) & verify_quorum.tc_sanity_check(TC) & tc_t.round(TC,Rt) & tc_t.to_messages(TC,N,QC) & R <= Rt & verify_quorum.qc_sanity_check(QC) & verify_quorum.tc_maxQC(TC) & tc_t.maxQC(TC,QCm) & qc_t.block(QCm,Bm) & block_t.round(Bm,Rm) -> Rp <= Rm

    # invariant verify_quorum.qc_sanity_check(QC) & verify_quorum.qc_has_quorum(QC) & qc_t.block(QC,B) & B ~= block_t.genesis & block_t.round(B,R) & block_t.parent(B,Bp) & block_t.round(Bp,Rp) & verify_quorum.tc_sanity_check(TC) & verify_quorum.tc_has_quorum(TC) & verify_quorum.tc_maxQC(TC) & tc_t.round(TC,Rt) & R <= Rt & tc_t.maxQC(TC,QCm) & qc_t.block(QCm,Bm) & block_t.round(Bm,Rm) -> Rp <= Rm

    relation prepare_and_to(Bc:block_t, TC:tc_t)
    definition prepare_and_to(Bc,TC) = exists N:process_index_t. exists QC:qc_t. is_good(N) & (verify_quorum.processor_sent_prepare_n(N,Bc) | verify_quorum.processor_sent_prepare_o(N,Bc) | verify_quorum.processor_sent_prepare_f(N,Bc)) & tc_t.to_messages(TC,N,QC)

    invariant prepare_and_to(B,TC) & B ~= block_t.genesis & block_t.round(B,R) & block_t.parent(B,Bp) & block_t.round(Bp,Rp) & verify_quorum.tc_sanity_check(TC) & tc_t.round(TC,Rt) & R <= Rt & verify_quorum.tc_maxQC(TC) & tc_t.maxQC(TC,QCm) & qc_t.block(QCm,Bm) & block_t.round(Bm,Rm) -> Rp <= Rm

    # attribute macro_finder=false
} with block_t, round_t, verify_quorum, to_after_prepare.inv_to_after_prepare, quorum_intersection_axiom, block_t_properties.round_only_for_cstd, block_t_properties.parent_only_for_cstd, only_cstd_blocks.prepare_o_cstd, only_cstd_blocks.prepare_n_cstd, only_cstd_blocks.prepare_f_cstd

isolate to_after_ldc_m1 = {
    property block_t_conv.successive_blocks(Bp,Bc) | ~ block_t_conv.successive_blocks(Bp,Bc)

    property block_t_properties.round_exists(B) | ~ block_t_properties.round_exists(B)

    relation prepare_and_to(Bc:block_t, TC:tc_t)
    definition prepare_and_to(Bc,TC) = exists N:process_index_t. exists QC:qc_t. is_good(N) & (verify_quorum.processor_sent_prepare_n(N,Bc) | verify_quorum.processor_sent_prepare_o(N,Bc) | verify_quorum.processor_sent_prepare_f(N,Bc)) & verify_quorum.qc_sanity_check(QC) & verify_quorum.qc_has_quorum(QC) & tc_t.to_messages(TC,N,QC)

    invariant [processed_qc_quorum] is_good(N) & verify_quorum.processor(N).processed_qc(B) -> exists QC:qc_t. verify_quorum.qc_sanity_check(QC) & verify_quorum.qc_has_quorum(QC) & qc_t.block(QC,B)

    invariant  verify_quorum.qc_sanity_check(QC) & verify_quorum.qc_has_quorum(QC) & qc_t.block(QC,B) & verify_quorum.tc_sanity_check(TC) & verify_quorum.tc_has_quorum(TC) -> prepare_and_to(B,TC)

    invariant is_good(N) & verify_quorum.processor_sent_timeout(N,R,QC) -> verify_quorum.processor(N).expired_rounds(R)

    invariant verify_quorum.tc_sanity_check(TC) & verify_quorum.tc_maxQC(TC) & tc_t.to_messages(TC,N,QC) & tc_t.maxQC(TC,QCm) & qc_t.block(QCm,Bm) & block_t.round(Bm,Rm) & qc_t.block(QC,B) & block_t.round(B,R) -> R <= Rm

    invariant verify_quorum.tc_sanity_check(TC) & tc_t.to_messages(TC,N,QC) & is_good(N) & tc_t.round(TC,R_tc) -> verify_quorum.processor_sent_timeout(N,R_tc,QC)

    # invariant [prepare_tc_maxQC] prepare_and_to(B,TC) & B~= block_t.genesis & block_t.round(B,R) & verify_quorum.tc_sanity_check(TC) & verify_quorum.tc_has_quorum(TC) & verify_quorum.tc_maxQC(TC) & tc_t.round(TC,R_tc) & R <= R_tc & block_t.parent(B,Bp) & block_t.round(Bp,Rp) & tc_t.maxQC(TC,QCm) & qc_t.block(QCm,Bm) & block_t.round(Bm,Rm) -> Rp <= Rm

    # attribute macro_finder = false
} with block_t, round_t, qc_t, verify_quorum, quorum_intersection_axiom, only_cstd_blocks.processed_qc_cstd, block_t_properties.genesis_cstd, block_t_properties.unused_not_cstd, block_t_properties.block_t_inv_round_unique, block_t_properties.genesis_round_0#, block_t_conv.successive_blocks, tc_r_no_po_rs_quorum_m1.rc_gt_locked_block, to_after_prepare.locked_qc_latest_processed, basic_validities.qc_l_valid, block_t_properties.block_t_inv_round_exists, block_t_properties.round_exists, to_after_prepare.inv_to_after_prepare, every_quorum_good

isolate to_after_ldc_m2 = {

    invariant to_after_ldc_m1.prepare_and_to(B,TC) & block_t.cstd(B) & B ~= block_t.genesis & block_t.round(B,R) & verify_quorum.tc_sanity_check(TC) & verify_quorum.tc_has_quorum(TC) & verify_quorum.tc_maxQC(TC) & block_t.parent(B,Bp) & block_t.round(Bp,Rp) & tc_t.maxQC(TC,QCm) & qc_t.block(QCm,Bm) & block_t.round(Bm,Rm) & tc_t.round(TC,R_tc) & R <= R_tc -> Rp <= Rm

    # attribute macro_finder = false
} with block_t, round_t, qc_t, verify_quorum, only_cstd_blocks.processed_qc_cstd, block_t_properties.genesis_cstd, block_t_properties.unused_not_cstd, block_t_properties.block_t_inv_round_unique, block_t_properties.genesis_round_0, block_t_properties.round_only_for_cstd, block_t_properties.parent_self_genesis, block_t_properties.parent_unique, block_t_properties.block_t_inv_round_exists, block_t_properties.parent_only_for_cstd, only_cstd_blocks.prepare_o_cstd, only_cstd_blocks.prepare_n_cstd, only_cstd_blocks.prepare_f_cstd, to_after_ldc_m1.prepare_and_to, to_after_ldc_m1.prepare_tc_maxQC, to_after_prepare.inv_to_after_prepare, tc_r_no_po_rs_quorum_m1.tl_greatest_to

isolate to_after_ldc_m3 = {

    relation block_has_quorum(B:block_t)
    definition block_has_quorum(B) = exists Q:quorum_t. forall N:process_index_t. quorum_t.member(Q,N) & is_good(N) -> (verify_quorum.processor_sent_prepare_f(N,B) | verify_quorum.processor_sent_prepare_n(N,B) | verify_quorum.processor_sent_prepare_o(N,B))

    invariant is_good(N1) & verify_quorum.processor(N1).ldc_pair(Bp,Bc) -> block_has_quorum(Bc)

    # invariant is_good(N1) & verify_quorum.processor(N1).ldc_pair(Bp,Bc) & Bc ~= block_t.genesis & verify_quorum.tc_sanity_check(TC) & verify_quorum.tc_has_quorum(TC) -> to_after_ldc_m1.prepare_and_to(Bc,TC) & Bc ~= block_t.genesis

    # invariant is_good(N1) & verify_quorum.processor(N1).ldc_pair(Bp,Bc) & block_t.round(Bc,Rc) & block_t.round(Bp,Rp) & verify_quorum.tc_sanity_check(TC) & verify_quorum.tc_has_quorum(TC) & verify_quorum.tc_maxQC(TC) & tc_t.maxQC(TC,QCm) & qc_t.block(QCm,Bm) & block_t.round(Bm,Rm) & tc_t.round(TC,R_tc) & Rc <= R_tc -> Rp <= Rm

    # attribute macro_finder=false

} with block_t, round_t, verify_quorum, quorum_intersection_axiom, to_after_ldc_m1.prepare_and_to, to_after_ldc_m1.processed_qc_quorum#, to_after_ldc_m2