#lang ivy1.8

include types
include network
include global_view
include local_view

isolate global_view_used_here = {
    instantiate global_view

    # dummy invariant needed to make sure that the parent_exists definition is used within this isolate
    invariant block_t.parent_exists(B) | ~block_t.parent_exists(B)

    invariant is_good(N) & process_voted(N, B1) & process_voted(N, B2) & block_t.round(B1, R) & block_t.round(B2, R) -> B1 = B2
    invariant is_good(N) & process_locked(N, B1) & process_locked(N, B2) & block_t.round(B1, R) & block_t.round(B2, R) -> B1 = B2
    invariant is_good(N) & process_committed(N, B1) & process_committed(N, B2) & block_t.round(B1, R) & block_t.round(B2, R) -> B1 = B2
    invariant is_good(N) & process_locked(N, B) -> exists QC:qc_t. qc_valid(QC) & qc_t.block(QC, B)
    #invariant is_good(N) & process_locked(N, B) & B ~= block_t.genesis & block_t.parent(B, PB) -> process_committed(N, PB)
    invariant is_good(N) & process_committed(N, B) -> exists QC:qc_t. qc_valid(QC) & qc_t.block(QC, B)
    invariant is_good(N) & process_committed(N, B) & block_t.parent(B, P) -> process_committed(N, P)
} with round_t, height_t, block_t, prepare_t, qc_t, timeout_t, proposal_f_t

isolate genesis_starts_the_chain = {
    invariant block_t.parent_exists(B) | ~block_t.parent_exists(B)

    invariant is_good(N) & global_view_used_here.process_committed(N, B) & block_t.height(B, 0) -> B = block_t.genesis
} with block_t, prepare_t, timeout_t, proposal_f_t, global_view_used_here

isolate same_round_same_block_across_nodes = {
    invariant block_t.parent_exists(B) | ~block_t.parent_exists(B)

    invariant is_good(N1) & is_good(N2) & global_view_used_here.process_committed(N1, B1) & global_view_used_here.process_committed(N2, B2) &
            block_t.round(B1, R) & block_t.round(B2, R) -> B1 = B2
} with block_t, prepare_t, quorum_intersection_axiom, timeout_t, proposal_f_t, global_view_used_here

isolate safety = {
    invariant block_t.parent_exists(B) | ~block_t.parent_exists(B)
    invariant ancestor_transitive_closure_block.inbetween(B1, B2) | ~ancestor_transitive_closure_block.inbetween(B1, B2)

    # invariant is_good(N) & global_view_used_here.process_committed(N, B) & block_t.ancestor(B, A) -> global_view_used_here.process_committed(N, A)
    # invariant is_good(N1) & is_good(N2) & global_view_used_here.process_committed(N1, B1) & global_view_used_here.process_committed(N2, B2) &
            # block_t.height(B1, H1) & block_t.height(B2, H2) & H1 > H2 -> block_t.ancestor(B1, B2)
} with height_t, block_t, ancestor_transitive_closure_block, parent_same_implications, prepare_t, every_quorum_good, quorum_intersection_axiom, timeout_t,
        proposal_f_t, global_view_used_here, genesis_starts_the_chain, same_round_same_block_across_nodes

isolate local_view_used_here = {
    instantiate supraBFT(global_view_used_here)

    invariant block_t.parent_exists(B) | ~block_t.parent_exists(B)
    invariant ancestor_transitive_closure_block.inbetween(B1, B2) | ~ancestor_transitive_closure_block.inbetween(B1, B2)
} with round_t, height_t, block_t, ancestor_transitive_closure_block, parent_same_implications, proposal_n_t, prepare_t, genesis_member, qc_t, timeout_t,
        proposal_f_t, global_view_used_here
