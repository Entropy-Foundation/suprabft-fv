#lang ivy1.8

include domain_model

module global_view = {
    relation process_voted(N:process_index_t, B:block_t)
    relation process_locked(N:process_index_t, B:block_t)
    relation process_committed(N:process_index_t, B:block_t)
    relation process_sent_timeout(N:process_index_t, T:timeout_t)

    action vote_normal(n:process_index_t, b:block_t, r_c:round_t, pB:block_t)
    action vote_fallback_recovery(n:process_index_t, b:block_t, r_c:round_t)
    action lock(n:process_index_t, b:block_t)
    action commit(n:process_index_t, b:block_t)
    action timeout(n:process_index_t, t:timeout_t)

    # In the real world, we would assess the validity of certificates using signatures. For the IVy model,
    # we use the fact that the global view has access to this information and can tell us whether the QC is
    # actually constructible from the information currently floating around in the network
    relation qc_valid(QC:qc_t)
    definition qc_valid(QC) =
                ~(exists B1,B2:block_t. B1 ~= B2 & qc_t.block(QC, B1) & qc_t.block(QC, B2)) &
                ~(exists P1,P2:prepare_t. P1 ~= P2  & qc_t.prepare(QC, P1) & qc_t.prepare(QC, P2)) &
                ~(exists Q1,Q2:quorum_t. Q1 ~= Q2 & qc_t.quorum(QC, Q1) & qc_t.quorum(QC, Q2)) &
                (forall P:prepare_t. qc_t.prepare(QC, P) -> prepare_t.valid(P)) &
                (forall P:prepare_t,B:block_t. qc_t.prepare(QC, P) & prepare_t.block(P, B) -> qc_t.block(QC, B)) &
                (forall Q:quorum_t,N:process_index_t,B:block_t. qc_t.quorum(QC, Q) & quorum_t.member(Q, N) & qc_t.block(QC, B) -> process_voted(N, B))

    export action qc_get_block(qc:qc_t) returns (b:block_t)
    export action qc_maxQC(qc1:qc_t, qc2:qc_t) returns (qc:qc_t)

    relation timeout_valid(T:timeout_t)
    definition timeout_valid(T) = timeout_t.was_constructed(T) &
                (forall QC:qc_t. timeout_t.qc(T, QC) -> qc_valid(QC))

    export action timeout_get_qc(t:timeout_t) returns (qc:qc_t)

    relation tc_fplusone_valid(TC:tc_fplusone_t)
    definition tc_fplusone_valid(TC) =
                ~(exists R1,R2:round_t. R1 ~= R2 & tc_fplusone_t.round(TC, R1) & tc_fplusone_t.round(TC, R2)) &
                ~(exists Q1,Q2:quorum_fplusone_t. Q1 ~= Q2 & tc_fplusone_t.quorum(TC, Q1) & tc_fplusone_t.quorum(TC, Q2)) &
                (forall T:timeout_t. tc_fplusone_t.timeout(TC, T) -> timeout_valid(T)) &
                (forall T:timeout_t,R:round_t. tc_fplusone_t.timeout(TC, T) & timeout_t.round(T, R) -> tc_fplusone_t.round(TC, R)) &
                (forall T:timeout_t,Q:quorum_fplusone_t. tc_fplusone_t.timeout(TC, T) & tc_fplusone_t.quorum(TC, Q) -> (exists N:process_index_t. quorum_fplusone_t.member(Q, N) & process_sent_timeout(N, T)))

    export action tc_fplusone_get_round(tc:tc_fplusone_t) returns (r:round_t)

    relation tc_valid(TC:tc_t)
    definition tc_valid(TC) =
                ~(exists R1,R2:round_t. R1 ~= R2 & tc_t.round(TC, R1) & tc_t.round(TC, R2)) &
                ~(exists Q1,Q2:quorum_t. Q1 ~= Q2 & tc_t.quorum(TC, Q1) & tc_t.quorum(TC, Q2)) &
                (forall T:timeout_t. tc_t.timeout(TC, T) -> timeout_valid(T)) &
                (forall T:timeout_t,R:round_t. tc_t.timeout(TC, T) & timeout_t.round(T, R) -> tc_t.round(TC, R)) &
                (forall T:timeout_t,Q:quorum_t. tc_t.timeout(TC, T) & tc_t.quorum(TC, Q) -> (exists N:process_index_t. quorum_t.member(Q, N) & process_sent_timeout(N, T)))

    export action tc_get_round(tc:tc_t) returns (r:round_t)
    export action tc_getMaxQC(tc:tc_t) returns (qc:qc_t)

    relation proposal_f_valid(P:proposal_f_t)
    definition proposal_f_valid(P) = proposal_f_t.was_constructed(P) &
                (forall QC:qc_t. proposal_f_t.qc(P, QC) -> qc_valid(QC)) &
                (forall TC:tc_t. proposal_f_t.tc(P, TC) -> tc_valid(TC))

    export action proposal_f_get_qc(p:proposal_f_t) returns (qc:qc_t)
    export action proposal_f_get_tc(p:proposal_f_t) returns (tc:tc_t)

    specification {
        before vote_normal {
            require block_t.valid(b);
            require is_good(n) -> round_t.succ(block_t.get_round(b), r_c);
            require is_good(n) -> block_t.get_parent(b) = pB;
            require is_good(n) -> (forall T:timeout_t. forall R:round_t. (timeout_t.round(T, R) & process_sent_timeout(n, T)) -> R < r_c);
            require is_good(n) -> (forall B:block_t. forall R:round_t. (block_t.round(B, R) & process_voted(n, B)) -> R < r_c);
        }

        before vote_fallback_recovery {
            require block_t.valid(b);

            require is_good(n) -> (forall T:timeout_t. forall R:round_t. (timeout_t.round(T, R) & process_sent_timeout(n, T)) -> R < r_c);
            require is_good(n) -> (forall B:block_t. forall R:round_t. (block_t.round(B, R) & process_voted(n, B)) -> R < r_c);
        }

        before qc_get_block {
            require qc_valid(qc);
        }

        after qc_get_block {
            ensure block_t.valid(b);
        }

        before qc_maxQC {
            require qc_valid(qc1);
            require qc_valid(qc2);
        }

        after qc_maxQC {
            ensure qc = qc1 | qc = qc2;
            ensure block_t.get_round(qc_get_block(qc)) >= block_t.get_round(qc_get_block(qc1));
            ensure block_t.get_round(qc_get_block(qc)) >= block_t.get_round(qc_get_block(qc2));
        }

        before timeout_get_qc {
            require timeout_valid(t);
        }

        after timeout_get_qc {
            ensure qc_valid(qc);
        }

        before tc_fplusone_get_round {
            require tc_fplusone_valid(tc);
        }

        before tc_get_round {
            require tc_valid(tc);
        }

        before tc_getMaxQC {
            require tc_valid(tc);
            assume exists T:timeout_t. timeout_valid(T) & tc_t.timeout(tc, T) & timeout_t.qc(T, qc);
            assume forall T:timeout_t. forall QC:qc_t. forall B:block_t. forall R:round_t. (timeout_valid(T) & tc_t.timeout(tc, T) & timeout_t.qc(T, QC) & qc_t.block(QC, B) & block_t.round(B, R)) -> block_t.get_round(qc_get_block(qc)) >= R;
        }

        after tc_getMaxQC {
            ensure qc_valid(qc);
        }

        before proposal_f_get_qc {
            require proposal_f_valid(p);
        }

        after proposal_f_get_qc {
            ensure qc_valid(qc);
        }

        before proposal_f_get_tc {
            require proposal_f_valid(p);
        }

        after proposal_f_get_tc {
            ensure tc_valid(tc);
        }

        invariant process_voted(N, block_t.genesis)
        invariant process_committed(N, block_t.genesis)

        invariant process_voted(N, B) -> block_t.valid(B)
        invariant process_committed(N, B) -> block_t.valid(B)
    }

    implementation {
        after init {
            process_voted(N, B) := B = block_t.genesis;
            process_committed(N, B) := B = block_t.genesis;
            process_sent_timeout(N, B) := false;
        }

        implement vote_normal(n:process_index_t, b:block_t, r_c:round_t, pB:block_t) {
            process_voted(n, b) := true;
        }

        implement vote_fallback_recovery(n:process_index_t, b:block_t, r_c:round_t) {
            process_voted(n, b) := true;
        }

        implement vote(n:process_index_t, b:block_t, r:round_t) {
        }

        implement lock(n:process_index_t, b:block_t) {
            process_locked(n, b) := true;
        }

        implement commit(n:process_index_t, b:block_t) {
            process_committed(n, b) := true;
        }

        implement timeout(n:process_index_t, t:timeout_t) {
            process_sent_timeout(n, t) := true;
        }

        implement qc_get_block(qc:qc_t) returns (b:block_t) {
            if some qc_b:block_t. qc_t.block(qc, qc_b) {
                b := qc_b;
            } else {
            }
        }

        implement qc_maxQC(qc1:qc_t, qc2:qc_t) returns (qc:qc_t) {
            if block_t.get_round(qc_get_block(qc1)) > block_t.get_round(qc_get_block(qc2)) {
                qc := qc1;
            } else {
                qc := qc2;
            }
        }

        implement timeout_get_qc(t:timeout_t) returns (qc:qc_t) {
            if some t_qc:qc_t. timeout_t.qc(t, t_qc) {
                qc := t_qc;
            } else {
            }
        }

        implement tc_fplusone_get_round(tc:tc_fplusone_t) returns (r:round_t) {
            if some tc_r:round_t. tc_fplusone_t.round(tc, tc_r) {
                r := tc_r;
            } else {
            }
        }

        implement tc_get_round(tc:tc_t) returns (r:round_t) {
            if some tc_r:round_t. tc_t.round(tc, tc_r) {
                r := tc_r;
            } else {
            }
        }

        implement tc_getMaxQC(tc:tc_t) returns (qc:qc_t) {
        }

        implement proposal_f_get_qc(p:proposal_f_t) returns (qc:qc_t) {
            if some p_qc:qc_t. proposal_f_t.qc(p, p_qc) {
                qc := p_qc;
            } else {
            }
        }

        implement proposal_f_get_tc(p:proposal_f_t) returns (tc:tc_t) {
            if some p_tc:tc_t. proposal_f_t.tc(p, p_tc) {
                tc := p_tc;
            } else {
            }
        }
    }
}
