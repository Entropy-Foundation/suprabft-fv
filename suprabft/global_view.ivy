#lang ivy1.8

include types

module global_view = {
    relation process_proposed(N:process_index_t, B:block_t)
    relation process_voted(N:process_index_t, B:block_t)
    relation process_locked(N:process_index_t, B:block_t)
    relation process_committed(N:process_index_t, B:block_t)
    relation process_sent_timeout(N:process_index_t, T:timeout_t)

    # In the real world, we would assess the validity of certificates using signatures. For the IVy model,
    # we use the fact that the global view has access to this information and can tell us whether the QC is
    # actually constructible from the information currently floating around in the network
    relation qc_valid(QC:qc_t)
    definition qc_valid(QC) =
                (exists B:block_t. qc_t.block(QC, B)) &
                (exists P:prepare_t. qc_t.prepare(QC, P)) &
                (exists Q:quorum_t. qc_t.quorum(QC, Q)) &
                (forall B1,B2:block_t. qc_t.block(QC, B1) & qc_t.block(QC, B2) -> B1 = B2) &
                (forall P1,P2:prepare_t. qc_t.prepare(QC, P1) & qc_t.prepare(QC, P2) -> P1 = P2) &
                (forall Q1,Q2:quorum_t. qc_t.quorum(QC, Q1) & qc_t.quorum(QC, Q2) -> Q1 = Q2) &
                (forall P:prepare_t. qc_t.prepare(QC, P) -> prepare_t.valid(P)) &
                (forall P:prepare_t,B:block_t. qc_t.prepare(QC, P) & prepare_t.block(P, B) -> qc_t.block(QC, B)) &
                (forall Q:quorum_t,N:process_index_t,B:block_t. qc_t.quorum(QC, Q) & quorum_t.member(Q, N) & qc_t.block(QC, B) -> process_voted(N, B))

    relation timeout_valid(T:timeout_t)
    definition timeout_valid(T) = timeout_t.was_constructed(T) &
                (forall QC:qc_t. timeout_t.qc(T, QC) -> qc_valid(QC))

    relation tc_fplusone_valid(TC:tc_fplusone_t)
    definition tc_fplusone_valid(TC) =
                (exists R:round_t. tc_fplusone_t.round(TC, R)) &
                (exists Q:quorum_fplusone_t. tc_fplusone_t.quorum(TC, Q)) &
                (forall R1,R2:round_t. tc_fplusone_t.round(TC, R1) & tc_fplusone_t.round(TC, R2) -> R1 = R2) &
                (forall Q1,Q2:quorum_fplusone_t. tc_fplusone_t.quorum(TC, Q1) & tc_fplusone_t.quorum(TC, Q2) -> Q1 = Q2) &
                (forall T:timeout_t. tc_fplusone_t.timeout(TC, T) -> timeout_valid(T)) &
                (forall T:timeout_t,R:round_t. tc_fplusone_t.timeout(TC, T) & timeout_t.round(T, R) -> tc_fplusone_t.round(TC, R)) &
                (forall Q:quorum_fplusone_t,N:process_index_t. tc_fplusone_t.quorum(TC, Q) & quorum_fplusone_t.member(Q, N) ->
                        (exists T:timeout_t. tc_fplusone_t.timeout(TC,T) & process_sent_timeout(N, T)))

    relation tc_valid(TC:tc_t)
    definition tc_valid(TC) =
                (exists R:round_t. tc_t.round(TC, R)) &
                (exists Q:quorum_t. tc_t.quorum(TC, Q)) &
                (forall R1,R2:round_t. tc_t.round(TC, R1) & tc_t.round(TC, R2) -> R1 = R2) &
                (forall Q1,Q2:quorum_t. tc_t.quorum(TC, Q1) & tc_t.quorum(TC, Q2) -> Q1 = Q2) &
                (forall T:timeout_t. tc_t.timeout(TC, T) -> timeout_valid(T)) &
                (forall T:timeout_t,R:round_t. tc_t.timeout(TC, T) & timeout_t.round(T, R) -> tc_t.round(TC, R)) &
                (forall Q:quorum_t,N:process_index_t. tc_t.quorum(TC, Q) & quorum_t.member(Q, N) ->
                        (exists T:timeout_t. tc_t.timeout(TC,T) & process_sent_timeout(N, T)))

    relation proposal_f_valid(P:proposal_f_t)
    definition proposal_f_valid(P) = proposal_f_t.was_constructed(P) &
                (forall QC:qc_t. proposal_f_t.qc(P, QC) -> qc_valid(QC)) &
                (forall TC:tc_t. proposal_f_t.tc(P, TC) -> tc_valid(TC))

    after init {
        process_proposed(N, B) := N = leader(0) & B = block_t.genesis;
        process_voted(N, B) := B = block_t.genesis;
        process_locked(N, B) := B = block_t.genesis;
        process_committed(N, B) := false;
        process_sent_timeout(N, B) := false;
    }

    action propose(n:process_index_t, b:block_t) = {
        require block_t.valid(b);
        require forall R:round_t. block_t.round(b, R) -> n = leader(R);

        process_proposed(n, b) := true;
    }

    action vote(n:process_index_t, b:block_t) = {
        require block_t.valid(b);
        require forall B:block_t. block_t.parent(b, PB) -> process_locked(n, PB);
        require forall B:block_t. forall R1,R2:round_t. process_voted(n, B) & block_t.round(B, R1) & block_t.round(b, R2) -> R1 < R2;

        process_voted(n, b) := true;
    }

    action lock(n:process_index_t, b:block_t, qc:qc_t) = {
        require block_t.valid(b);
        require qc_valid(qc);
        require qc_t.block(qc, b); 
        #require forall B:block_t. block_t.parent(b, PB) -> process_committed(n, PB);
        require forall B:block_t. forall R1,R2:round_t. process_locked(n, B) & block_t.round(B, R1) & block_t.round(b, R2) -> R1 < R2;

        process_locked(n, b) := true;
    }

    action commit(n:process_index_t, b:block_t) = {
        require block_t.valid(b);
        require exists QC:qc_t. qc_valid(QC) & qc_t.block(QC, b);
        require forall PB:block_t. block_t.parent(b, PB) -> process_committed(n, PB);
        require forall B:block_t. forall R1,R2:round_t. process_committed(n, B) & block_t.round(B, R1) & block_t.round(b, R2) -> R1 < R2;
        require forall B:block_t. forall H1,H2:height_t. process_committed(n, B) & block_t.height(B, H1) & block_t.height(b, H2) -> H1 < H2;

        process_committed(n, b) := true;
    }

    action timeout(n:process_index_t, t:timeout_t) = {
        require timeout_valid(t);

        process_sent_timeout(n, t) := true;
    }

    action qc_get_block(qc:qc_t) returns (b:block_t) = {
        require qc_valid(qc);

        if some qc_b:block_t. qc_t.block(qc, qc_b) {
            b := qc_b;
        }

        ensure qc_t.block(qc, b);
    }

    action qc_maxQC(qc1:qc_t, qc2:qc_t) returns (qc:qc_t) = {
        require qc_valid(qc1);
        require qc_valid(qc2);

        if forall B1,B2:block_t. forall R1,R2:round_t. qc_t.block(qc1, B1) & block_t.round(B1, R1) & qc_t.block(qc2, B2) & block_t.round(B2, R2) -> R1 > R2 {
            qc := qc1;
        } else {
            qc := qc2;
        }

        ensure qc = qc1 | qc = qc2;
        ensure forall B1,B2:block_t. forall R1,R2:round_t. qc_t.block(qc, B1) & block_t.round(B1, R1) & qc_t.block(qc1, B2) & block_t.round(B2, R2) -> R1 >= R2;
        ensure forall B1,B2:block_t. forall R1,R2:round_t. qc_t.block(qc, B1) & block_t.round(B1, R1) & qc_t.block(qc2, B2) & block_t.round(B2, R2) -> R1 >= R2;
    }

    action timeout_get_qc(t:timeout_t) returns (qc:qc_t) = {
        require timeout_valid(t);

        if some t_qc:qc_t. timeout_t.qc(t, t_qc) {
            qc := t_qc;
        }

        ensure timeout_t.qc(t, qc);
    }

    action tc_fplusone_get_round(tc:tc_fplusone_t) returns (r:round_t) = {
        require tc_fplusone_valid(tc);

        if some tc_r:round_t. tc_fplusone_t.round(tc, tc_r) {
            r := tc_r;
        }

        ensure tc_fplusone_t.round(tc, r);
    }

    action tc_get_round(tc:tc_t) returns (r:round_t) = {
        require tc_valid(tc);

        if some tc_r:round_t. tc_t.round(tc, tc_r) {
            r := tc_r;
        }

        ensure tc_t.round(tc, r);
    }

    action tc_getMaxQC(tc:tc_t) returns (qc:qc_t) = {
        require tc_valid(tc);
        assume exists T:timeout_t. timeout_valid(T) & tc_t.timeout(tc, T) & timeout_t.qc(T, qc);
        assume forall T:timeout_t. forall QC:qc_t. forall B1,B2:block_t. forall R1,R2:round_t. timeout_valid(T) & tc_t.timeout(tc, T) & timeout_t.qc(T, QC) &
                qc_t.block(QC, B1) & block_t.round(B1, R1) & qc_t.block(qc, B2) & block_t.round(B2, R2) -> R2 >= R1;

        ensure qc_valid(qc);
    }

    action proposal_f_get_qc(p:proposal_f_t) returns (qc:qc_t) = {
        require proposal_f_valid(p);

        if some p_qc:qc_t. proposal_f_t.qc(p, p_qc) {
            qc := p_qc;
        }

        ensure proposal_f_t.qc(p, qc);
    }

    action proposal_f_get_tc(p:proposal_f_t) returns (tc:tc_t) = {
        require proposal_f_valid(p);

        if some p_tc:tc_t. proposal_f_t.tc(p, p_tc) {
            tc := p_tc;
        }

        ensure proposal_f_t.tc(p, tc);
    }

    invariant qc_valid(qc_t.genesis)

    invariant process_proposed(N, block_t.genesis) <-> N = leader(0)
    invariant process_voted(N, block_t.genesis)
    invariant process_locked(N, block_t.genesis)

    invariant process_proposed(N, B) -> block_t.valid(B)
    invariant process_voted(N, B) -> block_t.valid(B)
    invariant process_locked(N, B) -> block_t.valid(B)
    invariant process_committed(N, B) -> block_t.valid(B)
    invariant process_sent_timeout(N, T) -> timeout_valid(T)
}
