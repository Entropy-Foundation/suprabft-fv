#lang ivy1.8

include domain_model

module global_view = {
	relation node_voted(N:process_index_t, B:block_t)
	relation node_locked(N:process_index_t, B:block_t)
	relation node_committed(N:process_index_t, B:block_t)
	relation node_sent_timeout(N:process_index_t, T:timeout_t)

	action vote(n:process_index_t, b:block_t)
	action lock(n:process_index_t, b:block_t)
	action commit(n:process_index_t, b:block_t)
	action timeout(n:process_index_t, t:timeout_t)

	# In the real world, we would assess the validity of certificates using signatures. For the IVy model,
	# we use the fact that the global view has access to this information and can tell us whether the QC is
	# actually constructible from the information currently floating around in the network
	relation valid_qc(QC:qc_t)
	definition valid_qc(QC) =
				~(exists B1,B2:block_t. B1 ~= B2 & qc_t.block(QC, B1) & qc_t.block(QC, B2)) &
				~(exists P1,P2:prepare_t. P1 ~= P2  & qc_t.prepare(QC, P1) & qc_t.prepare(QC, P2)) &
				~(exists Q1,Q2:quorum_t. Q1 ~= Q2 & qc_t.quorum(QC, Q1) & qc_t.quorum(QC, Q2)) &
				(forall P:prepare_t. qc_t.prepare(QC, P) -> prepare_t.valid(P)) &
				(forall P:prepare_t,B:block_t. qc_t.prepare(QC, P) & prepare_t.block(P, B) -> qc_t.block(QC, B)) &
				(forall Q:quorum_t,N:process_index_t,B:block_t. qc_t.quorum(QC, Q) & quorum_t.member(Q, N) & qc_t.block(QC, B) -> node_voted(N, B))

	action get_qc_block(qc:qc_t) returns (b:block_t)

	relation valid_tc(TC:tc_t)

	specification {
		before get_qc_block {
			require valid_qc(qc);
		}

		after get_qc_block {
			ensure block_t.valid(b);
		}
	}

	implementation {
		after init {
			node_voted(N, B) := B = block_t.genesis;
			node_committed(N, B) := B = block_t.genesis;
			node_sent_timeout(N, B) := false;
		}

		implement vote(n:process_index_t, b:block_t) {
			node_voted(n, b) := true;
		}

		implement lock(n:process_index_t, b:block_t) {
			node_locked(n, b) := true;
		}

		implement commit(n:process_index_t, b:block_t) {
			node_committed(n, b) := true;
		}

		implement timeout(n:process_index_t, t:timeout_t) {
			node_sent_timeout(n, t) := true;
		}

		implement get_qc_block(qc:qc_t) returns (b:block_t) {
		    if some qc_b:block_t. qc_t.block(qc, qc_b) {
                b := qc_b;
            } else {
            }
        }
	}
}
